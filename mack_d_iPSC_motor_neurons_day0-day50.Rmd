---
title: "iPSC Motor Neurons Time-series Data"
author: "Jenny L Smith"
date: "`R Sys.Date()`"
output: html_document
---

# Set-up 

```{r set-up, echo=FALSE}
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
knitr::opts_chunk$set(tidy.opts=list(width.cutoff=80),
                      tidy=TRUE,
                      fig.align='center',
                      fig.width = 10, fig.height = 10,
                      eval = TRUE)

options(stringsAsFactors = FALSE, max.print = 100)
options(Seurat.object.assay.version = 'v5')
table = function (..., useNA = 'ifany') base::table(..., useNA = useNA)
```

```{r message=FALSE,warning=FALSE}
library(dplyr)
library(tidyr)
library(magrittr)
library(stringr)
library(tibble)
library(glue)

library(ggplot2)
library(plotly)
library(RColorBrewer)

library(Seurat)
library(SeuratDisk)
library(SeuratObject)
library(SeuratWrappers)
library(Matrix)
library(SeuratObject)
library(SeuratData)
library(SeuratWrappers)

library(scDblFinder)
library(SoupX)
```

```{r}
conflicted::conflict_prefer("select", "dplyr")
conflicted::conflict_prefer("filter","dplyr")
conflicted::conflict_prefer("saveRDS","base")
```

# Parallelization 

```{r}
library(future)
# check the current active plan
plan()
```

```{r}
plan("multisession", workers = 16)
plan()
options(future.globals.maxSize = 60000 * 1024^2)
```

# Background 

## Library prep:

1. Time points between the iPSC ~ day 27: 

  * I froze the cells down along the differentiation at each time point from the same batch, by making multiple wells from the beginning. 
  * When the diff reached day 27, I ended up having frozen vials of cells at 10 different time points (iPSC, d3, d5, d8, d11, d15, d18, d21, d24, d27).
  * Since the 10x Chromium protocol recommends running the library experiment no more than 5 libraries at a time, I split them into 2 sets (5 time points each) and serially made the libraries. The reason for doing the freeze-thawing step in the early phase of differentiation -> Running the library experiment with the fresh (unfrozen) cells from all 16 different time points in one day was unrealistic. 
  * But by experience, we knew that the cells younger than day27 survive pretty well (viability >75%) after getting defrosted. So we decided to use the freeze-thawing strategy for those early time points and make libraries whenever we want. 

2. Time points after day 27: 

  * Since the cells after the neurogenic phase do not survive well after the freeze-thawing cycle, we had to use 'fresh' culture for these library preps. 
  * So I thawed & plated the day18 progenitor stock vials on several different days to do a sort of temporally 'staggered culture' 
  * I harvested the 5 groups of cells (d30, d35, d40, d45, d50) on the same day for library experiment. 
  * These 5 libraries were made on the same day. 
  
Did the library prep use multiplexed samples?    
https://support.10xgenomics.com/single-cell-gene-expression/software/pipelines/latest/what-is-cellplex -> 

> No. I used one library per GEM well, but not mixing the libraries until the actual sequencing run with the Illumina cartridge. Please refer to the 10x protocol I used for all of the library prep: 

https://cdn.10xgenomics.com/image/upload/v1660261285/support-documents/CG000204_ChromiumNextGEMSingleCell3_v3.1_Rev_D.pdf

  
**Mack Lab diff protocol derives stem cells into ventral horn of the spinal cord which not only have motor neurons but different subtypes of interneurons.**


## Human iPSCs

https://www.nature.com/articles/ncomms7626

https://www.ncbi.nlm.nih.gov/books/NBK554616/

The neurons are differentiated from WTC11 iPSCs. https://hpscreg.eu/cell-line/UCSFi001-A. For the MN differentiation, I attached our MN diff protocol used for this experiment. 
>Population: Japanese.
Omics: Genome sequenced.
Derived from sampling site: Leg; skin. Cell type=Fibroblast.

To help with understanding what cell types we might expect at Day 0 and early time-points. -> for the undifferentiated iPSC, we expect the culture enriched with pluripotent cells, usually show high expression of OCT4 (POU5F1), SOX2, NANOG. 

https://github.com/regan-hamel/h-iPSCs-MNI/blob/master/R%20workflow_iMNs_LThiry_2020.Rmd

GTEX - fibroblasts
https://biospecimens.cancer.gov/resources/sops/docs/GTEx_SOPs/BBRB-PR-0004-W1%20GTEx%20Tissue%20Harvesting%20Work%20Instruction.pdf

>Preferred Location: Left or right leg (designate side) 2 cm below
patella on medial side. If not available, an “other” location should be
chosen.
GTEx Tissue Harvesting Work Instruction
PR-0004-W1 VER. 03.05 Effective Date: mm/dd/yyyy Page 7 of 21
4.3.6.6.2 Procedure: After cleaning with alcohol two times, remove a portion
of skin and send to aliquot processing station. From the skin portion,
prepare two 4 mm squared aliquots, place in fibroblast tube
containing culture medium, and tightly seal with parafilm for
shipment directly to the LDACC (Yellow Kit). Return to skin tissue and
prepare the remaining aliquots of skin and subcutaneous adipose
tissue.
4.3.6.6.3 Skin for Fibroblast Culture
4.3.6.6.3.1 Skin, fibroblast culture: Two 4 mm x 4 mm x thickness.
Thickness not to exceed 4 mm.
4.3.6.6.4 Skin Tissue for Fixation in PAXgene®
Underlying visible
subcutaneous fat should be trimmed off.


# Sample Manifest

See https://support.10xgenomics.com/single-cell-gene-expression/software/pipelines/latest/output/gex-metrics

```{r}
expn_mats <- dir("resources", pattern = "filtered_feature_bc.+h5|filtered_feature_bc_matrix.h5", recursive = TRUE, full.names = TRUE) %>% 
  grep("too few", ., value=TRUE, invert = TRUE)

raw_mats <- dir("resources", pattern = "raw_feature_bc", recursive = TRUE, full.names = TRUE) 

summaries <- dir("resources", pattern = "^metrics_summary.csv", recursive = TRUE, full.names = TRUE) %>% 
  grep("too few", ., value=TRUE, invert = TRUE)

length(expn_mats)
length(raw_mats)
length(summaries)
```

```{r}
sample_manifest <- data.frame(expression_matrix_path = expn_mats, 
                              raw_matrix_path = raw_mats,
                              summary_path=summaries) %>%
  mutate(time_point=str_split_fixed(expression_matrix_path, pattern="/", n=3)[,2]) %>% 
  mutate(sample_id=paste0("iPSC_", tolower(time_point)), 
         organism="human", 
         tissue="motor_neuron", 
         cell_type="iPSC") %>% 
  mutate(time_point=gsub("Day", "", time_point) %>% gsub("iPSC", 0, .) %>% as.numeric(.)) %>% 
  mutate(batch=case_when(
    time_point < 15 ~ "batch1",
    time_point >= 15 & time_point < 30 ~ "batch2",
    time_point >= 30 & time_point <= 50 ~ "batch3"
  )) %>% 
  arrange(time_point) %>% 
  filter(!grepl("too few cells", expression_matrix_path)) %>% 
  select(sample_id, time_point,batch, organism:cell_type, everything())

qc_data <- purrr::map_dfr(1:nrow(sample_manifest), function(i){
    read.csv(sample_manifest[i,'summary_path']) %>% 
      janitor::clean_names() %>% 
      mutate(sample_id=sample_manifest[i,'sample_id']) %>% 
      mutate_all(~as.character(.)) %>% 
      select(sample_id, everything())
}) 

sample_manifest <- sample_manifest %>% 
  left_join(., qc_data, by="sample_id") %>% 
  mutate(across(.cols = c(estimated_number_of_cells:number_of_reads, total_genes_detected:median_umi_counts_per_cell),
                .fns =  ~as.numeric(gsub(",","", .x)))) %>% 
  rename_at(vars(valid_barcodes:fraction_reads_in_cells), ~paste0(.,"_percent")) %>% 
  mutate(across(.cols = matches("_percent$"),
                .fns =  ~as.numeric(gsub("\\%","", .x))))

# sample_manifest
dim(sample_manifest)
# any(duplicated(sample_manifest$sample_id))
# write.csv(sample_manifest, "samples/mack_d_iPSC_motor_neurons_sample_manifest_v2.csv", row.names = FALSE)
```

### CellRanger Summary Plots

```{r}
colors <- c("#E41A1C", "#377EB8", "#4DAF4A", "#F781BF", 
            "blue1", "darkslategray3", "burlywood3", "#984EA3", 
            "#FF7F00", "seagreen1", "maroon", "orchid", "darkblue", 
            "azure2", "chartreuse1", "orange1", 
            "deeppink", "darkslategray1", "green4", "navajowhite2", 
            "brown3", "darkgoldenrod4", "deepskyblue1", "lightcoral") %>% 
  c(., ggpubr::get_palette("jco", 4),
    ggpubr::get_palette("npg", 4)) %>% 
  c("darkorchid1","magenta", "peru")

length(colors) #35
```

```{r}
qc_plots_data <- sample_manifest %>% 
  select(sample_id, batch, 
         estimated_number_of_cells,
         median_genes_per_cell, 
         number_of_reads,
         sequencing_saturation_percent, 
         valid_barcodes_percent, 
         reads_mapped_confidently_to_genome_percent,
         reads_mapped_confidently_to_transcriptome_percent, 
         total_genes_detected) %>% 
  pivot_longer(cols = -c(sample_id,batch),
               names_to = "stat", 
               values_to = "value") %>% 
  mutate(sample_id=factor(sample_id, levels=unique(sample_id)))

# head(qc_plots_data)
```

```{r fig.height=10, fig.width=10}
p1 <- ggplot(qc_plots_data, aes(x = stat, y=value)) +
  geom_boxplot(outlier.color = NA) +
  geom_point(aes(color=sample_id), position = position_jitter(width = 0.2), 
             size=1.5) +
  facet_wrap(~stat, scales = 'free') +
  scale_color_manual(values=c(brewer.pal(8, "Set1"), 
                              ggpubr::get_palette(7, palette = "jco")[-1], 
                              "darkseagreen2")) +
  theme_classic() +
  theme(legend.position = 'top', 
        text = element_text(size=8))

# pdf("figures/day0_day50/cellranger_qc_metrics_boxplots.pdf", height = 10, width = 10)
# p1
# dev.off()
```

```{r fig.height=10, fig.width=10}

p2 <- ggplot(qc_plots_data, aes(x = batch, y=value, fill=batch)) +
  geom_boxplot(outlier.color = NA, alpha=0.25) +
  geom_point(aes(color=sample_id), 
             position = position_jitter(width = 0.2, height = 0), 
             size=1.5) +
  facet_wrap(~stat, scales = 'free') +
  scale_fill_manual(values=c("seashell3", "paleturquoise3", "pink")) +
  scale_color_manual(values=c(brewer.pal(8, "Set1"), 
                              ggpubr::get_palette(7, palette = "jco")[-1], 
                              "darkseagreen2")) +
  theme_classic() +
  theme(legend.position = 'top', 
        text = element_text(size=8))

# pdf("figures/day0_day50/cellranger_qc_metrics_byBatch_boxplots.pdf", height = 10, width = 10)
# p2
# dev.off()
```


# Genome Refs

```{r eval=FALSE}
suppressPackageStartupMessages(library(ensembldb))

# db <- ensDbFromGtf("resources/genome/Homo_sapiens.GRCh38.109.chr.gtf.gz")

#Warning: Could not determine length for all seqnames
db <- ensDbFromGtf(gtf = "/gpfs/shared_data/10X/cellranger-7.0.0/refdata-gex-GRCh38-2020-A/genes/genes.gtf", 
                   genomeVersion = "GRCh38",
                   organism = "Homo_sapiens",
                   version = 98)
```

```{r}
edb <- ensembldb::EnsDb("resources/genome/Homo_sapiens.GRCh38.98.sqlite")

# edb
```

```{r}
gids <- ensembldb::keys(edb, keytype = "GENEID")

idmap <- AnnotationDbi::select(edb, keytype="GENEID", 
                      keys = gids, 
                      columns = c("GENEID","GENEBIOTYPE","GENENAME","SYMBOL")) %>% 
  janitor::clean_names()

# head(idmap)
# dim(idmap) #36601
```

```{r}
marker_genes_mc <- read.csv("resources/cell_refs/allen_institute/allen_institute_azimuth_marker_gene_list.csv") %>% 
  mutate(Label = gsub("\\s{1,}|\\/|-","_", Label)) %>% 
  pull(Markers , name = Label) %>% 
  as.list() %>% 
  sapply(.,  function(x) str_split(gsub("\\.","-",x), pattern = ", "))
```

```{r}
# https://github.com/regan-hamel/h-iPSCs-MNI/blob/master/R%20workflow_iMNs_LThiry_2020.Rmd
marker_genes_iPSC <- list(MNPCs = c("CHAT", "ISL1", "ISL2", "MNX1", "OLIG2", "NEUROG2"),
                INs = c("PAX3", "VSX2", "GATA3", "SOX14", "SIM1", "LBX1", "TLX3"),
                NPCs = c("SOX1", "SOX2", "MKI67"),
                Glial = c("SOX9", "S100B", "GFAP"),
                Oligodendrocytes = c("PDGFRA", "GALC"),
                iPSCs = c("NANOG", "POU5F1"))
```

```{r}
marker_genes_endoderm <- c("CXCR4", "KRT12", "SOX17", "KLF8", "MYCT1", "DKK4", "GATA4", "GATA6","SOX7", "EOMES","KRT19","CLDN6","FOXA1","FOXA2")

length(marker_genes_endoderm)
```

```{r eval=FALSE}
ref_expn <- read.delim("resources/human_protein_atlas/rna_single_cell_type.tsv") %>% 
  janitor::clean_names()

# head(ref_expn)
```

```
wget https://storage.googleapis.com/gtex_analysis_v8/annotations/GTEx_Analysis_v8_Annotations_SampleAttributesDS.txt
wget https://storage.googleapis.com/gtex_analysis_v8/rna_seq_data/GTEx_Analysis_2017-06-05_v8_RNASeQCv1.1.9_gene_median_tpm.gct.gz
```
https://gtexportal.org/home/tissue/Cells_Cultured_fibroblasts?tissueSelect=Cells_Cultured_fibroblasts

```{r eval=FALSE}
gtex_samples <- read.delim("resources/GTEX/GTEx_Analysis_v8_Annotations_SampleAttributesDS.txt")

# head(gtex_samples)

gtex_fibroblast_genes <- read.delim("resources/GTEX/GTEx_Analysis_2017-06-05_v8_RNASeQCv1.1.9_gene_median_tpm.gct", comment.char = "#", skip = 2) %>% 
  janitor::clean_names() %>% 
  select(name:description, matches("fibroblast")) %>% 
  arrange(desc(cells_cultured_fibroblasts)) %>% 
  filter(!grepl("^MT-|^GAPDH|^RP[LS]", description)) %>% 
  dplyr::slice(1:10)

# head(gtex_fibroblast_genes)
```

```{r eval=FALSE}
HB_genes <- RCurl::getURI(url = "https://www.genenames.org/cgi-bin/genegroup/download?id=940&type=node") %>% 
  str_split(., "\n") %>% 
  lapply(., function(x) str_split_fixed(x, pattern = "\t", n=13)) %>% 
  as.data.frame() %>% 
  set_colnames(.[1,]) %>% 
  janitor::clean_names() %>% 
  filter(!grepl("Approved symbol|^$", approved_symbol))

# head(HB_genes)
```


# Read in iPSC Object

```{r}
filtered_matrices <- sample_manifest %>% 
  pull(expression_matrix_path, name = sample_id)

length(filtered_matrices)
# temp <- Read10X_h5(filtered_matrices[3])
# head(temp)
# head(rownames(temp)) #gene symbols
# grep("^MT-", rownames(temp), value = TRUE) #OK
```

```{r eval=FALSE}
seurat_objs <- purrr::map(seq_along(filtered_matrices), function(i){
  id <- names(filtered_matrices)[i]
  path <- filtered_matrices[i]
  counts <- Read10X_h5(path)
  seurat_obj <-  CreateSeuratObject(counts=counts,
                                    assay="RNA",
                                    project=id)
  
  seurat_obj <- PercentageFeatureSet(seurat_obj,
                                   assay="RNA",
                                   pattern = "^MT-",
                                   col.name = "percent.mt")
  seurat_obj <- PercentageFeatureSet(seurat_obj,
                                     assay="RNA",
                                     pattern = "^RP[SL]", 
                                     col.name = "percent.ribo")
})
names(seurat_objs) <- names(filtered_matrices)
# seurat_objs$iPSC_ipsc$percent.ribo %>% quantile()
# seurat_objs$iPSC_ipsc$percent.mt %>%  quantile()

if(exists("seurat_objs")){
  job::job({
      dir.create("results/day0_day50/seurat/individual_objs", recursive = TRUE)
      base::saveRDS(seurat_objs, "results/individual_objs/mack_iPSC_motor_neuron_day0-day50_seurat_obj_list.RDS")
  }, import = c("seurat_objs"))
}
```

```{r eval=FALSE}
if(!exists("seurat_objs")){
  seurat_objs <- readRDS("results/day0_day50/seurat/individual_objs/mack_iPSC_motor_neuron_day0-day50_seurat_obj_list.RDS")
}

length(seurat_objs) #15
names(seurat_objs)
# sapply(seurat_objs, dim)

# missing 1,630 - need to map these. 
table(rownames(seurat_objs$iPSC_ipsc@assays$RNA@meta.features) %in% idmap$genename) 

merged_obj <- merge(x = seurat_objs$iPSC_ipsc,
                    y = seurat_objs[grep("iPSC_ipsc", names(seurat_objs), invert = TRUE)],
                    add.cell.ids=names(filtered_matrices),
                    project="iPSC")


# An object of class Seurat 
# 33538 features across 61518 samples within 1 assay 
# Active assay: RNA (33538 features, 0 variable features)
#  2 layers present: counts, data
merged_obj 

if(exists("merged_obj")) {
  job::job({
      saveRDS(merged_obj,"results/day0_day50/seurat/iPSC_motor_neuron_day0-day50_time-course_Seurat_obj.RDS")
  }, import = c("merged_obj"))
}
```


```{r}
current_path <- file.path("results/day0_day50/seurat")
current_obj <- "iPSC_motor_neuron_day0-day50_time-course_filtered_merged_soupX_normalized_seurat_obj_v5.RDS" #v5 Seurat Object
  # "iPSC_motor_neuron_day0-day50_time-course_filtered_merged_soupX_seurat_obj_v3.RDS" #v3 Seurat object
  # "iPSC_motor_neuron_day0-day50_time-course_filtered_merged_soupX_normalized_seurat_obj.RDS"
preprocess_merge_obj <- "iPSC_motor_neuron_day0-day50_time-course_SCT_UMAP_LeidenClust_Seurat_obj.RDS"

if(!exists("merged_obj") & !is.null(current_obj)){
  message(glue("Loading the merged object {current_obj}"))
  if(grepl("normalized", current_obj)){
      merged_norm_obj <- readRDS(file.path(current_path, current_obj))
      merged_norm_obj$id <- factor(merged_norm_obj$orig.ident, levels = c(unique(merged_norm_obj$orig.ident)))
  }else{
    merged_filt_obj <- readRDS(file.path(current_path, current_obj))
  }

}else if(!exists("merged_obj") & is.null(current_obj) ){
  message(glue("Loading the preprocessed merged object {preprocess_merge_obj}"))
  merged_obj <- readRDS(file.path(current_path, preprocess_merge_obj))
}
```


## QC Plots

nFeature_RNA is the number of genes detected in each cell. 
* Low nFeature_RNA for a cell indicates that it may be dead/dying or an empty droplet.

nCount_RNA is the total number of molecules (UMI) detected within a cell. 

* High nCount_RNA and/or nFeature_RNA indicates that the "cell" may in fact be a doublet (or multiplet).

```{r eval=FALSE, fig.height=5, fig.width=10}
# pdf("figures/day0_day50/iPSC_MN_seurat_all_QC_metrics_noFilter.pdf", height = 10, width = 15)
Idents(merged_obj) <- merged_obj$orig.ident
VlnPlot(
  object = merged_obj,
  features = c("nCount_RNA", "nFeature_RNA", "percent.mt","percent.ribo"),
  ncol = 2,
  alpha = 0.5,
  pt.size = 0
)
# dev.off()
```

# Preprocess QC 

https://satijalab.org/seurat/articles/sctransform_vignette.html
https://nbisweden.github.io/workshop-scRNAseq/labs/compiled/seurat/seurat_01_qc.html#MitoRibo_filtering

```{r eval=FALSE}
merged_obj <- SCTransform(merged_obj, vst.flavor = "v2", verbose = T) %>%
    RunPCA(npcs = 50, verbose = T) %>%
    RunUMAP(reduction = "pca", dims = 1:50, verbose = T) %>%
    FindNeighbors(reduction = "pca", dims = 1:50, verbose = T) %>%
    FindClusters(resolution = 0.8, verbose = T)

# merged_obj

new_meta <- merged_obj@meta.data %>% 
  rownames_to_column("barcode") %>% 
  left_join(., sample_manifest, by=c("orig.ident"="sample_id"))

merged_obj <- AddMetaData(merged_obj,metadata = new_meta)
merged_obj@meta.data %>% head()
# merged_obj@reductions$umap # Number of dimensions: 2 

# saveRDS(merged_obj, "results/day0_day50/seurat/iPSC_motor_neuron_day0-day50_time-course_SCT_UMAP_LeidenClust_Seurat_obj.RDS")
```

```{r fig.height=10, fig.width=10, eval=FALSE}
# pdf("figures/day0_day50/iPSC_MN_seurat_UMAP_noFilter.pdf", height = 15, width = 15)
DimPlot(merged_obj, label = T, repel = T, label.size = 7) + 
  scale_color_manual(values = colors) +
  ggtitle("Unsupervised clustering")
# dev.off()

merged_obj$time_point_day <- factor(paste0("day_",merged_obj$time_point),
                                    levels=unique(paste0("day_",merged_obj$time_point)))

# as.data.frame(table(merged_obj$batch, merged_obj$time_point_day))

d1 <- DimPlot(merged_obj, 
        group.by = c("batch","time_point_day"),
        label = T, 
        repel = T,
        label.size = 7) + 
  scale_color_manual(values = colors)

# pdf("figures/day0_day50/iPSC_MN_seurat_UMAP_batch_day_noFilter.pdf", height = 15, width = 20)
d1
# dev.off()

# pdf("figures/day0_day50/iPSC_MN_seurat_PCA_elbow_noFilter.pdf", height = 5, width = 10)
# ElbowPlot(merged_obj,ndims = 50)
# dev.off()
# 
# pdf("figures/day0_day50/iPSC_MN_seurat_PCA_loadings_noFilter.pdf", height = 10, width = 10)
# VizDimLoadings(merged_obj, dims = 1:4, reduction = "pca")
# dev.off()
# 
# # Identify the 10 most highly variable genes
# top10 <- head(VariableFeatures(merged_obj), 10)
# 
# # plot variable features with and without labels
# plot1 <- VariableFeaturePlot(merged_obj)
# plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)
# 
# pdf("figures/day0_day50/iPSC_MN_seurat_topVarFeatures_noFilter.pdf", height = 5, width = 10)
# plot2
# dev.off()


n_cells_barplot <- merged_obj@meta.data %>% 
  mutate(id=factor(orig.ident, levels=unique(orig.ident))) %>% 

  ggplot(., aes(x=id,fill=id)) +
  geom_bar() +
  scale_fill_manual(values=colors) +
  theme_classic() +
  theme(axis.text.x = element_text(angle=25, vjust=1, hjust=1))

# png("figures/day0_day50/iPSC_MN_seurat_number_cells_per_day_noFilter.png", height = 5, width = 8, units = "in", res = 150)
n_cells_barplot
# dev.off()

median_umis <- merged_obj@meta.data %>% 
  mutate(id=factor(orig.ident, levels=unique(orig.ident))) %>% 
  select(id, median_umi_counts_per_cell, batch) %>% 
  distinct() %>% 

  ggplot(., aes(y=id, x = median_umi_counts_per_cell, fill = batch)) +
  geom_col() +
  theme_classic()

# png("figures/day0_day50/cellranger_qc_metrics_byBatch_median_UMIs.png", height = 8, width = 7, units = "in",res = 150)
median_umis
# dev.off()
```

# Doublet Scores

scDblFinder operation
  * The input data for scDblFinder (denoted x below) can be either i) a count matrix (full or sparse), with genes/features as rows and cells/droplets as columns; or ii) an object of class SingleCellExperiment. 
  * the object should not contain empty drops, but should **not otherwise have undergone very stringent filtering** (which would bias the estimate of the doublet rate). 
  
> initial processing, artificial doublets (either random or between-cluster, depending on the settings) are generated, then a nearest neighbor (kNN) network is generated. 

> Rather than selecting a single neighborhood size, as most kNN-based methods do, scDblFinder gathers statistics at various neighborhood sizes, thereby enabling the downstream classifier to select the most informative size(s), which might also differ across the expression space. 

Doublet Considerations:
  * https://bioinformatics-core-shared-training.github.io/CrukCiScRnaSeqMatDev/AnaWiSce/AnaCourse1/BookDownCourse1/doubletDetectionTop.html
  * "Doublet detection procedures should only be applied to libraries generated in the same experimental batch. It is obviously impossible for doublets to form between two cells that were captured separately." 
  * "It is also difficult to interpret doublet predictions in data containing cellular trajectories."

10x Doublets expected:
  * https://kb.10xgenomics.com/hc/en-us/articles/360001378811-What-is-the-maximum-number-of-cells-that-can-be-profiled-
  * closer to 4.8% expected by the docs, though many must be excluded by CellRanger in the filtered_bc_matrix

Benchmarks:
 - https://f1000research.com/articles/10-979/v2#ref19
 - https://arxiv.org/pdf/2101.08860.pdf
 - https://www.ncbi.nlm.nih.gov/pmc/articles/PMC7897250/

```{r eval=FALSE}
if(!exists("seurat_objs")){
  seurat_objs <- readRDS("results/individual_objs/mack_iPSC_motor_neuron_day0-day50_seurat_obj_list.RDS")
}

job::job({
  
  doublet_scores <- purrr::map_dfr(names(seurat_objs), function(x){
    
        outfile <- glue::glue("results/individual_objs/mack_{x}_motor_neuron_SCT_doublets_seurat_obj.RDS")
        
        if(!file.exists(outfile)){
          
          print(glue("Processing {x}"))
          # normalize
          obj <- SCTransform(seurat_objs[[x]], method = "glmGamPoi")  
          
          # cluster
          obj <- obj %>%
            RunPCA(npcs = 50, verbose = F) %>%
            RunUMAP(n.components = 3, reduction = "pca",
                    dims = 1:50, verbose = F) %>%
            FindNeighbors(reduction = "pca", dims = 1:50, verbose = F) %>%
            FindClusters(resolution = 0.8, verbose = F)
          
          print(glue("SCE to doublet finder {x}"))
          sce <- Seurat::as.SingleCellExperiment(obj)
          doublets <- computeDoubletDensity(sce,  
                                            k = 50, #default
                                            subset.row = VariableFeatures(obj))
          doublets_clust <- scDblFinder(sce,
                                        clusters = "seurat_clusters", 
                                        nfeatures = VariableFeatures(obj), 
                                        k = NULL, #default - allow alg to select K from examining a number of different values. 
                                        returnType = "table")
          
          print(glue("Update Metadata for {x}"))
          obj <- AddMetaData(obj, metadata = as.data.frame(obj@reductions$umap@cell.embeddings))
          obj$doublet_score <- doublets
          obj$doublet_outlier <- obj$doublet_score > quantile(obj$doublet_score, probs = c(0.98)) # assume 2% doublet rate?
          obj <- AddMetaData(obj, metadata = filter(as.data.frame(doublets_clust), type =="real"))
          
          print(glue("Saving {outfile}"))
          base::saveRDS(obj,outfile)
        }else{
          print(glue("Reading in {x}"))
          obj <- readRDS(outfile)
        }
        
        meta <- as.data.frame(obj@meta.data)
        return(meta)
      })
  # save the results in a csv file
  write.csv(doublet_scores, "results/doublet_scores/mack_iPSC_MN_day0-day50_scDblFinder_scores.csv", row.names = TRUE)
}, import = c("seurat_objs"))
```

```{r}
doublet_scores <- read.csv("results/doublet_scores/mack_iPSC_MN_day0-day50_scDblFinder_scores.csv") %>% 
  mutate(id=factor(orig.ident, levels=unique(orig.ident)),
         barcode=X) %>%
  left_join(., sample_manifest, by=c("orig.ident"="sample_id")) %>%
  rename_at(vars(cluster,SCT_snn_res.0.8, seurat_clusters), ~paste0(.,"_per_sample"))

# head(doublet_scores)
dim(doublet_scores) #61518    69 
```

```{r eval=FALSE}
doublet_scores %>% 
  select(orig.ident,barcode,
         distanceToNearest,score,
         class,matches("^ratio")) %>% 
  head()
```

```{r eval=FALSE}
purrr::map(unique(doublet_scores$orig.ident), function(x){
  
  basefile <- glue("figures/day0_day50/doublets/iPSC_MN_doublet_scores_{x}")
  chk <- doublet_scores %>% 
    filter(orig.ident == x)
  
  p1 <- ggplot(chk, aes(x=umap_1, y=umap_2, color = as.factor(seurat_clusters_per_sample))) +
      geom_point(alpha=0.7) +
      scale_color_manual(values=colors) +
      theme_classic()

  p2 <-  ggplot(chk, aes(x=umap_1, y=umap_2, color = doublet_score)) +
    geom_point() +
    scale_color_viridis_c() +
    theme_classic()
  
  p3 <- ggplot(chk, aes(x=umap_1, y=umap_2, color = doublet_outlier)) +
    geom_point(alpha=0.7) +
    scale_color_viridis_d(direction = -1) +
    theme_classic()
  
  p4 <- ggplot(chk, aes(x=umap_1, y=umap_2, color = score)) +
    geom_point() +
    scale_color_viridis_c() +
    theme_classic()
  
  p5 <- ggplot(chk, aes(x=umap_1, y=umap_2, color = class)) +
    geom_point(alpha=0.7) +
    scale_color_viridis_d() +
    theme_classic()
  
  png(glue(basefile, "_computeDoubletDensity.png"), width = 20, height = 8, res=150, units = "in")
  print(p1 + p2 + p3 + patchwork::plot_layout(guides = 'collect') + patchwork::plot_annotation(title = x))
  dev.off()
  
  png(glue(basefile, "_scDblFinder.png"), width = 20, height = 8, res=150, units = "in")
  print(p1 + p4 + p5 + patchwork::plot_layout(guides = 'collect') + patchwork::plot_annotation(title = x))
  dev.off()

}) 
```

```{r}
# pdf("figures/day0_day50/doublets/iPSC_MN_doublet_scores_scDblFinder_barplot.pdf", height = 7, width = 12)
doublet_scores %>% 
  mutate(class=factor(class, levels=rev(c("doublet","singlet")))) %>% 
ggplot(., aes(x=id, fill=class)) +
  geom_bar() +
  scale_fill_manual(values=colors) +
  labs(y="number of cells",x="") +
  theme_classic() +
  theme(axis.text.x = element_text(angle=25, vjust=1, hjust=1))
# dev.off()
```


```{r fig.height=5, fig.width=10, eval=FALSE}
# pdf("figures/day0_day50/doublets/iPSC_MN_scDblFinder_noFilter_ridgePlot.pdf", height = 10, width = 10)
ggplot(doublet_scores, aes(y=id, x=score, fill=id)) +
  ggridges::stat_density_ridges(quantile_lines = TRUE, 
                                quantiles = 0.5, alpha=0.75, 
                                scale = 0.9) +
  geom_point(aes(color=id), 
             shape="|",
             size=2,
             alpha=0.7,
             position = position_nudge(y=-0.15)) +
  scale_fill_manual(values=colors) +
  scale_color_manual(values=colors) +
  theme_classic()
# dev.off()
```


# Filter Cells

https://www.10xgenomics.com/resources/analysis-guides/common-considerations-for-quality-control-filters-for-single-cell-rna-seq-data

From Yadav 2023

>All the 10x runs for each human sample were initially filtered with an nUMI cutoff of >1000 and then nuclei with less than 5% mitochondrial gene contamination were retained. Next, the mitochondrial genes were also removed from the matrices. A total of 55,289 nuclei that passed quality control filtering, with mean detection of 2,187 genes per nucleus (Figure S1).

```{r}
seurat_objs_dbls <- dir("results/individual_objs", 
                        pattern = "mack_.+_motor_neuron_SCT_doublets_seurat_obj.RDS", full.names = TRUE) %>% 
  set_names(str_split_fixed(basename(.), "_", n=4)[,3])

head(seurat_objs_dbls)
length(seurat_objs_dbls)
```

```{r eval=FALSE}
job::job({
  # loop through each sample and create dynamic filting thresholds
  filter_objs <- purrr::map(names(seurat_objs_dbls), function(x){
    
        outfile <- glue::glue("results/individual_objs/mack_{x}_motor_neuron_filtered_seurat_obj.RDS")
        out_summary <- glue("results/day0_day50/seurat/filtering_stats/mack_iPSC_{x}_day0-day50_cell_filtering_threshold_summary.csv")
        input <- readRDS(seurat_objs_dbls[x])
    
        if(!file.exists(outfile) | !file.exists(out_summary)){
          
          print(glue("Processing {x}"))
          mito_outlier <- scuttle::isOutlier(input$percent.mt, type="higher")
          rb_outlier <- scuttle::isOutlier(input$percent.ribo, type="lower")
          ncount_outlier <- scuttle::isOutlier(input$nCount_RNA, type="higher")
          nfeat_outlier <- scuttle::isOutlier(input$nFeature_RNA, type="higher")
          
          
          mito_th <- attr(mito_outlier,which = "thresholds")["higher"]
          rb_th <- attr(rb_outlier,which = "thresholds")["lower"]
          ncount_th <- attr(ncount_outlier,which = "thresholds")["higher"]
          nfeat_th <- attr(nfeat_outlier,which = "thresholds")["higher"]
          
          to_retain <- WhichCells(input, 
                                  expression = 
                                    nFeature_RNA > 200 & #at least 200 genes assayed per cell
                                    percent.ribo > rb_th &
                                    percent.mt < mito_th &
                                    class == "singlet")
          input$to_retain <- as.numeric(colnames(input) %in%  to_retain)
          
          d1 <- DimPlot(input)
          f1 <- FeaturePlot(input, 
                            features = c("percent.mt","percent.ribo","to_retain"),
                            ncol=3)
          
          outplot <- glue("figures/day0_day50/filtering/mack_{x}_motor_neuron_filtered_seurat_UMAP.png")
          png(outplot,height = 7, width = 20, units="in", res=150)
          print(d1 + f1 + patchwork::plot_annotation(title=x) + patchwork::plot_layout(widths = c(0.5, 1)))
          dev.off()
          
          sub_filt_obj <- subset(
                          x = input,
                          subset = 
                            nFeature_RNA > 200 &
                            percent.ribo > rb_th &
                            percent.mt < mito_th &
                            class == "singlet"
                        )

          print(glue("Saving {outfile}"))
          base::saveRDS(sub_filt_obj, outfile)
          # Save the thresholds to a file
          ths <-  data.frame(sample=x,
                           mito_th=mito_th,
                           rb_th=rb_th,
                           ncount_th=ncount_th,
                           nfeat_th=nfeat_th,
                           input_number_cells=ncol(input),
                           output_number_cells=ncol(merged_filt_obj))
          write.csv(ths,out_summary, row.names = FALSE)

        }else{
          print(glue("Reading in RDS results for {x}"))
          sub_filt_obj <- readRDS(outfile)
        }
        return(sub_filt_obj)
      })
  names(filter_objs) <- paste0("iPSC_", names(seurat_objs_dbls))
  
}, import = c("seurat_objs_dbls"))
```

```{r}
threshold_summary <- read.csv("results/day0_day50/seurat/filtering_stats/mack_iPSC_MN_day0-day50_cell_filtering_threshold_summary.csv") %>% 
  mutate(id=factor(id, levels=levels(doublet_scores$id))) %>% 
  arrange(id)


threshold_summary %>% head()
dim(threshold_summary) #15 36
```

```{r}
# pdf("figures/day0_day50/filtering/mack_iPSC_motor_neuron_day0-day50_filtered_seurat_mito_thresholds_updated.pdf", height = 7, width = 10)
ggplot(threshold_summary, aes(x=batch, y=mito_th, fill=batch)) +
  geom_boxplot(alpha=0.25) +
  geom_point(aes(color=id),
             size=2,
             position = position_jitter(width = 0.2, seed=2023)) +
  scale_fill_brewer(palette = "Blues") +
  scale_color_manual(values = colors) +
  ggrepel::geom_text_repel(aes(label=id)) +
  labs(x="",y="Mitochondrial Reads Threshold (%)") +
  guides(color="none") +
  theme_classic() +
  theme(axis.text.x = element_text(angle=25, vjust=1, hjust=1))
# dev.off()
```

```{r fig.width=10}
# png("figures/day0_day50/filtering/mack_iPSC_motor_neuron_day0-day50_filtered_seurat_barplot_updated.png",height = 8, width = 12, unit="in", res=150)
threshold_summary %>% 
  pivot_longer(cols = c(input_number_cells,output_number_cells), 
               names_to = "status",
               values_to = "number_of_cells") %>% 
  group_by(id) %>% 
  mutate_at(vars(percent), ~ifelse(duplicated(percent), "", paste0(.,"%\nretained"))) %>% 
  ungroup() %>% 


ggplot(., aes(y = number_of_cells, x = id, fill = status)) +
  geom_col(position = position_dodge()) +
  labs(x="") +
  scale_y_continuous(limits = c(0, 10500)) +
  geom_text(aes(label = percent), nudge_y = 300) +
  scale_fill_viridis_d(option = "turbo", begin = 0.1) +
  theme_classic() +
  theme(axis.text.x = element_text(angle=25, vjust=1, hjust=1))
# dev.off()
```



# SoupX

SoupX
  * https://rawcdn.githack.com/constantAmateur/SoupX/204b602418df12e9fdb4b68775a8b486c6504fe4/inst/doc/pbmcTutorial.html
  * https://academic.oup.com/gigascience/article/9/12/giaa151/6049831
  * https://github.com/constantAmateur/SoupX/issues/44
    * "Ideally you should run doublet removal first and exclude these cells when running SoupX, but it will make little practical difference." 
  * https://github.com/constantAmateur/SoupX/issues/47


The contamination fraction is parametrised as rho in the code, with rho=0 meaning no contamination and rho=1 meaning 100% of UMIs in a droplet are soup.

While it is possible to run SoupX without clustering information, you will get far better results if some basic clustering is provided. Therefore, it is strongly recommended that you provide some clustering information to SoupX. 


>  If you try and run it on a channel with  (e.g. a cell line, flow-sorted cells), you will likely get a warning, an error, and/or an extremely high contamination estimate. In such circumstances your best option is usually to manually set the contamination to something reasonable.

```bash
# move the day5 and day 8 to archive but likely wont need these
mv iPSC_day8 ../../00_archive/
mv iPSC_day5 ../../00_archive/
```

```{r eval=FALSE}
if(!exists("filter_objs")){
  seurat_objs_filt <- dir("results/individual_objs", 
                          pattern = "mack_.+_motor_neuron_filtered_seurat_obj.RDS",
                          full.names = TRUE) %>% 
    set_names(str_split_fixed(basename(.), "_", n=4)[,2])
  
  filter_objs <- purrr::map(seurat_objs_filt, function(x) {
          obj <- readRDS(x) 
    })
  names(filter_objs) <- paste0("iPSC_", names(filter_objs))
}
length(filter_objs) #15

outdirs <- glue("results/soupX_counts/{names(filter_objs)}")
#Read in the previous processed data
soup_channels <- readRDS("results/soupX_counts/mack_iPSC_MN_soupX_channel_objs_list.RDS")
length(soup_channels) #14
# only re-processes new data sets
for(dir in outdirs){
  if(!dir.exists(dir)){
    x <- basename(dir)
    print(x)
    subset <- sample_manifest %>%
      filter(sample_id == x)

    full_counts <- Read10X_h5(subset$raw_matrix_path)
    filt_obj <- filter_objs[[x]]
    cell_counts <- filt_obj@assays$RNA@counts
    clusts <- filt_obj@meta.data$seurat_clusters
    dim_red <- filt_obj@reductions$umap@cell.embeddings

    sc <- SoupChannel(tod=full_counts,
                      toc=cell_counts)
    sc <- setClusters(sc, clusts)
    sc <- suppressWarnings(setDR(sc, dim_red))
    soup_channels[[x]] <- sc
  }
}
length(soup_channels) #15

names(outdirs) <- basename(outdirs)
outdirs <- outdirs[levels(doublet_scores$id)] #re-order the entries by time
est_first_pass <- purrr::map(outdirs, function(dir){
  min <- 1
  sc <- soup_channels[[basename(dir)]]
  outfile2 <- glue("figures/day0_day50/soupX/{basename(dir)}_autoEstCont_figure.pdf")
  # if(!dir.exists(dir)){
     print(dir)
     tryCatch(expr = {
      # estimate contamination fraction
      adj_sc <-  autoEstCont(sc, tfidfMin = min,
                             doPlot = FALSE,
                             verbose = FALSE)
  
    }, error = function(err){
      print(glue("{dir} Too homogenous for reliable estimate"))
      return(NULL)
    })
  
    if(exists("adj_sc")){
      pdf(outfile2, height = 7, width = 10)
      autoEstCont(adj_sc, tfidfMin = min, verbose = FALSE)
      dev.off()
      return(adj_sc)
    }else{
      return(dir)
    }
  # }
})
names(est_first_pass) <- names(outdirs)

# Manually adjust the missing datasets using the mean rho value from all other samples  
missing <- sapply(est_first_pass, function(x) is.character(x))
ave_rho <- round(mean(sapply(est_first_pass[!missing],  function(x) unique(x$metaData$rho))), digits = 3)
remaining_est <- purrr::map(names(est_first_pass[missing]), function(x){
  print(x)
   sc <- soup_channels[[x]]
    # set contamination fraction
    adj_sc <-  setContaminationFraction(sc,ave_rho)
})
names(remaining_est) <- names(est_first_pass[missing])

# save the results 
final_estimates <- c(est_first_pass[!missing], remaining_est)
final_estimates <- final_estimates[names(outdirs)]
length(final_estimates) #15
save_corrected_counts <- purrr::map(outdirs, function(outdir){
  if(!dir.exists(outdir)){
    print(outdir)
    x <- basename(outdir)
    out = adjustCounts(final_estimates[[x]])
    DropletUtils:::write10xCounts(outdir, out)
  }
})

job::job({
  saveRDS(soup_channels, "results/soupX_counts/mack_iPSC_MN_day0-day50_soupX_channel_objs_list.RDS")
}, import = c("soup_channels"))
```



There are some issues in the plotting functions that haven't been updated. 
* https://github.com/constantAmateur/SoupX/issues/102

```{r eval=FALSE}

plotMarkerDistribution(sc = soup_channels, 
                       nonExpressedGeneList = NULL,
                       maxCells = 150, 
                       tfidfMin = 1)

```


* iPSC_day40
4833 cells default filters 
  - estimates ~20% contamination fraction which is wildly high. 
4497 cells after addition filters
 - estimates ~6% contamination fraction which is FAR more sensible
 
* iPSC_ipsc (day 0)
 - causes errors "No plausible marker genes found.  Is the channel low complexity (see help)?  If not, reduce tfidfMin or soupQuantile"
 - regardless of level of filtering
 - has to due with this population being lowerer completexity/ mostly 1 cell-type 
    
```{r eval=FALSE}
estimates_df <- purrr::map_dfr(names(final_estimates), function(x){
  final_estimates[[x]]$metaData %>% 
    rownames_to_column("barcode") %>% 
    mutate(sample = x)
}) %>% 
  mutate(id=factor(sample, levels=levels(doublet_scores$id)))

head(estimates_df)
table(estimates_df$id)
# write.csv(estimates_df, "results/soupX_counts/mack_iPSC_MN_day0-day50_soupX_contamination_estimates.csv", row.names = FALSE)
```


```{r}
if(!exists("estimates_df")){
  estimates_df <- read.csv("results/soupX_counts/mack_iPSC_MN_day0-day50_soupX_contamination_estimates.csv") %>% 
    mutate(id=factor(sample, levels=levels(doublet_scores$id)))
}

head(estimates_df)
estimates_df %>% 
  select(rho, sample) %>% 
  distinct()
```

```{r}
est_df_subset <- estimates_df %>% 
  select(id, rho) %>% 
  distinct()  %>% 
  mutate(id=factor(id, levels=levels(doublet_scores$id)))


est_plot <- ggplot(est_df_subset, aes(x =  id, y=rho, fill = id)) +
  geom_col() +
  scale_fill_manual(values = colors) +
  geom_hline(yintercept = 0.05, linetype="dashed") +
  labs(title="SoupX Ambient DNA Contamination Estimates", y="contamination fraction", x="") +
  theme_classic() +
  scale_y_continuous(limits=c(0,0.15)) +
  theme(axis.text.x = element_text(angle = 25, vjust = 1, hjust = 1))

# png("figures/day0_day50/soupX/iPSC_MN_contamination_estimates_update.png", height = 5, width = 8, units = "in", res = 150)
est_plot
# dev.off()
```


# Merge Filtered Objects

```{r eval=FALSE}
preprocess_merge_obj <- "iPSC_motor_neuron_day0-day50_time-course_SCT_UMAP_LeidenClust_Seurat_obj.RDS"
merged_obj <- readRDS(file.path(current_path, preprocess_merge_obj))
```

```{r eval=FALSE}
options(Seurat.object.assay.version = "v3")

outs <- dir("results/soupX_counts",pattern = "^iPSC", full.names = TRUE)
names(outs) <- basename(outs)
# head(outs)
length(outs) #15

metadata <- merged_obj@meta.data

soupx_objs <- purrr::map(outs, function(res){

  counts <- Read10X(res)
  id <- basename(res)
  print(glue("{id}"))
  
  mdata <- metadata %>% 
    filter(orig.ident == id) %>% 
    mutate(barcode=gsub("^iPSC_[A-Za-z].+_","", barcode)) %>% 
    filter(barcode %in% intersect(colnames(counts), barcode)) %>% 
    set_rownames(.$barcode) %>% 
    as.data.frame()
    
  seurat_obj <-  CreateSeuratObject(counts=counts, 
                                    assay="RNA",
                                    project = id, 
                                    meta.data = mdata)
  
  seurat_obj <- PercentageFeatureSet(seurat_obj,
                                 assay="RNA",
                                 pattern = "^MT-",
                                 col.name = "filtered_percent.mt")
  
  seurat_obj <- PercentageFeatureSet(seurat_obj,
                                     assay="RNA",
                                     pattern = "^RP[SL]", 
                                     col.name = "filtered_percent.ribo")
})

# reorder the objects
soupx_objs <- soupx_objs[levels(threshold_summary$id)]
names(soupx_objs)
```

```{r eval=FALSE}
job::job({
  sapply(names(soupx_objs), function(x)
    saveRDS(soupx_objs[[x]],glue("results/individual_objs/mack_{x}_motor_neuron_filtered_soupX_seurat_obj_v3.RDS")))
}, import = c("soupx_objs"))
```

```{r eval=FALSE}
VERSION="v3"
options(Seurat.object.assay.version = VERSION)

merged_filt_obj <-  merge(x = soupx_objs$iPSC_ipsc, 
                          y = soupx_objs[grep("ipsc", names(soupx_objs), invert = TRUE)],
                          merge.data = FALSE,
                          add.cell.ids=names(soupx_objs),
                          project="iPSC")


# An object of class Seurat 
# 33538 features across 51534 samples within 1 assay 
# Active assay: RNA (33538 features, 0 variable features)
#  2 layers present: counts, data
merged_filt_obj 
# saveRDS(merged_filt_obj,"results/day0_day50/seurat/iPSC_motor_neuron_day0-day50_time-course_filtered_merged_soupX_seurat_obj.RDS")
```

table(merged_filt_obj@meta.data$time_point)
Layers(merged_filt_obj) # version Seurat object v5 
 [1] "counts.iPSC_ipsc"  "counts.iPSC_day3"  "counts.iPSC_day5"  "counts.iPSC_day8"  "counts.iPSC_day11" "counts.iPSC_day15" "counts.iPSC_day18" "counts.iPSC_day21"
 [9] "counts.iPSC_day24" "counts.iPSC_day27" "counts.iPSC_day30" "counts.iPSC_day35" "counts.iPSC_day40" "counts.iPSC_day45" "counts.iPSC_day50"



# Filtered Dataset Processing

```{r}
#https://github.com/satijalab/seurat/issues/3622
options(future.rng.onMisuse="ignore")
```

From Yadav 2023

> All the 10x runs for each human sample were initially filtered with an nUMI cutoff of >1000 and then nuclei with less than 5% mitochondrial gene contamination were retained. Next, the mitochondrial genes were also removed from the matrices. A total of 55,289 nuclei that passed quality control filtering, with mean detection of 2,187 genes per nucleus (Figure S1).

The FindClusters() function implements this procedure, and contains a resolution parameter that sets the ‘granularity’ of the downstream clustering, with increased values leading to a greater number of clusters. 

We find that setting this parameter between 0.4-1.2 typically returns good results for single-cell datasets of around 3K cells. Optimal resolution often increases for larger datasets. 

```{r eval=FALSE}
VERSION="v3"
options(Seurat.object.assay.version = VERSION)

# remove MT genes
temp <- merged_filt_obj[grep("^MT-", rownames(merged_filt_obj), invert = TRUE), ]

#regularized negative binomial regression to normalize UMI count data
#Note that this single command replaces NormalizeData(), ScaleData(), and FindVariableFeatures().
merged_norm_obj <- SCTransform(temp,
                         assay="RNA",
                         new.assay.name = "SCT",
                         vars.to.regress = "percent.mt",
                         method = "glmGamPoi",
                         return.only.var.genes = FALSE,
                         verbose = TRUE)
```

```{r}
merged_norm_obj <- readRDS("results/day0_day50/seurat/iPSC_motor_neuron_day0-day50_time-course_filtered_merged_soupX_normalized_seurat_obj_v3.RDS")

merged_norm_obj
```

```{r}
merged_norm_obj <-   RunPCA(merged_norm_obj,
                            assay = "SCT",
                            npcs = 50,
                            verbose = TRUE) 

  #     RunUMAP(reduction = "pca",
  #             dims = 1:50, 
  #             n.components = 3,
  #             n.neighbors = 30,# default 30
  #             metric = "cosine",
  #             min.dist = 0.2, # default 0.3
  #             return.model = TRUE,
  #             verbose = T) 
  # 
  # merged_norm_obj <- merged_norm_obj %>% 
  #     FindNeighbors(reduction = "pca",
  #                   dims = 1:50, 
  #                   k.param = 20,
  #                   nn.method = "annoy",
  #                   annoy.metric = "cosine",
  #                   n.trees = 100,
  #                   verbose = T)
  # 
  # merged_norm_obj <- merged_norm_obj %>% 
  #     FindClusters(resolution = 1.0, 
  #                  algorithm = 2, 
  #                  verbose = T) 
  # 
  # merged_norm_obj <- merged_norm_obj %>% 
  #     FindClusters(resolution = 1.5, 
  #                  algorithm = 2, 
  #                  verbose = T)
  # 
  # merged_norm_obj <- AddMetaData(merged_norm_obj,
  #                                as.data.frame(merged_norm_obj@reductions$umap@cell.embeddings))
  # 
  # 
  # merged_norm_obj
```

```{r}
merged_norm_obj <- readRDS("results/day0_day50/seurat/iPSC_motor_neuron_day0-day50_time-course_filtered_merged_soupX_normalized_seurat_obj_v5.RDS")

# Add metadata and idents
merged_norm_obj$id <- factor(merged_norm_obj$orig.ident, levels=unique(merged_norm_obj$orig.ident))
merged_norm_obj$seurat_clusters <- merged_norm_obj$SCT_snn_res.1
Idents(merged_norm_obj) <- merged_norm_obj$SCT_snn_res.1

merged_norm_obj
# class(merged_norm_obj[["RNA"]]) #v5
```

```{r fig.height=10}
# pdf("figures/day0_day50/filtered_merged_results/sct_transform_100PCs_elbow_plot.pdf", height = 7, width=10)
# ElbowPlot(merged_norm_obj,ndims = 50, reduction = "pca")
# dev.off()

# pdf("figures/day0_day50/filtered_merged_results/transform_1-4PCs_loadings.pdf", height = 10, width=7)
# VizDimLoadings(merged_norm_obj, dims = 1:4, reduction = "pca")
# dev.off()

# pdf("figures/day0_day50/filtered_merged_results/byLouvainCluster_sct_UMAP.pdf",height = 10, width= 17)
DimPlot(merged_norm_obj, 
        reduction = "umap",
        dims = c(1,2)) +
  scale_color_manual(values = colors)
# dev.off()
```

```{r fig.height=10}
filt_d1 <- DimPlot(merged_norm_obj, 
        group.by = c("batch","id"),
        label = T, 
        repel = T,
        label.size = 7) + 
  scale_color_manual(values = colors)

# png("figures/day0_day50/filtered_merged_results_iPSC_MN_seurat_UMAP_batch_day_filtered.png", height = 15, width = 25, units = "in", res = 150)
filt_d1
# dev.off()

filt_s1 <- DimPlot(merged_norm_obj, 
        group.by = c("id"),
        split.by = "batch",
        label = T, 
        repel = T,
        label.size = 7) + 
  scale_color_manual(values = colors)

# png("figures/day0_day50/filtered_merged_results_iPSC_MN_seurat_UMAP_splitBy_batch_day_filtered.png",  height = 15, width = 25, units = "in", res = 150)
filt_s1
# dev.off()
```


```{r fig.height=10}
fig <- plot_ly(merged_norm_obj@meta.data,
               x = ~umap_1, y = ~umap_2, z = ~umap_3, 
               color = ~id,
               colors = colors)
fig <- fig %>%
  add_markers(
    marker = list(size = 1),
    text = pull(merged_norm_obj@meta.data, orig.ident, name = barcode),
    hoverinfo = 'text')

# fig <- fig %>% plotly::layout(scene = list(xaxis = list(title = 'PC1'),
#                      yaxis = list(title = 'PC2'),
#                      zaxis = list(title = 'PC3')))

fig
```

```{r eval=FALSE}
Idents(merged_norm_obj) <- merged_norm_obj$orig.ident
purrr::map(names(marker_genes_iPSC), function(type){
 
   h <- ifelse(length(marker_genes_iPSC[[type]]) <= 4, 12, 20)
  outfile <- glue("figures/day0_day50/filtered_merged_results/iPSC_MN_expression_{type}_marker_genes.png")
  
  png(outfile, height = h, width = 20, units = "in", res = 100)
  print(FeaturePlot(merged_norm_obj, 
                    features = marker_genes_iPSC[[type]],
                    label = TRUE) +
          patchwork::plot_annotation(title = glue("{type} marker genes")))
  dev.off()
  
})
```



```{r fig.height=10, fig.width=10}
Idents(merged_norm_obj) <- merged_norm_obj$orig.ident
png("figures/day0_day50/filtered_merged_results/filtered_merged_results_iPSC_MN_seurat_endoderm_markers_p1.png", height = 10, width = 12, res = 100, units="in")
VlnPlot(merged_norm_obj,
        features = marker_genes_endoderm[1:7])
dev.off()

png("figures/day0_day50/filtered_merged_results/filtered_merged_results_iPSC_MN_seurat_endoderm_markers_p2.png", height = 10, width = 12, res = 100, units="in")
VlnPlot(merged_norm_obj,
        features = marker_genes_endoderm[8:14])
dev.off()
```

```{r}
most_var_genes_per_sample <- SCTResults(merged_norm_obj, slot = "feature.attributes")

# most_var_genes_per_sample
```

```{r eval=FALSE}
# Identify the 10 most highly variable genes
top10 <- head(VariableFeatures(merged_norm_obj), 10)

# plot variable features with and without labels
plot1 <- VariableFeaturePlot(merged_norm_obj)
plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)

# pdf("figures/day0_day50/filtered_merged_results/iPSC_MN_seurat_topVarFeatures.pdf", height = 5, width = 10)
plot2
# dev.off()
```

```{r}
umi_counts_filt <-  sapply( Layers(merged_norm_obj@assays$RNA), function(x) {
   colSums(merged_norm_obj@assays$RNA[[x]] > 1)
})


# mean(umi_counts_filt)
med_per_day <- sapply(umi_counts_filt, median)
mean_per_day <- sapply(umi_counts_filt, mean)

# unlist(umi_counts_filt) %>% length()

median(unlist(umi_counts_filt)) # 1723 genes detected across all cells
mean(unlist(umi_counts_filt)) #1885 genes detected across all cells
```

```{r}
data.frame(counts=umi_counts_filt$counts.iPSC_day40) %>% 
  ggplot(., aes(x=counts)) +
  geom_histogram(binwidth = 1)

data.frame(counts=umi_counts_filt$counts.iPSC_ipsc) %>% 
  ggplot(., aes(x=counts)) +
  geom_histogram(binwidth = 1)
```


```{r}
mean_per_day[order(mean_per_day)]
```

# Batch Effect Correction 

return.only.var.genes -
If set to TRUE the scale.data matrices in output assay are subset to contain only the variable genes; default is TRUE

vars.to.regress	- 
Variables to regress out in a second non-regularized linear regression. For example, percent.mito. 

Note on scale_data and return.only.var.genes
- https://github.com/satijalab/seurat/discussions/4259

https://www.sc-best-practices.org/cellular_structure/integration.html
* "one can say that Harmony and Seurat consistently perform well for simple batch correction tasks,"

## Seurat regression 

Since each sample was made a "layer" and so in Layer1 these cells are in the same batch, so lacks 2 factor levels. 

> required or else Error in `contrasts<-`(`*tmp*`, value = contr.funs[1 + isOF[nn]]) :

https://github.com/satijalab/seurat/issues/3657

```{r eval=FALSE}
if(!exists("merged_filt_obj_v3")){
  merged_filt_obj_v3 <- readRDS("results/day0_day50/seurat/iPSC_motor_neuron_day0-day50_time-course_filtered_merged_soupX_seurat_obj_v3.RDS")
}

merged_filt_obj_v3
# class(merged_filt_obj_v3[["RNA"]]) #v3
table(merged_filt_obj_v3$batch)
```

```{r eval=FALSE}
options(Seurat.object.assay.version = 'v3')
  #regularized negative binomial regression to normalize UMI count data
  #Note that this single command replaces NormalizeData(), ScaleData(), and FindVariableFeatures().
  temp <- merged_filt_obj_v3[grep("^MT-", rownames(merged_filt_obj_v3), invert = TRUE), ]
  temp$batch <- as.factor(merged_filt_obj_v3$batch)
  
  merged_norm_batchcorr <- SCTransform(merged_filt_obj_v3,
                             assay="RNA",
                             new.assay.name = "SCT",
                             vars.to.regress = c("batch","percent.mt"),
                             method = "glmGamPoi",
                             return.only.var.genes = TRUE,
                             verbose = TRUE)
  
  merged_norm_batchcorr <- merged_norm_batchcorr %>%  
    RunPCA(npcs = 50, verbose = FALSE) 

  merged_norm_batchcorr <- merged_norm_batchcorr %>% 
    RunUMAP(reduction = "pca",
              dims = 1:50, 
              n.components = 3,
              n.neighbors = 30,# default 30
              metric = "cosine",
              min.dist = 0.2, # default 0.3
              return.model = TRUE,
              verbose = T) 
  
  merged_norm_batchcorr <- merged_norm_batchcorr %>% 
      FindNeighbors(reduction = "pca",
                    dims = 1:50, 
                    k.param = 20,
                    nn.method = "annoy",
                    annoy.metric = "cosine",
                    n.trees = 100,
                    verbose = T)
  
  merged_norm_batchcorr <- merged_norm_batchcorr %>% 
      FindClusters(resolution = 1.0, 
                   algorithm = 2, 
                   verbose = T) 
  
  merged_norm_batchcorr <- merged_norm_batchcorr %>% 
      FindClusters(resolution = 1.5, 
                   algorithm = 2, 
                   verbose = T)
  
  merged_norm_batchcorr <- AddMetaData(merged_norm_batchcorr,
                                 as.data.frame(merged_norm_batchcorr@reductions$umap@cell.embeddings))
  
  # saveRDS(merged_norm_batchcorr, 
  #       "results/day0_day50/seurat/iPSC_motor_neuron_day0-day50_time-course_filtered_merged_soupX_normalized_batchcorrected_seurat_obj_v3.RDS")
```
```{r}
if(!exists("merged_norm_batchcorr")){
  merged_norm_batchcorr <- readRDS(file.path(current_path, "results/day0_day50/seurat/iPSC_motor_neuron_day0-day50_time-course_filtered_merged_soupX_normalized_batchcorrected_seurat_obj_v3.RDS"))
}

merged_norm_batchcorr$id <- factor(merged_norm_batchcorr$orig.ident, 
                                   levels = c(unique(merged_norm_batchcorr$orig.ident)))

merged_norm_batchcorr$seurat_clusters <- merged_norm_batchcorr$SCT_snn_res.1
Idents(merged_norm_batchcorr) <- merged_norm_batchcorr$SCT_snn_res.1

merged_norm_batchcorr
```

```{r fig.height=10}
# pdf("figures/day0_day50/filtered_merged_batchcorrected/batchcorrected_sct_transform_100PCs_elbow_plot.pdf", height = 7, width=10)
# ElbowPlot(merged_norm_batchcorr,ndims = 50, reduction = "pca")
# dev.off()
# 
# pdf("figures/day0_day50/filtered_merged_batchcorrected/batchcorrected_transform_1-4PCs_loadings.pdf", height = 10, width=7)
# VizDimLoadings(merged_norm_batchcorr, dims = 1:4, reduction = "pca")
# dev.off()
# 
# pdf("figures/day0_day50/filtered_merged_batchcorrected/batchcorrected_byLouvainCluster_sct_UMAP.pdf",height = 10, width= 17)
# DimPlot(merged_norm_batchcorr, dims = c(1,2)) +
#   scale_color_manual(values = colors)
# dev.off()
```

```{r fig.height=10}
bc_d1 <- DimPlot(merged_norm_batchcorr, 
        group.by = c("batch","id"),
        label = T, 
        repel = T,
        label.size = 7) + 
  scale_color_manual(values = colors)

# png("figures/day0_day50/filtered_merged_batchcorrected/filtered_merged_results_iPSC_MN_seurat_batchcorrected_UMAP_batch_day_filtered.png", height = 15, width = 25, units = "in", res = 150)
bc_d1
# dev.off()

bc_s1 <- DimPlot(merged_norm_batchcorr, 
        group.by = c("id"),
        split.by = "batch",
        label = T, 
        repel = T,
        label.size = 7) + 
  scale_color_manual(values = colors)

# png("figures/day0_day50/filtered_merged_batchcorrected/filtered_merged_results_iPSC_MN_seurat_batchcorrected_UMAP_splitBy_batch_day_filtered.png", height = 15, width = 25, units = "in", res = 150)
bc_s1
# dev.off()
```


```{r fig.height=10}
fig_batchcorr <- plot_ly(merged_norm_batchcorr@meta.data,
               x = ~umap_1, y = ~umap_2, z = ~umap_3, 
               color = ~id,
               colors = colors)
fig_batchcorr <- fig_batchcorr %>% 
  add_markers( 
    marker = list(size = 1), 
    text = merged_norm_batchcorr@meta.data$orig.ident,
      hoverinfo = 'text')

# fig <- fig %>% plotly::layout(scene = list(xaxis = list(title = 'PC1'),
#                      yaxis = list(title = 'PC2'),
#                      zaxis = list(title = 'PC3')))

fig
```


```{r}
Idents(merged_norm_batchcorr) <- merged_norm_batchcorr$orig.ident
purrr::map(names(marker_genes_iPSC), function(type){    
  h <- ifelse(length(marker_genes_iPSC[[type]]) <= 4, 12, 20)
  outfile <- glue("figures/day0_day50/filtered_merged_batchcorrected/iPSC_MN_batchcorrected_expression_{type}_marker_genes.png")
  
  # png(outfile, height = h, width = 20, units = "in", res = 100)
  print(
    FeaturePlot(merged_norm_batchcorr, 
                    features = marker_genes_iPSC[[type]],
                    label = TRUE) +
          patchwork::plot_annotation(title = glue("{type} marker genes"))
        )
  # dev.off()
  
})
```

```{r}
# Identify the 10 most highly variable genes
top10 <- head(VariableFeatures(merged_norm_batchcorr), 10)

# plot variable features with and without labels
plot1 <- VariableFeaturePlot(merged_norm_batchcorr)
plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)

# pdf("figures/day0_day50/filtered_merged_batchcorrected/iPSC_MN_seurat_batchcorrected_topVarFeatures.pdf", height = 5, width = 10)
plot2
# dev.off()
```


## Harmony 

```{r}
VERSION = 'v5'
```

```{r eval=FALSE}
if VERSION == 'v3'{
  merged_harmony_obj <- merged_filt_obj

  merged_harmony_obj[["RNA"]] <- split(merged_harmony_obj[["RNA"]], f = merged_harmony_obj$sample)
  merged_harmony_obj
}
```

Warning: Groups are set automatically by model when integrating SCT assaysWarning: Quick-TRANSfer stage steps exceeded maximum (= 2694850)Harmony 1/10

2023-08-08 12:31:54.280978: Done. Exporting 12336.2MB: .Random.seed, merged_harmony_obj_batch...
Error in save(list = vars, file = exportRdata, envir = globalenv()) : 
  'file' must be non-empty string
Execution halted

```{r eval=FALSE}

merged_harmony_obj_batch <- IntegrateLayers(
  object = merged_norm_obj,
  group.by = "batch",
  method = HarmonyIntegration,
  orig.reduction = "pca",
  new.reduction = "harmony",
  verbose = TRUE ) %>%
 FindNeighbors(reduction = "harmony",
               dims = 1:50)

merged_harmony_obj_batch <- merged_harmony_obj_batch %>% 
 FindClusters(resolution = 1.0,
              cluster.name = "harmony_clusters") %>% 
    RunUMAP(reduction = "harmony",
            reduction.name = "umap.harmony",
            dims = 1:50, 
            n.components = 3,
            n.neighbors = 30,# default 30
            metric = "cosine",
            min.dist = 0.2, # default 0.3
            return.model = TRUE,
            verbose = T) 

merged_harmony_obj_batch$id <- factor(merged_harmony_obj_batch$orig.ident, levels=unique(merged_harmony_obj_batch$orig.ident))
# saveRDS(merged_harmony_obj_batch, "results/day0_day50/seurat/iPSC_motor_neuron_day0-day50_time-course_filtered_merged_soupX_normalized_harmonyPerBatch_seurat_obj_v5.RDS")

# class(merged_harmony_obj_batch[["RNA"]])
```

```{r eval=FALSE}
# defaults to Layers which are the sample IDs in this case
merged_harmony_obj <- IntegrateLayers(
    object = merged_norm_obj,
    method = HarmonyIntegration,
    orig.reduction = "pca",
    new.reduction = "harmony",
    verbose = TRUE ) %>%
   FindNeighbors(reduction = "harmony",
                 dims = 1:50)
  
merged_harmony_obj <- merged_harmony_obj %>% 
   FindClusters(resolution = 1.0,
                cluster.name = "harmony_clusters") %>% 
   RunUMAP(reduction = "harmony",
           dims = 1:50, 
           reduction.name = "umap.harmony")
  
merged_harmony_obj$id <- factor(merged_harmony_obj$orig.ident, levels=unique(merged_harmony_obj$orig.ident))
# saveRDS(merged_harmony_obj, "results/day0_day50/seurat/iPSC_motor_neuron_day0-day50_time-course_filtered_merged_soupX_normalized_harmonyPerSample_seurat_obj_v5.RDS")
```

```{r}
merged_harmony_obj_batch <- AddMetaData(merged_harmony_obj_batch,
                                        merged_harmony_obj_batch@reductions$umap.harmony@cell.embeddings)
```

```{r fig.height=10}
# pdf("figures/day0_day50/harmony/merged_harmony_obj_batch_sct_transform_100PCs_elbow_plot.pdf", height = 7, width=10)
ElbowPlot(merged_harmony_obj_batch,ndims = 50, reduction = "pca")
# dev.off()

# pdf("figures/day0_day50/harmony/merged_harmony_obj_batch_transform_1-4PCs_loadings.pdf", height = 10, width=7)
VizDimLoadings(merged_harmony_obj_batch, dims = 1:4, reduction = "pca")
# dev.off()

# pdf("figures/day0_day50/harmony/merged_harmony_obj_batch_byLouvainCluster_sct_UMAP.pdf",height = 10, width= 17)
DimPlot(merged_harmony_obj_batch,
        reduction = "umap",
        dims = c(1,2)) +
  scale_color_manual(values = colors)
# dev.off()
```

```{r fig.height=10}
filt_harmony_d1 <- DimPlot(merged_harmony_obj_batch, 
        group.by = c("batch","id"),
        reduction = "umap.harmony", 
        label = T, 
        repel = T,
        label.size = 7) + 
  scale_color_manual(values = colors)

# 
# filt_harmony_d2 <- DimPlot(merged_harmony_obj, 
#         group.by = c("batch","id"),
#         reduction = "umap.harmony",
#         label = T, 
#         repel = T,
#         label.size = 7) + 
#   scale_color_manual(values = colors)

# png("figures/day0_day50/harmony/merged_harmony_obj_batch_iPSC_MN_seurat_UMAP_batch_day_filtered.png", height = 15, width = 25, units = "in", res = 150)
filt_harmony_d1
# dev.off()

```


```{r eval=FALSE}
Idents(merged_harmony_obj_batch) <- merged_harmony_obj_batch$orig.ident
purrr::map(names(marker_genes_iPSC), function(type){
 
   h <- ifelse(length(marker_genes_iPSC[[type]]) <= 4, 12, 20)
  outfile <- glue("figures/day0_day50/harmony/merged_harmony_obj_batch_iPSC_MN_expression_{type}_marker_genes.png")
  
  png(outfile, height = h, width = 20, units = "in", res = 100)
  print(FeaturePlot(merged_harmony_obj_batch, 
                    features = marker_genes_iPSC[[type]],
                    label = TRUE) +
          patchwork::plot_annotation(title = glue("{type} marker genes")))
  dev.off()
})
```

```{r}
merged_harmony_obj_batch
Idents(merged_harmony_obj_batch) <- merged_harmony_obj_batch$orig.ident
```

```{r fig.height=10, fig.width=10}
# png("figures/day0_day50/harmony/merged_harmony_obj_batch_iPSC_MN_seurat_endoderm_markers_p1.png", height = 10, width = 12, res = 100, units="in")
VlnPlot(merged_harmony_obj_batch,
        features = marker_genes_endoderm[1:7])
# dev.off()

# png("figures/day0_day50/harmony/merged_harmony_obj_batch_iPSC_MN_seurat_endoderm_markers_p2.png", height = 10, width = 12, res = 100, units="in")
VlnPlot(merged_harmony_obj_batch,
        features = marker_genes_endoderm[8:14])
# dev.off()
```

```{r}
fig2 <- plot_ly(merged_harmony_obj_batch@meta.data,
               x = ~umapharmony_1, y = ~umapharmony_2, z = ~umapharmony_3, 
               color = ~id,
               colors = colors)
fig2 <- fig2 %>%
  add_markers(
    marker = list(size = 1),
    text = pull(merged_harmony_obj_batch@meta.data, orig.ident, name = barcode),
    hoverinfo = 'text')

fig2
```

# Session Info

```{r}
session_info()
```






