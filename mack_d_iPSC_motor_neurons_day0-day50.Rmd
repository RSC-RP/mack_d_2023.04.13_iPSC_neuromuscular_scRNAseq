---
title: "iPSC Motor Neurons Time-series Data"
author: "Jenny L Smith"
date: "`R Sys.Date()`"
output: html_document
---

# Set-up 

```{r set-up, echo=FALSE}
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
knitr::opts_chunk$set(tidy.opts=list(width.cutoff=80),
                      tidy=TRUE,
                      fig.align='center',
                      fig.width = 10, fig.height = 10,
                      eval = TRUE)

options(stringsAsFactors = FALSE, max.print = 100)
options(Seurat.object.assay.version = 'v5')
table = function (..., useNA = 'ifany') base::table(..., useNA = useNA)
```

```{r message=FALSE,warning=FALSE}
library(dplyr)
library(tidyr)
library(magrittr)
library(stringr)
library(tibble)
library(glue)

library(ggplot2)
library(plotly)
library(RColorBrewer)

library(Seurat)
# library(SeuratDisk)
# library(SeuratObject)
# library(SeuratWrappers)
# library(Matrix)
# library(SeuratObject)
# library(SeuratData)
# library(SeuratWrappers)

library(scDblFinder)
library(SoupX)
```

```{r}
conflicted::conflict_prefer("select", "dplyr")
conflicted::conflict_prefer("filter","dplyr")
conflicted::conflict_prefer("saveRDS","base")
```

```{r}
colors_vector <- c(RColorBrewer::brewer.pal(12, "Paired"), 
            "blue1", "darkslategray3", "burlywood3", "#984EA3",
            "seagreen1", "yellow2", "orchid", "darkblue", 
            "lightsalmon2","slateblue1","lightskyblue4",
            "azure2", "chartreuse1",  "lemonchiffon2",
            "deeppink", "darkslategray1", "green4", "navajowhite", 
            "brown4", "darkgoldenrod2", "deepskyblue1", "lightpink") %>% 
  c(., ggpubr::get_palette("jco", 5)) %>% 
  c("mediumpurple4","magenta", "peru") %>% 
  c(ggsci::pal_igv()(51))

length(colors_vector) 
```



# Parallelization 

```{r eval=FALSE}
library(future)
# check the current active plan
plan()
plan("multisession", workers = 16)
plan()
options(future.globals.maxSize = 60000 * 1024^2)
```

# Background 

## Library prep:

1. Time points between the iPSC ~ day 27: 

  * I froze the cells down along the differentiation at each time point from the same batch, by making multiple wells from the beginning. 
  * When the diff reached day 27, I ended up having frozen vials of cells at 10 different time points (iPSC, d3, d5, d8, d11, d15, d18, d21, d24, d27).
  * Since the 10x Chromium protocol recommends running the library experiment no more than 5 libraries at a time, I split them into 2 sets (5 time points each) and serially made the libraries. The reason for doing the freeze-thawing step in the early phase of differentiation -> Running the library experiment with the fresh (unfrozen) cells from all 16 different time points in one day was unrealistic. 
  * But by experience, we knew that the cells younger than day27 survive pretty well (viability >75%) after getting defrosted. So we decided to use the freeze-thawing strategy for those early time points and make libraries whenever we want. 

2. Time points after day 27: 

  * Since the cells after the neurogenic phase do not survive well after the freeze-thawing cycle, we had to use 'fresh' culture for these library preps. 
  * So I thawed & plated the day18 progenitor stock vials on several different days to do a sort of temporally 'staggered culture' 
  * I harvested the 5 groups of cells (d30, d35, d40, d45, d50) on the same day for library experiment. 
  * These 5 libraries were made on the same day. 
  
Did the library prep use multiplexed samples?    
https://support.10xgenomics.com/single-cell-gene-expression/software/pipelines/latest/what-is-cellplex -> 

> No. I used one library per GEM well, but not mixing the libraries until the actual sequencing run with the Illumina cartridge. Please refer to the 10x protocol I used for all of the library prep: 

https://cdn.10xgenomics.com/image/upload/v1660261285/support-documents/CG000204_ChromiumNextGEMSingleCell3_v3.1_Rev_D.pdf

  
**Mack Lab diff protocol derives stem cells into ventral horn of the spinal cord which not only have motor neurons but different subtypes of interneurons.**


## Human iPSCs

https://www.nature.com/articles/ncomms7626

https://www.ncbi.nlm.nih.gov/books/NBK554616/

The neurons are differentiated from WTC11 iPSCs. https://hpscreg.eu/cell-line/UCSFi001-A. For the MN differentiation, I attached our MN diff protocol used for this experiment. 
>Population: Japanese.
Omics: Genome sequenced.
Derived from sampling site: Leg; skin. Cell type=Fibroblast.

To help with understanding what cell types we might expect at Day 0 and early time-points. -> for the undifferentiated iPSC, we expect the culture enriched with pluripotent cells, usually show high expression of OCT4 (POU5F1), SOX2, NANOG. 

https://github.com/regan-hamel/h-iPSCs-MNI/blob/master/R%20workflow_iMNs_LThiry_2020.Rmd

GTEX - fibroblasts
https://biospecimens.cancer.gov/resources/sops/docs/GTEx_SOPs/BBRB-PR-0004-W1%20GTEx%20Tissue%20Harvesting%20Work%20Instruction.pdf

>Preferred Location: Left or right leg (designate side) 2 cm below
patella on medial side. If not available, an “other” location should be
chosen.
GTEx Tissue Harvesting Work Instruction
PR-0004-W1 VER. 03.05 Effective Date: mm/dd/yyyy Page 7 of 21
4.3.6.6.2 Procedure: After cleaning with alcohol two times, remove a portion
of skin and send to aliquot processing station. From the skin portion,
prepare two 4 mm squared aliquots, place in fibroblast tube
containing culture medium, and tightly seal with parafilm for
shipment directly to the LDACC (Yellow Kit). Return to skin tissue and
prepare the remaining aliquots of skin and subcutaneous adipose
tissue.
4.3.6.6.3 Skin for Fibroblast Culture
4.3.6.6.3.1 Skin, fibroblast culture: Two 4 mm x 4 mm x thickness.
Thickness not to exceed 4 mm.
4.3.6.6.4 Skin Tissue for Fixation in PAXgene®
Underlying visible
subcutaneous fat should be trimmed off.


# Sample Manifest

See https://support.10xgenomics.com/single-cell-gene-expression/software/pipelines/latest/output/gex-metrics


```{r}
sample_manifest <- read.csv("samples/mack_d_iPSC_motor_neurons_sample_manifest_v3.csv")

head(sample_manifest)
```

### Define Manifest 

```{r eval=FALSE}
expn_mats <- dir("resources", pattern = "filtered_feature_bc.+h5|filtered_feature_bc_matrix.h5", 
                 recursive = TRUE, full.names = TRUE) %>% 
  grep("too few", ., value=TRUE, invert = TRUE)

raw_mats <- dir("resources", pattern = "raw_feature_bc", 
                recursive = TRUE, full.names = TRUE) 

length(expn_mats)
length(raw_mats)

summaries <- dir("resources/summary_csv", 
                 pattern = "*.csv", 
                 recursive = FALSE, full.names = TRUE) %>% 
  grep("too few", ., value=TRUE, invert = TRUE)

length(summaries) 
```

```{r eval=FALSE, warning=FALSE}
sample_manifest <- data.frame(expression_matrix_path = expn_mats, 
                              raw_matrix_path = raw_mats, 
                              summary_path = summaries ) %>%
  mutate(time_point=str_split_fixed(expression_matrix_path, pattern="/", n=3)[,2]) %>% 
  mutate(sample_id=paste0("iPSC_", tolower(time_point)), 
         organism="human", 
         tissue="motor_neuron", 
         cell_type="iPSC") %>% 
  mutate(time_point=gsub("Day|Rerun_Day", "", time_point) %>% gsub("iPSC", 0, .) %>% as.numeric(.)) %>% 
  mutate(batch=case_when(
    time_point < 15 ~ "batch1",
    time_point >= 15 & time_point < 30 ~ "batch2",
    grepl("\\/Day(30|35|40|45|50)", expression_matrix_path) ~ "batch3",
    grepl("Rerun_Day(35|40|45|50)", expression_matrix_path) ~ "batch4"
    # time_point >= 30 & time_point <= 50 ~ "batch3"
  )) %>% 
  arrange(time_point) %>% 
  select(sample_id, time_point,batch, organism:cell_type, everything())

# sample_manifest
dim(sample_manifest)
table(sample_manifest$batch)

qc_data <- purrr::map_dfr(1:nrow(sample_manifest), function(i){
  p <- sample_manifest[i,'summary_path']
  read.csv(p) %>% 
      janitor::clean_names() %>% 
      mutate(sample_id=sample_manifest[i,'sample_id']) %>% 
      mutate_all(~as.character(.)) %>% 
      select(sample_id, everything())
}) 

sample_manifest <- sample_manifest %>% 
  left_join(., qc_data, by="sample_id") %>% 
  mutate(across(.cols = c(estimated_number_of_cells:number_of_reads, total_genes_detected:median_umi_counts_per_cell),
                .fns =  ~as.numeric(gsub(",","", .x)))) %>% 
  rename_at(vars(valid_barcodes:fraction_reads_in_cells), ~paste0(.,"_percent")) %>% 
  mutate(across(.cols = matches("_percent$"),
                .fns =  ~as.numeric(gsub("\\%","", .x))))

# any(duplicated(sample_manifest$sample_id))
```

### CellRanger Summary Plots

```{r}
qc_plots_data <- sample_manifest %>% 
  select(sample_id, batch, time_point,
         estimated_number_of_cells,
         median_genes_per_cell, 
         number_of_reads,
         sequencing_saturation_percent, 
         valid_barcodes_percent, 
         reads_mapped_confidently_to_genome_percent,
         reads_mapped_confidently_to_transcriptome_percent, 
         total_genes_detected) %>% 
  pivot_longer(cols = -c(sample_id,batch, time_point),
               names_to = "stat", 
               values_to = "value") %>% 
  mutate(sample_id=factor(sample_id, levels=unique(sample_id)))

# head(qc_plots_data)
```

```{r fig.height=10, fig.width=10}
p1 <- ggplot(qc_plots_data, aes(x = stat, y=value)) +
  geom_boxplot(outlier.color = NA) +
  geom_point(aes(color=sample_id), position = position_jitter(width = 0.2), 
             size=1.5) +
  facet_wrap(~stat, scales = 'free') +
  scale_color_manual(values=colors_vector) +
  theme_classic() +
  theme(legend.position = 'top', 
        text = element_text(size=8))

# pdf("figures/day0_day50/cellranger_qc_metrics_boxplots.pdf", height = 10, width = 10)
p1
# dev.off()
```

```{r fig.height=10, fig.width=10}

p2 <- ggplot(qc_plots_data, aes(x = batch, y=value, fill=batch)) +
  geom_boxplot(outlier.color = NA, alpha=0.25) +
  geom_point(aes(color=sample_id), 
             position = position_jitter(width = 0.2, height = 0, seed = 2023), 
             size=1.5) +
  facet_wrap(~stat, scales = 'free') +
  scale_fill_manual(values=c("seashell3", "paleturquoise3", "pink","dodgerblue1")) +
  scale_color_manual(values=colors_vector) +
  ggrepel::geom_text_repel(aes(label = time_point), size = 3, position = position_jitter(width = 0.2, height = 0, seed = 2023)) +
  theme_classic() +
  theme(legend.position = 'top', 
        text = element_text(size=8))

# pdf("figures/day0_day50/cellranger_qc_metrics_byBatch_boxplots.pdf", height = 10, width = 10)
p2
# dev.off()
```


# Genome Refs

```{r eval=FALSE}
suppressPackageStartupMessages(library(ensembldb))

# db <- ensDbFromGtf("resources/genome/Homo_sapiens.GRCh38.109.chr.gtf.gz")

#Warning: Could not determine length for all seqnames
db <- ensDbFromGtf(gtf = "/gpfs/shared_data/10X/cellranger-7.0.0/refdata-gex-GRCh38-2020-A/genes/genes.gtf", 
                   genomeVersion = "GRCh38",
                   organism = "Homo_sapiens",
                   version = 98)
```

```{r}
edb <- ensembldb::EnsDb("resources/genome/Homo_sapiens.GRCh38.98.sqlite")

# edb

gids <- ensembldb::keys(edb, keytype = "GENEID")
idmap <- AnnotationDbi::select(edb, keytype="GENEID", 
                      keys = gids, 
                      columns = c("GENEID","GENEBIOTYPE","GENENAME","SYMBOL")) %>% 
  janitor::clean_names()

# head(idmap)
# dim(idmap) #36601
```

```{r}
changho_refs_file <- "references/changho_updated_marker_genes_MN_IN_annotation.xlsx"
marker_genes_chun <- purrr::map_dfr(openxlsx::getSheetNames(changho_refs_file)[2:4], function(x){
  openxlsx::read.xlsx(changho_refs_file, sheet = x)
}) %>% 
  janitor::clean_names() %>% 
  distinct() %>% 
  mutate(group=paste(author, tolower(neural_pop)) %>% 
           gsub("\\s","_",.)) %>% 
  mutate(specific_markers_for_each_type_of_neuron=gsub("\\s","", specific_markers_for_each_type_of_neuron))

# marker_genes_chun
marker_genes_chun_list <- purrr::map(unique(marker_genes_chun$group), function(x){
  marker_genes_chun %>%
    filter(group == x) %>%
    pull(specific_markers_for_each_type_of_neuron)
}) %>% 
  set_names(unique(marker_genes_chun$group))
marker_genes_chun_list[["pan_neuronal_markers"]] <- str_split(marker_genes_chun[1,"pan_neuronal_markers"], pattern = ", ", n=3)[[1]]

# marker_genes_chun_list
```

```{r}
# https://github.com/regan-hamel/h-iPSCs-MNI/blob/master/R%20workflow_iMNs_LThiry_2020.Rmd
marker_genes_iPSC <- list(MNPCs = c("CHAT", "ISL1", "ISL2", "MNX1", "OLIG2", "NEUROG2"),
                INs = c("PAX3", "VSX2", "GATA3", "SOX14", "SIM1", "LBX1", "TLX3"),
                NPCs = c("SOX1", "SOX2", "MKI67"),
                Glial = c("SOX9", "S100B", "GFAP"),
                Oligodendrocytes = c("PDGFRA", "GALC"),
                iPSCs = c("NANOG", "POU5F1"))
```

```{r warning=FALSE}
rayon_marker_genes <- openxlsx::read.xlsx(xlsxFile = "resources/cell_refs/Rayon_2021/TableS2.xlsx") %>% 
  janitor::clean_names() %>% 
  mutate(id = paste("rayon", type, neural_pop, sep="_") %>% 
           gsub("\\s", "_", .)) %>% 
  mutate(description = case_when(
    grepl("FP", id) ~ gsub("FP","floor plate", id),
    grepl("RP", id) ~ gsub("RP","roof plate", id),
    grepl("dp", id) ~ gsub("dp[0-9]", "dorsal interneuron progenitors", id),
    grepl("p[0-2]", id) ~ gsub("p[0-2]", "intermediate interneuron progenitors", id),
    grepl("p3", id) ~ gsub("p3","ventral interneuron progenitors p3", id), 
    grepl("V[0-3]", id) ~ gsub("V[0-9].?", "ventral neurons", id),
    grepl("MN", id) ~ gsub(".?MN","motor neuron", id),
    grepl("dl[0-6]", id) ~ gsub("dl[0-9]", "dorsal Interneuron", id),
    grepl("LTMR|LMTR", id) ~ gsub("C?-{0,1}(LTMR|LMTR).{0,}", "mechanoreceptor", id),
    grepl("Proprioceptor|nociceptor", id) ~ gsub("Peripheral","PNS Peripheral",id),
    grepl("Mesoderm|Eryt|Blood|Hema|Myoblast|Oligo", id) ~ paste("rayon",str_split_fixed(id, "_", n=3)[,2]),
    TRUE ~ id
  ) %>% gsub("_"," ", .) %>% gsub("rayon ","", .))


# View(rayon_marker_genes)
# head(rayon_marker_genes)

rayon_marker_genes_long <- rayon_marker_genes %>% 
  separate(genes_map_step1, into = paste0("gene",1:5), sep=", ") %>% 
  separate(genes_map_step2, into = paste0("gene",5:20), sep = ", ") %>% 
  pivot_longer(cols = matches("^gene"),
               names_to = "colname",
               values_to = "genes") %>% 
  filter(!is.na(genes)) 

# rayon_marker_genes_long

rayon_marker_gene_list <-  purrr::map(unique(rayon_marker_genes_long$id), function(x){
  rayon_marker_genes_long %>% 
    filter(id == x) %>% 
    pull(genes) %>% 
    unique()
})
names(rayon_marker_gene_list) <- unique(rayon_marker_genes_long$id)
# rayon_marker_gene_list
```

```{r}
rayon_degs <- openxlsx::read.xlsx("resources/cell_refs/Yadav_2023/1-s2.0-S0896627323000314-mmc5.xlsx", sheet = 1, check.names = FALSE, sep.names = " ") %>% 
  pivot_longer(cols = everything(),
               names_to = "subtype_annotation", 
               values_to = "degs") %>% 
  mutate(names = gsub("-[0-9]{1,2}$","", subtype_annotation) %>% 
           gsub(".+\\s(.+)$", "\\1", .) %>% 
           gsub("\\/|-","_", .))

esc_celltypes <- unique(rayon_degs$names)
rayon_deg_gene_list <-  purrr::map(esc_celltypes, function(x){
  rayon_degs %>%
    filter(names == x) %>%
    pull(degs) %>%
    unique()
})
names(rayon_deg_gene_list) <- esc_celltypes
```

```{r}
mn_subtype_markers <- openxlsx::read.xlsx("references/11122023_Alpha_Gamma_MNs_consolidated marker list.xlsx", sheet = 2)
head(mn_subtype_markers)
# table(mn_subtype_markers$celltype)
```


# Read in iPSC Object

```{r}
current_path <- file.path("results/day0_day50/seurat")
current_obj <- "iPSC_motor_neuron_day0-day50_time-course_filtered_merged_soupX_normalized_seurat_obj_v5.RDS" #v5 Seurat Object
```


# Generate iPSC Seurat Object 

```{r}
filtered_matrices <- sample_manifest %>% 
  pull(expression_matrix_path, name = sample_id)

length(filtered_matrices)

# temp <- Read10X_h5(filtered_matrices[19])
# head(temp[,1:5])
# head(rownames(temp)) #gene symbols
# grep("^MT-", rownames(temp), value = TRUE) #OK
```

```{r eval=FALSE}
seurat_objs <- purrr::map(seq_along(filtered_matrices), function(i){
  id <- names(filtered_matrices)[i]
  path <- filtered_matrices[i]
  counts <- Read10X_h5(path)
  seurat_obj <-  CreateSeuratObject(counts=counts,
                                    assay="RNA",
                                    project=id)
  
  seurat_obj <- PercentageFeatureSet(seurat_obj,
                                   assay="RNA",
                                   pattern = "^MT-",
                                   col.name = "percent.mt")
  seurat_obj <- PercentageFeatureSet(seurat_obj,
                                     assay="RNA",
                                     pattern = "^RP[SL]", 
                                     col.name = "percent.ribo")
})
names(seurat_objs) <- names(filtered_matrices)
# seurat_objs$iPSC_ipsc$percent.ribo %>% quantile()
# seurat_objs$iPSC_ipsc$percent.mt %>%  quantile()

if(exists("seurat_objs")){
  job::job({
      dir.create("results/day0_day50/seurat/individual_objs", recursive = TRUE)
      base::saveRDS(seurat_objs, "results/individual_objs/mack_iPSC_motor_neuron_day0-day50_seurat_obj_list.RDS")
  }, import = c("seurat_objs"))
}
```

```{r eval=FALSE}
if(!exists("seurat_objs")){
  seurat_objs <- readRDS("results/day0_day50/seurat/individual_objs/mack_iPSC_motor_neuron_day0-day50_seurat_obj_list.RDS")
}

length(seurat_objs) #19
names(seurat_objs)
# sapply(seurat_objs, dim)

# missing 1,630 - need to map these. 
table(rownames(seurat_objs$iPSC_ipsc@assays$RNA) %in% idmap$genename) 

merged_obj <- merge(x = seurat_objs$iPSC_ipsc,
                    y = seurat_objs[grep("iPSC_ipsc", names(seurat_objs), invert = TRUE)],
                    add.cell.ids=names(filtered_matrices),
                    project="iPSC")


# An object of class Seurat 
# 33538 features across 61518 samples within 1 assay 
# Active assay: RNA (33538 features, 0 variable features)
#  2 layers present: counts, data
merged_obj 

if(exists("merged_obj")) {
  job::job({
      saveRDS(merged_obj,"results/day0_day50/seurat/iPSC_motor_neuron_day0-day50_time-course_merged_seurat_obj.RDS")
  }, import = c("merged_obj"))
}
```

## QC Plots

nFeature_RNA is the number of genes detected in each cell. 
* Low nFeature_RNA for a cell indicates that it may be dead/dying or an empty droplet.

nCount_RNA is the total number of molecules (UMI) detected within a cell. 

* High nCount_RNA and/or nFeature_RNA indicates that the "cell" may in fact be a doublet (or multiplet).

```{r eval=FALSE, fig.height=5, fig.width=10}
# pdf("figures/day0_day50/iPSC_MN_seurat_all_QC_metrics_noFilter.pdf", height = 10, width = 15)
Idents(merged_obj) <- merged_obj$orig.ident
VlnPlot(
  object = merged_obj,
  features = c("nCount_RNA", "nFeature_RNA", "percent.mt","percent.ribo"),
  ncol = 2,
  alpha = 0.5,
  pt.size = 0
)
# dev.off()
```

# Preprocess QC 

https://satijalab.org/seurat/articles/sctransform_vignette.html
https://nbisweden.github.io/workshop-scRNAseq/labs/compiled/seurat/seurat_01_qc.html#MitoRibo_filtering

```{r eval=FALSE}
if(!exists("merged_obj")) {
  merged_obj <- readRDS("results/day0_day50/seurat/iPSC_motor_neuron_day0-day50_time-course_merged_seurat_obj.RDS")
}

merged_obj <- SCTransform(merged_obj, vst.flavor = "v2", verbose = T) %>%
    RunPCA(npcs = 50, verbose = T) %>%
    RunUMAP(n.components = 3L, reduction = "pca", dims = 1:50, verbose = T) %>%
    FindNeighbors(reduction = "pca", dims = 1:50, verbose = T) %>%
    FindClusters(resolution = 0.8, verbose = T)

# merged_obj

new_meta <- merged_obj@meta.data %>% 
  rownames_to_column("barcode") %>% 
  left_join(., sample_manifest, by=c("orig.ident"="sample_id"))

merged_obj <- AddMetaData(merged_obj,metadata = new_meta)
merged_obj@meta.data %>% head()

# saveRDS(merged_obj, "results/day0_day50/seurat/iPSC_motor_neuron_day0-day50_time-course_SCT_UMAP_Seurat_obj.RDS")
```

```{r eval=FALSE}
# include RNA lognormalized counts for certain data processing steps that require it. 
DefaultAssay(merged_obj) <- "RNA"
merged_obj <- NormalizeData(merged_obj, normalization.method = "LogNormalize")
merged_obj <- FindVariableFeatures(merged_obj, nfeatures = 3000)
```

```{r}
# Cannot visualize the 3000 var genes in SCT with layers.
# Instead Extract the individual var feature dataframes per individual sample. 
DefaultAssay(merged_obj) <- "SCT"
# Identify the 10 most highly variable genes
top10 <- head(VariableFeatures(merged_obj), 10)
var_feats_df <- SCTResults(merged_obj, slot = "feature.attributes")
```

```{r fig.height=10, fig.width=10, eval=FALSE}
pdf("figures/day0_day50/iPSC_MN_seurat_UMAP_noFilter.pdf", height = 15, width = 15)
DimPlot(merged_obj, label = T, repel = T, label.size = 7) + 
  scale_color_manual(values = colors_vector) +
  ggtitle("Unsupervised clustering")
dev.off()

merged_obj$time_point_day <- factor(paste0("day_",merged_obj$time_point),
                                    levels=unique(paste0("day_",merged_obj$time_point)))

# as.data.frame(table(merged_obj$batch, merged_obj$time_point_day))

d1 <- DimPlot(merged_obj, 
        group.by = c("batch","time_point_day"),
        label = T, 
        repel = T,
        label.size = 7) + 
  scale_color_manual(values = colors_vector)

pdf("figures/day0_day50/iPSC_MN_seurat_UMAP_batch_day_noFilter.pdf", height = 15, width = 20)
d1
dev.off()

pdf("figures/day0_day50/iPSC_MN_seurat_PCA_elbow_noFilter.pdf", height = 5, width = 10)
ElbowPlot(merged_obj,ndims = 50)
dev.off()

pdf("figures/day0_day50/iPSC_MN_seurat_PCA_loadings_noFilter.pdf", height = 10, width = 10)
VizDimLoadings(merged_obj, dims = 1:4, reduction = "pca")
dev.off()

n_cells_barplot <- merged_obj@meta.data %>% 
  mutate(id=factor(orig.ident, levels=unique(orig.ident))) %>% 

  ggplot(., aes(x=id,fill=id)) +
  geom_bar() +
  scale_fill_manual(values=colors_vector) +
  theme_classic() +
  theme(axis.text.x = element_text(angle=25, vjust=1, hjust=1))

png("figures/day0_day50/iPSC_MN_seurat_number_cells_per_day_noFilter.png", height = 5, width = 8, units = "in", res = 150)
n_cells_barplot
dev.off()

median_umis <- merged_obj@meta.data %>% 
  mutate(id=factor(orig.ident, levels=unique(orig.ident))) %>% 
  select(id, median_umi_counts_per_cell, batch) %>% 
  distinct() %>% 

  ggplot(., aes(y=id, x = median_umi_counts_per_cell, fill = batch)) +
  geom_col() +
  theme_classic()

png("figures/day0_day50/cellranger_qc_metrics_byBatch_median_UMIs.png", height = 8, width = 7, units = "in",res = 150)
median_umis
dev.off()
```

# Doublet Scores

scDblFinder operation
  * The input data for scDblFinder (denoted x below) can be either i) a count matrix (full or sparse), with genes/features as rows and cells/droplets as columns; or ii) an object of class SingleCellExperiment. 
  * the object should not contain empty drops, but should **not otherwise have undergone very stringent filtering** (which would bias the estimate of the doublet rate). 
  
> initial processing, artificial doublets (either random or between-cluster, depending on the settings) are generated, then a nearest neighbor (kNN) network is generated. 

> Rather than selecting a single neighborhood size, as most kNN-based methods do, scDblFinder gathers statistics at various neighborhood sizes, thereby enabling the downstream classifier to select the most informative size(s), which might also differ across the expression space. 

Doublet Considerations:
  * https://bioinformatics-core-shared-training.github.io/CrukCiScRnaSeqMatDev/AnaWiSce/AnaCourse1/BookDownCourse1/doubletDetectionTop.html
  * "Doublet detection procedures should only be applied to libraries generated in the same experimental batch. It is obviously impossible for doublets to form between two cells that were captured separately." 
  * "It is also difficult to interpret doublet predictions in data containing cellular trajectories."

10x Doublets expected:
  * https://kb.10xgenomics.com/hc/en-us/articles/360001378811-What-is-the-maximum-number-of-cells-that-can-be-profiled-
  * closer to 4.8% expected by the docs, though many must be excluded by CellRanger in the filtered_bc_matrix

Benchmarks:
 - https://f1000research.com/articles/10-979/v2#ref19
 - https://arxiv.org/pdf/2101.08860.pdf
 - https://www.ncbi.nlm.nih.gov/pmc/articles/PMC7897250/

```{r eval=FALSE}
if(!exists("seurat_objs")){
  seurat_objs <- readRDS("results/individual_objs/mack_iPSC_motor_neuron_day0-day50_seurat_obj_list.RDS")
}

# only run for new samples. outputs for previous data are on gpfs not local. 
seurat_objs_all <- seurat_objs
seurat_objs <- seurat_objs[grep("rerun_", names(seurat_objs))]
print(length(seurat_objs))

job::job({
  
  doublet_scores <- purrr::map_dfr(names(seurat_objs), function(x){
    
        outfile <- glue::glue("results/individual_objs/mack_{x}_motor_neuron_SCT_doublets_seurat_obj.RDS")
        
        if(!file.exists(outfile)){
          
          print(glue("Processing {x}"))
          # normalize
          obj <- SCTransform(seurat_objs[[x]], method = "glmGamPoi")
          
          # cluster
          obj <- obj %>%
            RunPCA(npcs = 50, verbose = F) %>%
            RunUMAP(n.components = 3, reduction = "pca",
                    dims = 1:50, verbose = F) %>%
            FindNeighbors(reduction = "pca", dims = 1:50, verbose = F) %>%
            FindClusters(resolution = 0.8, verbose = F)
          
          print(glue("SCE to doublet finder {x}"))
          sce <- Seurat::as.SingleCellExperiment(obj, assay = "SCT")
          doublets <- computeDoubletDensity(sce,  
                                            k = 50, #default
                                            subset.row = VariableFeatures(obj))
          doublets_clust <- scDblFinder(sce,
                                        clusters = "seurat_clusters", 
                                        nfeatures = VariableFeatures(obj), 
                                        k = NULL, #default - allow alg to select K from examining a number of different values. 
                                        returnType = "table")
          
          print(glue("Update Metadata for {x}"))
          obj <- AddMetaData(obj, metadata = as.data.frame(obj@reductions$umap@cell.embeddings))
          obj$doublet_score <- doublets
          obj$doublet_outlier <- obj$doublet_score > quantile(obj$doublet_score, probs = c(0.98)) # assume 2% doublet rate?
          obj <- AddMetaData(obj, metadata = filter(as.data.frame(doublets_clust), type =="real"))
          
          print(glue("Saving {outfile}"))
          base::saveRDS(obj,outfile)
        }else{
          print(glue("Reading in {x}"))
          obj <- readRDS(outfile)
        }
        
        meta <- as.data.frame(obj@meta.data)
        return(meta)
      })
  # save the results in a csv file
  write.csv(doublet_scores, "results/doublet_scores/mack_iPSC_MN_day0-day50_rerun_scDblFinder_scores.csv", row.names = TRUE)
}, import = c("seurat_objs"))
```

```{r}
doublet_scores <- purrr::map_dfr(dir("results/doublet_scores", full.names = TRUE), function(x){
  read.csv(x) %>%
  mutate(id=factor(orig.ident, levels=unique(orig.ident)),
         barcode=X)
}) %>%
  left_join(., sample_manifest, by=c("orig.ident"="sample_id")) %>%
  rename_at(vars(cluster,SCT_snn_res.0.8, seurat_clusters), ~paste0(.,"_per_sample")) %>%
  arrange(time_point, orig.ident) %>% 
  mutate(sample_id=factor(orig.ident, levels=unique(orig.ident))) %>% 
  arrange(sample_id) %>%
  select(sample_id, barcode, everything(), -X)

head(doublet_scores)
dim(doublet_scores) #98532    76
# table(doublet_scores$batch)
# table(doublet_scores$sample_id)
```

```{r eval=FALSE}
doublet_scores %>% 
  select(orig.ident,barcode,
         distanceToNearest,score,
         class,matches("^ratio")) %>% 
  head()
```

```{r eval=FALSE}
purrr::map(unique(doublet_scores$orig.ident), function(x){
  
  basefile <- glue("figures/day0_day50/doublets/iPSC_MN_doublet_scores_{x}")
  chk <- doublet_scores %>% 
    filter(orig.ident == x)
  
  p1 <- ggplot(chk, aes(x=umap_1, y=umap_2, color = as.factor(seurat_clusters_per_sample))) +
      geom_point(alpha=0.7) +
      scale_color_manual(values=colors_vector) +
      theme_classic()

  p2 <-  ggplot(chk, aes(x=umap_1, y=umap_2, color = doublet_score)) +
    geom_point() +
    scale_color_viridis_c() +
    theme_classic()
  
  p3 <- ggplot(chk, aes(x=umap_1, y=umap_2, color = doublet_outlier)) +
    geom_point(alpha=0.7) +
    scale_color_viridis_d(direction = -1) +
    theme_classic()
  
  p4 <- ggplot(chk, aes(x=umap_1, y=umap_2, color = score)) +
    geom_point() +
    scale_color_viridis_c() +
    theme_classic()
  
  p5 <- ggplot(chk, aes(x=umap_1, y=umap_2, color = class)) +
    geom_point(alpha=0.7) +
    scale_color_viridis_d() +
    theme_classic()
  
  png(glue(basefile, "_computeDoubletDensity.png"), width = 20, height = 8, res=150, units = "in")
  print(p1 + p2 + p3 + patchwork::plot_layout(guides = 'collect') + patchwork::plot_annotation(title = x))
  dev.off()
  
  png(glue(basefile, "_scDblFinder.png"), width = 20, height = 8, res=150, units = "in")
  print(p1 + p4 + p5 + patchwork::plot_layout(guides = 'collect') + patchwork::plot_annotation(title = x))
  dev.off()

})
```

```{r}
# pdf("figures/day0_day50/doublets/iPSC_MN_doublet_scores_scDblFinder_barplot.pdf", height = 7, width = 12)
doublet_scores %>% 
  mutate(class=factor(class, levels=rev(c("doublet","singlet")))) %>% 
ggplot(., aes(x=sample_id, fill=class)) +
  geom_bar() +
  scale_fill_manual(values=colors_vector) +
  labs(y="number of cells",x="") +
  theme_classic() +
  theme(axis.text.x = element_text(angle=25, vjust=1, hjust=1))
# dev.off()
```


```{r fig.height=5, fig.width=10, eval=FALSE}
# pdf("figures/day0_day50/doublets/iPSC_MN_scDblFinder_noFilter_ridgePlot.pdf", height = 10, width = 10)
ggplot(doublet_scores, aes(y=sample_id, x=score, fill=id)) +
  ggridges::stat_density_ridges(quantile_lines = TRUE, 
                                quantiles = 0.5, alpha=0.75, 
                                scale = 0.9) +
  geom_point(aes(color=sample_id), 
             shape="|",
             size=2,
             alpha=0.7,
             position = position_nudge(y=-0.15)) +
  scale_fill_manual(values=colors_vector) +
  scale_color_manual(values=colors_vector) +
  theme_classic()
# dev.off()
```


# Filter Cells

https://www.10xgenomics.com/resources/analysis-guides/common-considerations-for-quality-control-filters-for-single-cell-rna-seq-data

From Yadav 2023

>All the 10x runs for each human sample were initially filtered with an nUMI cutoff of >1000 and then nuclei with less than 5% mitochondrial gene contamination were retained. Next, the mitochondrial genes were also removed from the matrices. A total of 55,289 nuclei that passed quality control filtering, with mean detection of 2,187 genes per nucleus (Figure S1).

```{r}
seurat_objs_dbls <- dir("results/individual_objs", 
                        pattern = "mack_.+_motor_neuron_SCT_doublets_seurat_obj.RDS", full.names = TRUE) %>% 
  set_names(gsub("mack_iPSC_|_motor_neuron_.+$", "", basename(.)))

# head(seurat_objs_dbls)
# tail(seurat_objs_dbls)
length(seurat_objs_dbls) # 19
```

```{r eval=FALSE}
job::job({
  # loop through each sample and create dynamic filting thresholds
  filter_objs <- purrr::map(names(seurat_objs_dbls), function(x){
    
        outfile <- glue::glue("results/individual_objs/mack_{x}_motor_neuron_filtered_seurat_obj.RDS")
        out_summary <- glue("results/day0_day50/seurat/filtering_stats/mack_iPSC_{x}_day0-day50_cell_filtering_threshold_summary.csv")
        input <- readRDS(seurat_objs_dbls[x])
    
        if( any(!file.exists(outfile) | !file.exists(out_summary)) ){
          
          print(glue("Processing {x}"))
          mito_outlier <- scuttle::isOutlier(input$percent.mt, type="higher")
          rb_outlier <- scuttle::isOutlier(input$percent.ribo, type="lower")
          ncount_outlier <- scuttle::isOutlier(input$nCount_RNA, type="higher")
          nfeat_outlier <- scuttle::isOutlier(input$nFeature_RNA, type="higher")
          
          
          mito_th <- attr(mito_outlier,which = "thresholds")["higher"]
          rb_th <- attr(rb_outlier,which = "thresholds")["lower"]
          ncount_th <- attr(ncount_outlier,which = "thresholds")["higher"]
          nfeat_th <- attr(nfeat_outlier,which = "thresholds")["higher"]
          
          to_retain <- WhichCells(input, 
                                  expression = 
                                    nFeature_RNA > 200 & #at least 200 genes assayed per cell
                                    percent.ribo > rb_th &
                                    percent.mt < mito_th &
                                    class == "singlet")
          input$to_retain <- as.numeric(colnames(input) %in%  to_retain)
          
          d1 <- DimPlot(input)
          f1 <- FeaturePlot(input, 
                            features = c("percent.mt","percent.ribo","to_retain"),
                            ncol=3)
          
          outplot <- glue("figures/day0_day50/filtering/mack_{x}_motor_neuron_filtered_seurat_UMAP.png")
          png(outplot,height = 7, width = 20, units="in", res=150)
          print(d1 + f1 + patchwork::plot_annotation(title=x) + patchwork::plot_layout(widths = c(0.5, 1)))
          dev.off()
          
          sub_filt_obj <- subset(
                          x = input,
                          subset = 
                            nFeature_RNA > 200 &
                            percent.ribo > rb_th &
                            percent.mt < mito_th &
                            class == "singlet"
                        )

          print(glue("Saving {outfile}"))
          base::saveRDS(sub_filt_obj, outfile)
          # Save the thresholds to a file
          ths <-  data.frame(sample=x,
                           mito_th=mito_th,
                           rb_th=rb_th,
                           ncount_th=ncount_th,
                           nfeat_th=nfeat_th,
                           input_number_cells=ncol(input),
                           output_number_cells=ncol(sub_filt_obj))
          write.csv(ths,out_summary, row.names = FALSE)

        }else{
          print(glue("Reading in RDS results for {x}"))
          sub_filt_obj <- readRDS(outfile)
        }
        return(sub_filt_obj)
      })
  names(filter_objs) <- paste0("iPSC_", names(seurat_objs_dbls))
  
}, import = c("seurat_objs_dbls"))
```

```{r}
threshold_summary <- purrr::map_dfr(dir("results/day0_day50/seurat/filtering_stats", full.names = TRUE), function(x){
  read.csv(x) 
}) %>% 
  mutate(sample_id = paste0("iPSC_", sample), 
         percent = round(output_number_cells / input_number_cells * 100, digits = 2)) %>%
  left_join(., sample_manifest, by = c("sample_id")) %>% 
  arrange(time_point, sample_id) %>% 
  mutate(sample_id = factor(sample_id, levels=unique(sample_id))) %>%
  select(sample_id, everything()) %>% 
  arrange(sample_id)

threshold_summary %>% head()
# dim(threshold_summary) #19 35
```

```{r}
# pdf("figures/day0_day50/filtering/mack_iPSC_motor_neuron_day0-day50_filtered_seurat_mito_thresholds.pdf", height = 8, width = 10)
ggplot(threshold_summary, aes(x=batch, y=mito_th, fill=batch)) +
  geom_boxplot(alpha=0.25) +
  geom_point(aes(color=sample_id),
             size=2,
             position = position_jitter(width = 0.2, seed=2023)) +
  scale_fill_brewer(palette = "Blues") +
  scale_color_manual(values = colors_vector) +
  ggrepel::geom_text_repel(aes(label=sample)) +
  labs(x="",y="Mitochondrial Reads Threshold (%)") +
  guides(color="none") +
  theme_classic() +
  theme(axis.text.x = element_text(angle=25, vjust=1, hjust=1))
# dev.off()
```


```{r fig.width=10}
ths_to_plot <- threshold_summary %>% 
  select(sample_id, input_number_cells, output_number_cells) %>% 
  pivot_longer(cols = -sample_id, 
               names_to = "statistic",
               values_to = "number_of_cells") 

labels_df <- threshold_summary %>% 
  select(sample_id, percent, number_of_cells = input_number_cells) %>% 
  mutate(statistic = "input_number_cells") %>% 
  rowwise() %>% 
  mutate(label =paste0(percent,"%\nretained")) %>% 
  ungroup()

bplot <- ggplot(ths_to_plot, aes(x = sample_id,
                        y = number_of_cells,
                        fill = statistic)) +
  geom_col(position = position_dodge()) +
  labs(x="") +
  scale_y_continuous(limits = c(0, 12500), breaks = seq(0,12500, by=1000)) +
  geom_text(data = labels_df,
            mapping = aes(x = sample_id,
                          y = number_of_cells,
                          label = label),
            nudge_y = 400) +
  scale_fill_viridis_d(option = "turbo", begin = 0.1) +
  theme_classic() +
  theme(axis.text.x = element_text(angle=25, vjust=1, hjust=1))

# png("figures/day0_day50/filtering/mack_iPSC_motor_neuron_day0-day50_filtered_seurat_barplot.png",height = 8, width = 16, unit="in", res=150)
bplot
# dev.off()
```


### Day 5 and Day 8 

Day5 and Day8 are outliers in terms of %mito - I'll manually set these to the mean of all the other time-points and filter them again. 

```{r}
threshold_summary %>% 
  filter(grepl("day5$|day8$", sample_id))
```

```{r}
mean_th <- threshold_summary %>% 
  filter(!grepl("day5$|day8$", sample)) %>% 
  summarize(mean_mito_th = mean(mito_th)) %>% 
  pull(mean_mito_th)

mean_th # 7.429377
```


Move the original files to a seperate subdirectory for later, if needed. 

```bash
cd results/individual_objs
mv mack_day{5,8}_* first_pass_filter/
```
```{r}
names(filter_objs)
```

```{r}
redo <- c("iPSC_day5","iPSC_day8")
filter_objs_d5_d8 <- purrr::map(redo, function(x) {
    outfile <- glue::glue("results/individual_objs/mack_{x}_motor_neuron_filtered_seurat_obj.RDS")
    obj <- filter_objs[[x]]
    
    sub_filt_obj <- subset(
            x = obj,
            subset = percent.mt < mean_th)
    base::saveRDS(sub_filt_obj, outfile)
    return(sub_filt_obj)
})
names(filter_objs_d5_d8) <- redo

filter_objs_d5_d8$iPSC_day5$percent.mt %>% quantile()
filter_objs_d5_d8$iPSC_day8$percent.mt %>% quantile()

# Update the filtered objects list
filter_objs[redo] <- filter_objs_d5_d8
```

```{r}
threshold_summary_update <- threshold_summary %>% 
  mutate_at(vars(mito_th), ~case_when(
    sample == "day5" ~ mean_th,
    sample == "day8" ~ mean_th,
    TRUE ~ .
    )) %>%
  mutate_at(vars(output_number_cells), ~case_when(
    sample == "day5" ~ ncol(filter_objs_d5_d8$iPSC_day5),
    sample == "day8" ~ ncol(filter_objs_d5_d8$iPSC_day8),
    TRUE ~ .)) %>% 
  mutate(percent = round(output_number_cells/input_number_cells * 100, digits = 1))

threshold_summary_update
# write.csv(threshold_summary_update, "results/day0_day50/seurat/filtering_stats/mack_iPSC_MN_day0-day50_cell_filtering_final_threshold_summary.csv", row.names = FALSE)
```

```{r}
# pdf("figures/day0_day50/filtering/mack_iPSC_motor_neuron_day0-day50_filtered_seurat_mito_thresholds_update.pdf", height = 7, width = 10)
ggplot(threshold_summary_update, aes(x=batch, y=mito_th, fill=batch)) +
  geom_boxplot(alpha=0.25) +
  geom_point(aes(color=sample_id),
             size=2,
             position = position_jitter(width = 0.2, seed=2023)) +
  scale_fill_viridis_d() +
  scale_color_manual(values = colors_vector) +
  scale_y_continuous(limits = c(0,15)) +
  ggrepel::geom_text_repel(aes(label=sample),
                           position = position_jitter(width = 0.2, seed=2023)) +
  labs(x="",y="Mitochondrial Reads Threshold (%)") +
  guides(color="none") +
  theme_classic() +
  theme(axis.text.x = element_text(angle=25, vjust=1, hjust=1))
# dev.off()
```

```{r fig.width=10}
ths_to_plot <- threshold_summary_update %>% 
  select(sample_id, input_number_cells, output_number_cells) %>% 
  pivot_longer(cols = -sample_id, 
               names_to = "statistic",
               values_to = "number_of_cells") 

labels_df <- threshold_summary_update %>% 
  select(sample_id, percent, number_of_cells = input_number_cells) %>% 
  mutate(statistic = "input_number_cells") %>% 
  rowwise() %>% 
  mutate(label =paste0(percent,"%\nretained")) %>% 
  ungroup()

bplot2 <- ggplot(ths_to_plot, aes(x = sample_id,
                        y = number_of_cells,
                        fill = statistic)) +
  geom_col(position = position_dodge()) +
  labs(x="") +
  scale_y_continuous(limits = c(0, 12500), breaks = seq(0,12500, by = 1000)) +
  geom_text(data = labels_df,
            mapping = aes(x = sample_id,
                          y = number_of_cells,
                          label = label),
            nudge_y = 400) +
  scale_fill_viridis_d(option = "turbo", begin = 0.1) +
  theme_bw() +
  theme(axis.text.x = element_text(angle=25, vjust=1, hjust=1))

# png("figures/day0_day50/filtering/mack_iPSC_motor_neuron_day0-day50_filtered_seurat_barplot_update.png",height = 8, width = 16, unit="in", res=150)
bplot2
# dev.off()
```


# SoupX

SoupX
  * https://rawcdn.githack.com/constantAmateur/SoupX/204b602418df12e9fdb4b68775a8b486c6504fe4/inst/doc/pbmcTutorial.html
  * https://academic.oup.com/gigascience/article/9/12/giaa151/6049831
  * https://github.com/constantAmateur/SoupX/issues/44
    * "Ideally you should run doublet removal first and exclude these cells when running SoupX, but it will make little practical difference." 
  * https://github.com/constantAmateur/SoupX/issues/47


The contamination fraction is parametrised as rho in the code, with rho=0 meaning no contamination and rho=1 meaning 100% of UMIs in a droplet are soup.

While it is possible to run SoupX without clustering information, you will get far better results if some basic clustering is provided. Therefore, it is strongly recommended that you provide some clustering information to SoupX. 


>  If you try and run it on a channel with  (e.g. a cell line, flow-sorted cells), you will likely get a warning, an error, and/or an extremely high contamination estimate. In such circumstances your best option is usually to manually set the contamination to something reasonable.

```{r eval=FALSE}
if(!exists("filter_objs")){
  seurat_objs_filt <- dir("results/individual_objs", 
                          pattern = "mack_.+_motor_neuron_filtered_seurat_obj.RDS",
                          full.names = TRUE) %>% 
    set_names(gsub("mack_|_motor_neuron_filtered.+","", basename(.)) %>% 
                gsub("iPSC_", "", .))
  
  filter_objs <- purrr::map(seurat_objs_filt, function(x) {
          obj <- readRDS(x) 
    })
  names(filter_objs) <- paste0("iPSC_", names(filter_objs))
}
length(filter_objs) #19
```

```{r}
# define output directory locations
outdirs <- glue("results/soupX_counts/{names(filter_objs)}") %>% 
  as.character() %>% 
  set_names(basename(.))

#re-order the entries by time
outdirs <- outdirs[sample_manifest$sample_id] 
length(outdirs) #19
```

```{r eval=FALSE}
# Processes all data sets
soup_channels <- list()
for(dir in outdirs){
  if(! dir %in% names(soup_channels)){
    x <- basename(dir)
    print(x)
    subset <- sample_manifest %>%
      filter(sample_id == x)

    full_counts <- Read10X_h5(subset$raw_matrix_path)
    filt_obj <- filter_objs[[x]]
    cell_counts <- LayerData(filt_obj, assay = "RNA", layer = "counts")
    clusts <- filt_obj@meta.data$seurat_clusters
    dim_red <- filt_obj@reductions$umap@cell.embeddings

    sc <- SoupChannel(tod=full_counts,
                      toc=cell_counts)
    sc <- setClusters(sc, clusts)
    sc <- suppressWarnings(setDR(sc, dim_red))
    soup_channels[[x]] <- sc
  }
}
length(soup_channels) # 19

# save the filtered and raw bc counts soupX channel objects.
job::job({
  saveRDS(soup_channels, "results/soupX_counts/mack_iPSC_MN_day0-day50_soupX_channel_objs_list.RDS")
}, import = c("soup_channels"))
```

```{r, eval=FALSE}
if(!exists("soup_channels")){
  soup_channels <- readRDS("results/soupX_counts/mack_iPSC_MN_day0-day50_soupX_channel_objs_list.RDS")
}

# Calculate estimate of contamination with soupX
est_first_pass <- purrr::map(outdirs, function(dir){
    min <- 1
    sc <- soup_channels[[basename(dir)]]
    outfile2 <- glue("figures/day0_day50/soupX/{basename(dir)}_autoEstCont_figure.pdf")
    
     print(glue("Processing {dir}"))
     # attempt to run the contamination estimate, but some samples will fail due celltype composition
     tryCatch(expr = {
      # estimate contamination fraction
      adj_sc <-  autoEstCont(sc, tfidfMin = min,
                             doPlot = FALSE,
                             verbose = FALSE)
  
    }, error = function(err){
      print(glue("{dir} Too homogenous for reliable estimate"))
      return(NULL)
    })
     
    # generate a plot with the estimated rho if estimate was generated
    if(exists("adj_sc")){
      pdf(outfile2, height = 7, width = 10)
      autoEstCont(adj_sc, tfidfMin = min, verbose = FALSE)
      dev.off()
      return(adj_sc)
    } else {
      # or return the name of the sample that couldn't be analyzed
      return(dir)
    }
})
names(est_first_pass) <- names(outdirs)
```

SoupX Overview:

iPSC_ipsc
  * results/soupX_counts/iPSC_ipsc Too homogenous for reliable estimate
  * regardless of level of filtering
  * has to due with this population being lowerer completexity/ mostly 1 cell-type 
    
iPSC_day3
  * Warning: Fewer than 10 marker genes found.  Is this channel low complexity (see help)?  If not, consider reducing tfidfMin or soupQuantileWarning: Fewer than 10 independent estimates, rho estimation is likely to be unstable.
  
iPSC_day5
  * results/soupX_counts/iPSC_day5 Too homogenous for reliable estimate

* iPSC_day40
4833 cells default filters 
  - estimates ~20% contamination fraction which is wildly high. 
4497 cells after additional filters
 - estimates ~6% contamination fraction which is FAR more sensible
 
    
```{r eval=FALSE}
# sapply(est_first_pass, class)
ests <- sapply(est_first_pass, function(x) ifelse(!is.character(x), unique(x$metaData$rho), NA))

round(mean(ests, na.rm = TRUE), digits = 3)
```

```{r, eval=FALSE}
# Manually adjust the missing datasets using the mean rho value from all other samples  
missing <- grepl("ipsc|y3$|y5$", names(est_first_pass))
ave_rho <- round(mean(sapply(est_first_pass[!missing],  function(x) unique(x$metaData$rho))), digits = 3)
print(ave_rho) #0.052

# update the soup channel objects with the mean estimated fraction
remaining_est <- purrr::map(names(est_first_pass[missing]), function(x){
  print(x)
   sc <- soup_channels[[x]]
    # set contamination fraction
    adj_sc <-  setContaminationFraction(sc,ave_rho)
})
names(remaining_est) <- names(est_first_pass[missing])

# update the final objects list with those that needed manual contamination fraction estimation
final_estimates <- c(est_first_pass[!missing], remaining_est)
final_estimates <- final_estimates[names(outdirs)]
length(final_estimates) #19

# export the corrected counts 
job::job({
  save_corrected_counts <- purrr::map(outdirs, function(outdir){
    if(!dir.exists(outdir)){
      print(outdir)
      x <- basename(outdir)
      out = adjustCounts(final_estimates[[x]])
      DropletUtils:::write10xCounts(outdir, out)
    }
  })
}, import = c("final_estimates", "outdirs"))
```

```{r eval=FALSE}
estimates_df <- purrr::map_dfr(names(final_estimates), function(x){
  final_estimates[[x]]$metaData %>% 
    rownames_to_column("barcode") %>% 
    mutate(sample_id = x)
}) %>% 
  mutate(sample_id=factor(sample_id, levels=unique(sample_id)))

head(estimates_df)
# table(estimates_df$sample_id)
# write.csv(estimates_df, "results/soupX_counts/mack_iPSC_MN_day0-day50_soupX_contamination_estimates.csv", row.names = FALSE)
```

```{r}
est_df_subset <- estimates_df %>% 
  select(sample_id, rho) %>% 
  distinct()

est_plot <- ggplot(est_df_subset, aes(x =  sample_id, y=rho, fill = sample_id)) +
  geom_col() +
  scale_fill_manual(values = colors_vector) +
  geom_hline(yintercept = 0.05, linetype="dashed") +
  labs(title="SoupX Ambient DNA Contamination Estimates", y="contamination fraction", x="") +
  theme_classic() +
  scale_y_continuous(limits=c(0,0.15)) +
  theme(axis.text.x = element_text(angle = 25, vjust = 1, hjust = 1))

# png("figures/day0_day50/soupX/iPSC_MN_contamination_estimates_update.png", height = 7, width = 10, units = "in", res = 150)
est_plot
# dev.off()
```


There are some issues in the plotting functions that haven't been updated. 
* https://github.com/constantAmateur/SoupX/issues/102

```{r eval=FALSE}
plotMarkerDistribution(sc = soup_channels, 
                       nonExpressedGeneList = NULL,
                       maxCells = 150, 
                       tfidfMin = 1)

```



# Merge Filtered Objects

```{r eval=FALSE}
preprocess_merge_obj <- "iPSC_motor_neuron_day0-day50_time-course_SCT_UMAP_Seurat_obj.RDS"
merged_obj <- readRDS(file.path("results/day0_day50/seurat", preprocess_merge_obj))
merged_obj
```

```{r}
print(options()$Seurat.object.assay.version)
```

```{r eval=FALSE}
outs <- dir("results/soupX_counts",pattern = "^iPSC", full.names = TRUE)
names(outs) <- basename(outs)
length(outs) #19

metadata <- merged_obj@meta.data

soupx_objs <- purrr::map(outs, function(res){

  counts <- Read10X(res)
  id <- basename(res)
  print(glue("{id}"))
  
  mdata <- metadata %>% 
    filter(orig.ident == id) %>% 
    mutate(barcode = gsub("^iPSC_[A-Za-z].+_","", barcode)) %>% 
    filter(barcode %in% intersect(colnames(counts), barcode)) %>% 
    set_rownames(.$barcode) %>% 
    as.data.frame()
  
  print(dim(mdata))
  
  seurat_obj <-  CreateSeuratObject(counts=counts, 
                                    assay="RNA",
                                    project = id, 
                                    meta.data = mdata)
  
  seurat_obj <- PercentageFeatureSet(seurat_obj,
                                 assay="RNA",
                                 pattern = "^MT-",
                                 col.name = "filtered_percent.mt")
  
  seurat_obj <- PercentageFeatureSet(seurat_obj,
                                     assay="RNA",
                                     pattern = "^RP[SL]", 
                                     col.name = "filtered_percent.ribo")
})

# reorder the objects
soupx_objs <- soupx_objs[unique(sample_manifest$sample_id)]
names(soupx_objs)
```

```{r eval=FALSE}
job::job({
  sapply(names(soupx_objs), function(x)
    saveRDS(soupx_objs[[x]], glue("results/individual_objs/mack_{x}_motor_neuron_filtered_soupX_seurat_obj.RDS")))
}, import = c("soupx_objs"))
```

```{r eval=FALSE}
VERSION="v5"
options(Seurat.object.assay.version = VERSION)

merged_filt_obj <-  merge(x = soupx_objs$iPSC_ipsc, 
                          y = soupx_objs[grep("ipsc", names(soupx_objs), invert = TRUE)],
                          merge.data = FALSE,
                          add.cell.ids=names(soupx_objs),
                          project="iPSC")


# An object of class Seurat 
# 33538 features across 87870 samples within 1 assay 
# Active assay: RNA (33538 features, 0 variable features)
merged_filt_obj 
saveRDS(merged_filt_obj,glue("results/day0_day50/seurat/iPSC_motor_neuron_day0-day50_time-course_filtered_merged_soupX_seurat_obj_{VERSION}.RDS"))
```


# Filtered Dataset Processing

```{r}
#https://github.com/satijalab/seurat/issues/3622
options(future.rng.onMisuse="ignore")
```

From Yadav 2023

> All the 10x runs for each human sample were initially filtered with an nUMI cutoff of >1000 and then nuclei with less than 5% mitochondrial gene contamination were retained. Next, the mitochondrial genes were also removed from the matrices. A total of 55,289 nuclei that passed quality control filtering, with mean detection of 2,187 genes per nucleus (Figure S1).

The FindClusters() function implements this procedure, and contains a resolution parameter that sets the ‘granularity’ of the downstream clustering, with increased values leading to a greater number of clusters. 

We find that setting this parameter between 0.4-1.2 typically returns good results for single-cell datasets of around 3K cells. Optimal resolution often increases for larger datasets. 

```{r eval=FALSE}
versions = c("v5","v3")

for(VERSION in versions){
  options(Seurat.object.assay.version = VERSION)

  # remove MT genes
  temp <- merged_filt_obj[grep("^MT-", rownames(merged_filt_obj), invert = TRUE), ]
  # object version 
  seurat_class <- class(temp[['RNA']])
  if(seurat_class == VERSION){
    temp <- JoinLayers(temp)
    temp[["RNA"]] <- as(object = temp[["RNA"]], Class = "Assay")
  }
  print(glue())
  #regularized negative binomial regression to normalize UMI count data
  #Note that this single command replaces NormalizeData(), ScaleData(), and FindVariableFeatures().
  merged_norm_obj <- SCTransform(temp,
                           assay="RNA",
                           new.assay.name = "SCT",
                           vars.to.regress = "percent.mt",
                           method = "glmGamPoi",
                           return.only.var.genes = FALSE,
                           verbose = TRUE)
  
  merged_norm_obj <-   RunPCA(merged_norm_obj,
                              assay = "SCT",
                              npcs = 50,
                              verbose = TRUE) %>% 
        RunUMAP(reduction = "pca",
                dims = 1:50,
                n.components = 3,
                n.neighbors = 30,# default 30
                metric = "cosine",
                min.dist = 0.2, # default 0.3
                return.model = TRUE,
                verbose = T)
  
    merged_norm_obj <- merged_norm_obj %>%
        FindNeighbors(reduction = "pca",
                      dims = 1:50,
                      k.param = 20,
                      nn.method = "annoy",
                      annoy.metric = "cosine",
                      n.trees = 100,
                      verbose = T)
  
    merged_norm_obj <- merged_norm_obj %>%
        FindClusters(resolution = 1.0,
                     algorithm = 2,
                     verbose = T)
  
    merged_norm_obj <- merged_norm_obj %>%
        FindClusters(resolution = 1.5,
                     algorithm = 2,
                     verbose = T)
  
    merged_norm_obj <- AddMetaData(merged_norm_obj,
                                   as.data.frame(merged_norm_obj@reductions$umap@cell.embeddings))
    
    saveRDS(merged_norm_obj, glue("results/day0_day50/seurat/iPSC_motor_neuron_day0-day50_time-course_filtered_merged_soupX_normalized_seurat_obj_{VERSION}.RDS"))
  
}
```

```{r}
# Add metadata and idents
merged_norm_obj$id <- factor(merged_norm_obj$orig.ident, levels=unique(merged_norm_obj$orig.ident))
merged_norm_obj$seurat_clusters <- merged_norm_obj$SCT_snn_res.1
Idents(merged_norm_obj) <- merged_norm_obj$orig.ident

merged_norm_obj
class(merged_norm_obj[["RNA"]]) #v5
```

min.dist	
This controls how tightly the embedding is allowed compress points together. Larger values ensure embedded points are moreevenly distributed, while smaller values allow the algorithm to optimise more accurately with regard to local structure. Sensible values are in the range 0.001 to 0.5.

n.neighbors	
This determines the number of neighboring points used in local approximations of manifold structure. Larger values will result in more global structure being preserved at the loss of detailed local structure. In general this parameter should often be in the range 5 to 50.

```{r fig.height=10}
merged_norm_obj <- merged_norm_obj %>% 
          RunUMAP(reduction = "pca",
                dims = 1:30,
                # features = VariableFeatures(merged_norm_obj),
                # assay = 'SCT',
                n.components = 3,
                n.neighbors = 30,# default 30
                metric = "cosine",
                min.dist = 0.01, # default 0.3
                n.epochs = 500,
                return.model = TRUE,
                verbose = T)

merged_norm_obj <- AddMetaData(merged_norm_obj,as.data.frame(merged_norm_obj@reductions$umap@cell.embeddings))

# pdf("figures/day0_day50/filtered_merged_results/sct_transform_100PCs_elbow_plot.pdf", height = 7, width=10)
# ElbowPlot(merged_norm_obj,ndims = 50, reduction = "pca")
# dev.off()

# pdf("figures/day0_day50/filtered_merged_results/transform_1-4PCs_loadings.pdf", height = 10, width=7)
# VizDimLoadings(merged_norm_obj, dims = 1:4, reduction = "pca")
# dev.off()

# pdf("figures/day0_day50/filtered_merged_results/day0-day50_time-course_filtered_merged_byTimePoint_sct_UMAP.pdf",height = 15, width= 17)
DimPlot(merged_norm_obj, 
        reduction = "umap",
        label = TRUE,
        label.size = 8,
        repel = TRUE,
        dims = c(1,2)) +
  scale_color_manual(values = colors_vector) +
  theme(legend.position = 'bottom')
# dev.off()


# pdf("figures/day0_day50/filtered_merged_results/day0-day50_time-course_filtered_merged_byLouvainCluster_sct_UMAP.pdf",height = 15, width= 17)
DimPlot(merged_norm_obj, 
        reduction = "umap",
        group.by = 'seurat_clusters',
        label = TRUE,
        label.size = 10,
        repel = TRUE,
        dims = c(1,2)) +
  scale_color_manual(values = colors_vector) +
  theme(legend.position = 'bottom')
# dev.off()
```

```{r fig.height=10}
filt_d1 <- DimPlot(merged_norm_obj, 
        group.by = c("batch","id"),
        label = T, 
        repel = T,
        label.size = 7) + 
  scale_color_manual(values = colors_vector)

# png("figures/day0_day50/filtered_merged_results/iPSC_MN_seurat_UMAPv2_batch_day_filtered.png", height = 15, width = 25, units = "in", res = 150)
filt_d1
# dev.off()

filt_s1 <- DimPlot(merged_norm_obj, 
        group.by = c("id"),
        split.by = "batch",
        label = T, 
        repel = T,
        label.size = 7) + 
  scale_color_manual(values = colors_vector)

# png("figures/day0_day50/filtered_merged_results/iPSC_MN_seurat_UMAPv2_splitBy_batch_day_filtered.png",  height = 15, width = 25, units = "in", res = 150)
filt_s1
# dev.off()
```


```{r fig.height=10}
fig <- plot_ly(merged_norm_obj@meta.data,
               x = ~umap_1, y = ~umap_2, z = ~umap_3, 
               color = ~id,
               colors_vector = colors_vector)
fig <- fig %>%
  add_markers(
    marker = list(size = 1),
    text = pull(merged_norm_obj@meta.data, orig.ident, name = barcode),
    hoverinfo = 'text')

# fig <- fig %>% plotly::layout(scene = list(xaxis = list(title = 'PC1'),
#                      yaxis = list(title = 'PC2'),
#                      zaxis = list(title = 'PC3')))

fig
```

```{r eval=FALSE}
Idents(merged_norm_obj) <- merged_norm_obj$orig.ident
purrr::map(names(marker_genes_iPSC), function(type){
 
   h <- ifelse(length(marker_genes_iPSC[[type]]) <= 4, 12, 20)
  outfile <- glue("figures/day0_day50/filtered_merged_results/iPSC_MN_expression_{type}_marker_genes.png")
  
  png(outfile, height = h, width = 20, units = "in", res = 100)
  print(FeaturePlot(merged_norm_obj, 
                    features = marker_genes_iPSC[[type]],
                    label = TRUE) +
          patchwork::plot_annotation(title = glue("{type} marker genes")))
  dev.off()
  
})
```

```{r eval=FALSE, fig.height=10, fig.width=10}
Idents(merged_norm_obj) <- merged_norm_obj$orig.ident

purrr::map(names(marker_genes_chun_list), function(type){
 
  h <- ifelse(length(marker_genes_chun_list[[type]]) <= 4, 12, 20)
  base <- glue("figures/day0_day50/filtered_merged_results/iPSC_MN_expression_{type}_marker_genes_")
  
  # png(paste0(base,"FeaturePlot.png"), height = h, width = 20, units = "in", res = 100)
  # print(FeaturePlot(merged_norm_obj, 
  #                   reduction = "umap",
  #                   features = marker_genes_chun_list[[type]],
  #                   label = FALSE) +
  #         patchwork::plot_annotation(title = glue("{type} marker genes")))
  # dev.off()
  # 
  h <- ifelse(length(marker_genes_chun_list[[type]]) <= 4, 8, 15)
  png(paste0(base,"ViolinPlot.png"), height = 8, width = 20, units = "in", res = 100)
print(VlnPlot(merged_norm_obj,
              pt.size = 0,
              features = marker_genes_chun_list[[type]]) +
          patchwork::plot_annotation(title = glue("{type} marker genes")))
  dev.off()
  
})
```


```{r fig.height=10, fig.width=10}
Idents(merged_norm_obj) <- merged_norm_obj$orig.ident
# png("figures/day0_day50/filtered_merged_results/filtered_merged_results_iPSC_MN_seurat_endoderm_markers_p1.png", height = 10, width = 12, res = 100, units="in")
VlnPlot(merged_norm_obj,
        features = marker_genes_endoderm[1:7])
# dev.off()

# png("figures/day0_day50/filtered_merged_results/filtered_merged_results_iPSC_MN_seurat_endoderm_markers_p2.png", height = 10, width = 12, res = 100, units="in")
VlnPlot(merged_norm_obj,
        features = marker_genes_endoderm[8:14])
# dev.off()
```

```{r}
most_var_genes_per_sample <- SCTResults(merged_norm_obj, slot = "feature.attributes")

# most_var_genes_per_sample
```

```{r eval=FALSE}
# Identify the 10 most highly variable genes
top10 <- head(VariableFeatures(merged_norm_obj), 10)

# plot variable features with and without labels
plot1 <- VariableFeaturePlot(merged_norm_obj)
plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)

# pdf("figures/day0_day50/filtered_merged_results/iPSC_MN_seurat_topVarFeatures.pdf", height = 5, width = 10)
plot2
# dev.off()
```



nFeature_RNA is the number of genes detected in each cell. 
* Low nFeature_RNA for a cell indicates that it may be dead/dying or an empty droplet.

nCount_RNA is the total number of molecules (UMI) detected within a cell. 

https://github.com/satijalab/seurat/issues/2101
nFeatures counts any gene with at least 1 UMI count

nFeature_RNA column reports the total number of genes in each cell that have at least one UMI count.

https://www.bioinformatics.babraham.ac.uk/training/10XRNASeq/seurat_workflow.html
nFeature_RNA the number of observed genes (anything with a nonzero count)

```{r}
genes_detected <- merged_norm_obj@meta.data %>% 
  mutate(time_point_day = paste0("day", time_point)) %>% 
  # filter(grepl("day35|day40|day45|day50", time_point_day)) %>% 
  group_by(time_point_day, time_point) %>% 
  summarize(num_cells = n(),
            mean_num_genes_detected_RNA = mean(nFeature_RNA), 
            median_num_genes_detected_RNA = median(nFeature_RNA)) %>% 
  ungroup() %>% 
  arrange(time_point) %>% 
  mutate(time_point_day = factor(time_point_day, levels = unique(time_point_day)))
  # arrange(median_num_genes_detected_RNA)


merged_norm_obj@meta.data %>% 
  summarize(mean = mean(nFeature_RNA),
            median = median(nFeature_RNA))
```

```{r fig.height=10}
pdf("iPSC_MN_seurat_nFeature_UMAP.pdf", height = 10, width = 12)
ggplot(merged_norm_obj@meta.data, aes(x=UMAP_1, y=UMAP_2, color = nFeature_RNA)) +
  geom_point() +
  scale_color_gradient2(low = 'azure', high = 'red') +
  theme_classic()
dev.off()
```

```{r}
cell_color_codes <- c(brewer.pal(8, "Set1"), 
                              ggpubr::get_palette(7, palette = "jco")[-1], 
                              "darkseagreen2")
length(cell_color_codes)
```

```{r fig.width=7}
pdf("iPSC_MN_seurat_nFeature_barplot.pdf", height = 7, width = 12)

ggplot(genes_detected, aes(x=time_point_day, y=mean_num_genes_detected_RNA, fill=time_point_day)) +
  geom_col() +
  scale_fill_manual(values=cell_color_codes) +
  scale_y_continuous(breaks=seq(0,6500, by=500)) +
  theme_classic()

dev.off()
```


```{r}
umi_counts_filt <-  sapply( Layers(merged_norm_obj@assays$RNA), function(x) {
   colSums(merged_norm_obj@assays$RNA[[x]] > 0)
})


# mean(umi_counts_filt)
med_per_day <- sapply(umi_counts_filt, median)
mean_per_day <- sapply(umi_counts_filt, mean)

# unlist(umi_counts_filt) %>% length()

median(unlist(umi_counts_filt)) # 1723 genes detected across all cells
mean(unlist(umi_counts_filt)) #1885 genes detected across all cells
```

```{r}
med_per_day[order(med_per_day)]
```

```{r}
data.frame(counts=umi_counts_filt$counts.iPSC_day40) %>% 
  ggplot(., aes(x=counts)) +
  geom_histogram(binwidth = 100)

data.frame(counts=umi_counts_filt$counts.iPSC_ipsc) %>% 
  ggplot(., aes(x=counts)) +
  geom_histogram(binwidth = 100)
```



# Batch Effect Correction 

return.only.var.genes -
If set to TRUE the scale.data matrices in output assay are subset to contain only the variable genes; default is TRUE

vars.to.regress	- 
Variables to regress out in a second non-regularized linear regression. For example, percent.mito. 

Note on scale_data and return.only.var.genes
- https://github.com/satijalab/seurat/discussions/4259

https://www.sc-best-practices.org/cellular_structure/integration.html
* "one can say that Harmony and Seurat consistently perform well for simple batch correction tasks,"

## Seurat regression 

Since each sample was made a "layer" and so in Layer1 these cells are in the same batch, so lacks 2 factor levels. 

> required or else Error in `contrasts<-`(`*tmp*`, value = contr.funs[1 + isOF[nn]]) :

https://github.com/satijalab/seurat/issues/3657

```{r eval=FALSE}
if(!exists("merged_filt_obj_v3")){
  merged_filt_obj_v3 <- readRDS("results/day0_day50/seurat/iPSC_motor_neuron_day0-day50_time-course_filtered_merged_soupX_seurat_obj_v3.RDS")
}

merged_filt_obj_v3
# class(merged_filt_obj_v3[["RNA"]]) #v3
table(merged_filt_obj_v3$batch)
```

```{r eval=FALSE}
options(Seurat.object.assay.version = 'v3')
  #regularized negative binomial regression to normalize UMI count data
  #Note that this single command replaces NormalizeData(), ScaleData(), and FindVariableFeatures().
  temp <- merged_filt_obj_v3[grep("^MT-", rownames(merged_filt_obj_v3), invert = TRUE), ]
  temp$batch <- as.factor(merged_filt_obj_v3$batch)
  
  merged_norm_batchcorr <- SCTransform(merged_filt_obj_v3,
                             assay="RNA",
                             new.assay.name = "SCT",
                             vars.to.regress = c("batch","percent.mt"),
                             method = "glmGamPoi",
                             return.only.var.genes = TRUE,
                             verbose = TRUE)
  
  merged_norm_batchcorr <- merged_norm_batchcorr %>%  
    RunPCA(npcs = 50, verbose = FALSE) 

  merged_norm_batchcorr <- merged_norm_batchcorr %>% 
    RunUMAP(reduction = "pca",
              dims = 1:50, 
              n.components = 3,
              n.neighbors = 30,# default 30
              metric = "cosine",
              min.dist = 0.2, # default 0.3
              return.model = TRUE,
              verbose = T) 
  
  merged_norm_batchcorr <- merged_norm_batchcorr %>% 
      FindNeighbors(reduction = "pca",
                    dims = 1:50, 
                    k.param = 20,
                    nn.method = "annoy",
                    annoy.metric = "cosine",
                    n.trees = 100,
                    verbose = T)
  
  merged_norm_batchcorr <- merged_norm_batchcorr %>% 
      FindClusters(resolution = 1.0, 
                   algorithm = 2, 
                   verbose = T) 
  
  merged_norm_batchcorr <- merged_norm_batchcorr %>% 
      FindClusters(resolution = 1.5, 
                   algorithm = 2, 
                   verbose = T)
  
  merged_norm_batchcorr <- AddMetaData(merged_norm_batchcorr,
                                 as.data.frame(merged_norm_batchcorr@reductions$umap@cell.embeddings))
  
  # saveRDS(merged_norm_batchcorr, 
  #       "results/day0_day50/seurat/iPSC_motor_neuron_day0-day50_time-course_filtered_merged_soupX_normalized_batchcorrected_seurat_obj_v3.RDS")
```

```{r}
if(!exists("merged_norm_batchcorr")){
  merged_norm_batchcorr <- readRDS(file.path(current_path, "results/day0_day50/seurat/iPSC_motor_neuron_day0-day50_time-course_filtered_merged_soupX_normalized_batchcorrected_seurat_obj_v3.RDS"))
}

merged_norm_batchcorr$id <- factor(merged_norm_batchcorr$orig.ident, 
                                   levels = c(unique(merged_norm_batchcorr$orig.ident)))

merged_norm_batchcorr$seurat_clusters <- merged_norm_batchcorr$SCT_snn_res.1
Idents(merged_norm_batchcorr) <- merged_norm_batchcorr$SCT_snn_res.1

merged_norm_batchcorr
```

```{r fig.height=10}
# pdf("figures/day0_day50/filtered_merged_batchcorrected/batchcorrected_sct_transform_100PCs_elbow_plot.pdf", height = 7, width=10)
# ElbowPlot(merged_norm_batchcorr,ndims = 50, reduction = "pca")
# dev.off()
# 
# pdf("figures/day0_day50/filtered_merged_batchcorrected/batchcorrected_transform_1-4PCs_loadings.pdf", height = 10, width=7)
# VizDimLoadings(merged_norm_batchcorr, dims = 1:4, reduction = "pca")
# dev.off()
# 
# pdf("figures/day0_day50/filtered_merged_batchcorrected/batchcorrected_byLouvainCluster_sct_UMAP.pdf",height = 10, width= 17)
# DimPlot(merged_norm_batchcorr, dims = c(1,2)) +
#   scale_color_manual(values = colors_vector)
# dev.off()
```

```{r fig.height=10}
bc_d1 <- DimPlot(merged_norm_batchcorr, 
        group.by = c("batch","id"),
        label = T, 
        repel = T,
        label.size = 7) + 
  scale_color_manual(values = colors_vector)

# png("figures/day0_day50/filtered_merged_batchcorrected/filtered_merged_results_iPSC_MN_seurat_batchcorrected_UMAP_batch_day_filtered.png", height = 15, width = 25, units = "in", res = 150)
bc_d1
# dev.off()

bc_s1 <- DimPlot(merged_norm_batchcorr, 
        group.by = c("id"),
        split.by = "batch",
        label = T, 
        repel = T,
        label.size = 7) + 
  scale_color_manual(values = colors_vector)

# png("figures/day0_day50/filtered_merged_batchcorrected/filtered_merged_results_iPSC_MN_seurat_batchcorrected_UMAP_splitBy_batch_day_filtered.png", height = 15, width = 25, units = "in", res = 150)
bc_s1
# dev.off()
```


```{r fig.height=10}
fig_batchcorr <- plot_ly(merged_norm_batchcorr@meta.data,
               x = ~umap_1, y = ~umap_2, z = ~umap_3, 
               color = ~id,
               colors_vector = colors_vector)
fig_batchcorr <- fig_batchcorr %>% 
  add_markers( 
    marker = list(size = 1), 
    text = merged_norm_batchcorr@meta.data$orig.ident,
      hoverinfo = 'text')

# fig <- fig %>% plotly::layout(scene = list(xaxis = list(title = 'PC1'),
#                      yaxis = list(title = 'PC2'),
#                      zaxis = list(title = 'PC3')))

fig
```


```{r}
Idents(merged_norm_batchcorr) <- merged_norm_batchcorr$orig.ident
purrr::map(names(marker_genes_iPSC), function(type){    
  h <- ifelse(length(marker_genes_iPSC[[type]]) <= 4, 12, 20)
  outfile <- glue("figures/day0_day50/filtered_merged_batchcorrected/iPSC_MN_batchcorrected_expression_{type}_marker_genes.png")
  
  # png(outfile, height = h, width = 20, units = "in", res = 100)
  print(
    FeaturePlot(merged_norm_batchcorr, 
                    features = marker_genes_iPSC[[type]],
                    label = TRUE) +
          patchwork::plot_annotation(title = glue("{type} marker genes"))
        )
  # dev.off()
  
})
```

```{r}
# Identify the 10 most highly variable genes
top10 <- head(VariableFeatures(merged_norm_batchcorr), 10)

# plot variable features with and without labels
plot1 <- VariableFeaturePlot(merged_norm_batchcorr)
plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)

# pdf("figures/day0_day50/filtered_merged_batchcorrected/iPSC_MN_seurat_batchcorrected_topVarFeatures.pdf", height = 5, width = 10)
plot2
# dev.off()
```


## Harmony 

```{r}
VERSION = 'v5'
```

```{r eval=FALSE}
if VERSION == 'v3'{
  merged_harmony_obj <- merged_filt_obj

  merged_harmony_obj[["RNA"]] <- split(merged_harmony_obj[["RNA"]],
                                       f = merged_harmony_obj$sample)
  merged_harmony_obj
}
```

Warning: Groups are set automatically by model when integrating SCT assaysWarning: Quick-TRANSfer stage steps exceeded maximum (= 2694850)Harmony 1/10

```{r eval=FALSE}
merged_harmony_obj_batch <- IntegrateLayers(
  object = merged_norm_obj,
  group.by = "batch",
  method = HarmonyIntegration,
  orig.reduction = "pca",
  new.reduction = "harmony",
  verbose = TRUE ) %>%
 FindNeighbors(reduction = "harmony",
               dims = 1:50)

merged_harmony_obj_batch <- merged_harmony_obj_batch %>% 
 FindClusters(resolution = 1.0,
              cluster.name = "harmony_clusters") %>% 
    RunUMAP(reduction = "harmony",
            reduction.name = "umap.harmony",
            dims = 1:50, 
            n.components = 3,
            n.neighbors = 30,# default 30
            metric = "cosine",
            min.dist = 0.2, # default 0.3
            return.model = TRUE,
            verbose = T) 

merged_harmony_obj_batch$id <- factor(merged_harmony_obj_batch$orig.ident, levels=unique(merged_harmony_obj_batch$orig.ident))
# saveRDS(merged_harmony_obj_batch, "results/day0_day50/seurat/iPSC_motor_neuron_day0-day50_time-course_filtered_merged_soupX_normalized_harmonyPerBatch_seurat_obj_v5.RDS")

# class(merged_harmony_obj_batch[["RNA"]])
```

```{r eval=FALSE}
# defaults to Layers which are the sample IDs in this case
merged_harmony_obj <- IntegrateLayers(
    object = merged_norm_obj,
    method = HarmonyIntegration,
    orig.reduction = "pca",
    new.reduction = "harmony",
    verbose = TRUE ) %>%
   FindNeighbors(reduction = "harmony",
                 dims = 1:50)
  
merged_harmony_obj <- merged_harmony_obj %>% 
   FindClusters(resolution = 1.0,
                cluster.name = "harmony_clusters") %>% 
   RunUMAP(reduction = "harmony",
           dims = 1:50, 
           reduction.name = "umap.harmony")
  
merged_harmony_obj$id <- factor(merged_harmony_obj$orig.ident, levels=unique(merged_harmony_obj$orig.ident))
# saveRDS(merged_harmony_obj, "results/day0_day50/seurat/iPSC_motor_neuron_day0-day50_time-course_filtered_merged_soupX_normalized_harmonyPerSample_seurat_obj_v5.RDS")
```

```{r}
merged_harmony_obj_batch <- AddMetaData(merged_harmony_obj_batch,
                                        merged_harmony_obj_batch@reductions$umap.harmony@cell.embeddings)
```

```{r fig.height=10}
# pdf("figures/day0_day50/harmony/merged_harmony_obj_batch_sct_transform_100PCs_elbow_plot.pdf", height = 7, width=10)
ElbowPlot(merged_harmony_obj_batch,ndims = 50, reduction = "pca")
# dev.off()

# pdf("figures/day0_day50/harmony/merged_harmony_obj_batch_transform_1-4PCs_loadings.pdf", height = 10, width=7)
VizDimLoadings(merged_harmony_obj_batch, dims = 1:4, reduction = "pca")
# dev.off()

# pdf("figures/day0_day50/harmony/merged_harmony_obj_batch_byLouvainCluster_sct_UMAP.pdf",height = 10, width= 17)
DimPlot(merged_harmony_obj_batch,
        reduction = "umap",
        dims = c(1,2)) +
  scale_color_manual(values = colors_vector)
# dev.off()
```

```{r fig.height=10}
filt_harmony_d1 <- DimPlot(merged_harmony_obj_batch, 
        group.by = c("batch","id"),
        reduction = "umap.harmony", 
        label = T, 
        repel = T,
        label.size = 7) + 
  scale_color_manual(values = colors_vector)

# 
# filt_harmony_d2 <- DimPlot(merged_harmony_obj, 
#         group.by = c("batch","id"),
#         reduction = "umap.harmony",
#         label = T, 
#         repel = T,
#         label.size = 7) + 
#   scale_color_manual(values = colors_vector)

# png("figures/day0_day50/harmony/merged_harmony_obj_batch_iPSC_MN_seurat_UMAP_batch_day_filtered.png", height = 15, width = 25, units = "in", res = 150)
filt_harmony_d1
# dev.off()

```

```{r eval=FALSE}
Idents(merged_harmony_obj_batch) <- merged_harmony_obj_batch$orig.ident
purrr::map(names(marker_genes_iPSC), function(type){
 
   h <- ifelse(length(marker_genes_iPSC[[type]]) <= 4, 12, 20)
  outfile <- glue("figures/day0_day50/harmony/merged_harmony_obj_batch_iPSC_MN_expression_{type}_marker_genes.png")
  
  png(outfile, height = h, width = 20, units = "in", res = 100)
  print(FeaturePlot(merged_harmony_obj_batch, 
                    features = marker_genes_iPSC[[type]],
                    label = TRUE) +
          patchwork::plot_annotation(title = glue("{type} marker genes")))
  dev.off()
})
```

```{r}
merged_harmony_obj_batch
Idents(merged_harmony_obj_batch) <- merged_harmony_obj_batch$orig.ident
```

```{r fig.height=10, fig.width=10}
# png("figures/day0_day50/harmony/merged_harmony_obj_batch_iPSC_MN_seurat_endoderm_markers_p1.png", height = 10, width = 12, res = 100, units="in")
VlnPlot(merged_harmony_obj_batch,
        features = marker_genes_endoderm[1:7])
# dev.off()

# png("figures/day0_day50/harmony/merged_harmony_obj_batch_iPSC_MN_seurat_endoderm_markers_p2.png", height = 10, width = 12, res = 100, units="in")
VlnPlot(merged_harmony_obj_batch,
        features = marker_genes_endoderm[8:14])
# dev.off()
```

```{r}
fig2 <- plot_ly(merged_harmony_obj_batch@meta.data,
               x = ~umapharmony_1, y = ~umapharmony_2, z = ~umapharmony_3, 
               color = ~id,
               colors_vector = colors_vector)
fig2 <- fig2 %>%
  add_markers(
    marker = list(size = 1),
    text = pull(merged_harmony_obj_batch@meta.data, orig.ident, name = barcode),
    hoverinfo = 'text')

fig2
```

# Session Info

```{r}
session_info()
```






