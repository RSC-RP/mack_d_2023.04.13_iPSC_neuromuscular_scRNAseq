---
title: "iPSC Motor Neurons Time-series Data"
author: "Jenny L Smith"
date: "`R Sys.Date()`"
output: html_document
---

# Set-up 

```{r set-up, echo=FALSE}
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
knitr::opts_chunk$set(tidy.opts=list(width.cutoff=80),
                      tidy=TRUE,
                      fig.align='center',
                      fig.width = 10, fig.height = 10,
                      eval = TRUE)

options(stringsAsFactors = FALSE, max.print = 100)
options(Seurat.object.assay.version = 'v5')
table = function (..., useNA = 'ifany') base::table(..., useNA = useNA)
getwd()
```

```{r message=FALSE,warning=FALSE}
library(dplyr)
library(tidyr)
library(magrittr)
library(stringr)
library(tibble)
library(glue)

library(ggplot2)
library(plotly)
library(RColorBrewer)

library(Seurat)
# library(SeuratDisk)
# library(SeuratObject)
# library(SeuratWrappers)
# library(Matrix)
# library(SeuratObject)
# library(SeuratData)
# library(SeuratWrappers)

library(scDblFinder)
library(SoupX)
```

```{r}
conflicted::conflict_prefer("select", "dplyr")
conflicted::conflict_prefer("filter","dplyr")
conflicted::conflict_prefer("saveRDS","base")
```


------------------ CMAKE NOT FOUND --------------------

CMake was not found on the PATH. Please install CMake:

 - sudo yum install cmake          (Fedora/CentOS; inside a terminal)
 - sudo apt install cmake          (Debian/Ubuntu; inside a terminal).
 - sudo pacman -S cmake            (Arch Linux; inside a terminal).
 - sudo brew install cmake         (MacOS; inside a terminal with Homebrew)
 - sudo port install cmake         (MacOS; inside a terminal with MacPorts)

Alternatively install CMake from: <https://cmake.org/>

-------------------------------------------------------
ERROR: configuration failed for package ‘nloptr’
* removing ‘/home/jsmi26/R/x86_64-pc-linux-gnu-library/4.3/nloptr’

# Define Functions

```{r}
colors_vector <- c(RColorBrewer::brewer.pal(12, "Paired"), 
            "blue1", "darkslategray3", "burlywood3", "#984EA3",
            "seagreen1", "yellow2", "orchid", "darkblue", 
            "lightsalmon2","slateblue1","lightskyblue4",
            "azure2", "chartreuse1",  "lemonchiffon2",
            "deeppink", "darkslategray1", "green4", "navajowhite", 
            "brown4", "darkgoldenrod2", "deepskyblue1", "lightpink") %>% 
  # c(., ggpubr::get_palette("jco", 5)) %>% 
  c("mediumpurple4","magenta", "peru") %>% 
  c(ggsci::pal_igv()(51))

length(colors_vector) 

sample_id_colors <- c("black",colors_vector[1:18])
```

```{r}
make_3D_umap <- function(metadata, idents_column, label_cols, selected_colors=NULL){
    "
    idents_column is for labeling. ex) 'RNA_snn_res.0.7 as well as the UMAP colnames, eg UMAP_1, UMAP_2'
    "
    # 3D UMAP
    plot.data <- metadata
    plot.data$label <- paste(rownames(plot.data))

    plot.data  <- plot.data %>% 
          unite(col = label, all_of(c("label",label_cols)), sep = "\n", remove = FALSE) %>% 
          select(all_of(c("label",label_cols)), all_of(idents_column))

    
    if(is.null(selected_colors)){
      selected_colors <- c("lightseagreen", "gray50",  "darkgreen", "red4", "red", "turquoise4","black","yellow4","royalblue1","lightcyan3",
                 "peachpuff3","lightskyblue","gray20","orange2","royalblue4","yellow3","gray80","darkorchid1","lawngreen","plum2", 
                 "darkorange4","darkmagenta","mediumorchid1","lightslateblue","midnightblue", "tan2") #26
    }

    cnames <- colnames(plot.data)
    formulas <- sapply(1:3, function(x) as.formula(paste0("~", grep(glue("_{x}$"), cnames, value = TRUE))))
    fig <- plot_ly(data = plot.data, 
        x = formulas[[1]], y = formulas[[2]], z = formulas[[3]], 
        color = as.formula(paste0("~", label_cols[1])), 
        colors = selected_colors, 
        type = "scatter3d", 
        mode = "markers", 
        marker = list(size = 1, width=2), # controls size of points
        text=~label, # This is that extra column we made earlier for which we will use for cell ID
        hoverinfo="text") #When you visualize your plotly object, hovering your mouse pointer over a point shows cell names

    return(fig)
}
```

```{r}
custom_dimplot <- function(metadata, colorby, dimred_colnames, custom_colors,
                           lab_size = 6, ny = 0, custom_lab_fill = NULL,
                           label_samples = TRUE,
                           color_text_grp = FALSE,
                           add_text = TRUE, 
                           seed = 2023){
  
  # define x and y column names
  x_names <- paste0(dimred_colnames, "_1")
  y_names <- paste0(dimred_colnames, "_2")
  
  # define labels positions
  labs_df <- metadata %>%
    select(all_of(c(colorby, x_names, y_names))) %>%
    group_by(!! as.name(colorby)) %>% 
    summarise(x = mean(!! as.name(x_names)),
              y = mean(!! as.name(y_names)))
  
   # define point sizes based on how many total cells in data
   ncells <- nrow(metadata)
   pt_size <- case_when(
     ncells < 5e4 ~ 1,
     ncells >= 5e4 & ncells < 1e5 ~ 0.5,
     ncells >= 1e5 ~ 0.25)
   
   # Make the scatterplot
   plot <- ggplot(metadata, 
         aes_string(x = x_names, y = y_names)) +
    geom_point(aes_string(color = colorby),
               size = pt_size, alpha = 0.4) +
    scale_color_manual(values = custom_colors) +
    guides(color = guide_legend(override.aes = list(alpha = 1, size = 2))) +
    theme_classic() +
    theme(legend.position = "top")
   
   # customize label positions
   if(is.character(ny)){
     y_val <-  ifelse(grepl(ny, labs_df[[colorby]]), 1.5, 0)
   }else{
     y_val <- ny
   }
   
   if(is.null(custom_lab_fill)){
     fill_val <-  "white"
   }else{
     fill_val <- custom_lab_fill
   }
   
   if(color_text_grp){
     mapping <- aes_string(x = "x", y = "y", label = colorby, color = colorby)

   }else{
     mapping <- aes_string(x = "x", y = "y", label = colorby)
   }
  
   if( all(add_text & label_samples) ){
     plot <- plot + 
           ggrepel::geom_text_repel(data = labs_df, 
                             mapping = aes_string(x = "x", y = "y", label = colorby),
                             color = "black",
                             nudge_y = y_val,
                             segment.colour = NA,
                             size = lab_size,
                             seed = seed)
   }else if ( label_samples ) {
      plot <- plot + 
         ggrepel::geom_label_repel(data = labs_df, 
                           mapping = mapping,
                           fill = fill_val,
                           nudge_y = y_val,
                           segment.colour = NA,
                           label.size = 0.5,
                           size = lab_size,
                           show.legend = FALSE,
                           seed = seed)
   }
   
   return(plot)
}
```

```{r}
custom_heatmaps <- function(seurat_obj, genes,columns = NULL, annot_colors = NULL, celltype="ALL"){
  
  if(celltype == "ALL"){
    cell_ids <- colnames(seurat_obj)
  }else{
    cell_ids <- CellsByIdentities(seurat_obj, idents = celltype) %>%  unlist()
  }
  
  print(c("The assay is", DefaultAssay(seurat_obj)))
  genes <- intersect(genes,rownames(seurat_obj))
  seurat_obj <- ScaleData(seurat_obj, features = genes)
  
  print("Extracting expression data")
  norm_counts <- LayerData(seurat_obj[[DefaultAssay(seurat_obj)]], 
                           layer = 'scale.data', 
                           features = genes, 
                           cells = cell_ids)
  
  col_annots <- seurat_obj@meta.data %>% 
    select(-all_of("barcode")) %>% 
    rownames_to_column("barcode") %>% 
    filter(barcode %in% colnames(norm_counts)) %>% 
    as.data.frame() %>%
    set_rownames(.$barcode) %>%
    select(all_of(columns))
  
  # row_annots <- temp %>% 
  #   set_rownames(.$coords) %>% 
  #   select(gene_name, p_val, p_val_adj) 
  
  x <- nrow(norm_counts)
  fontsize_rows <- case_when(
    x < 50 ~ 10,
    x >= 50 & x < 100 ~ 8, 
    x >= 100 & x < 200 ~ 6, 
    x >= 200 ~ 4)


  len <- 299
  colors <- colorRampPalette(viridis::viridis(10))(len)
  colors_list <- lapply(columns, function(x){
          grps <- unique(pull(col_annots, all_of(x)))
          n <- length(grps)
          colors <- annot_colors[1:n] %>% 
            set_names(grps)
          return(colors)
    })
  names(colors_list) <- columns
  

  pheatmap::pheatmap(mat=as.matrix(norm_counts), 
                     scale = "none", 
                     color = colors,
                     fontsize_row = fontsize_rows,
                     # main = glue::glue("{celltype}: DA Peaks p<0.05 & FC >= {th}"),
                     annotation_col = col_annots,
                     annotation_colors = colors_list,
                     # annotation_row = row_annots[,-1],
                     labels_row = rownames(norm_counts),
                     clustering_method = 'ward.D2',
                     show_colnames = FALSE)
}
```



# Parallelization 

```{r eval=FALSE}
library(future)
# check the current active plan
plan()
plan("multisession", workers = 16)
plan()
options(future.globals.maxSize = 60000 * 1024^2)
```

# Background 

## Library prep:

1. Time points between the iPSC ~ day 27: 

  * I froze the cells down along the differentiation at each time point from the same batch, by making multiple wells from the beginning. 
  * When the diff reached day 27, I ended up having frozen vials of cells at 10 different time points (iPSC, d3, d5, d8, d11, d15, d18, d21, d24, d27).
  * Since the 10x Chromium protocol recommends running the library experiment no more than 5 libraries at a time, I split them into 2 sets (5 time points each) and serially made the libraries. The reason for doing the freeze-thawing step in the early phase of differentiation -> Running the library experiment with the fresh (unfrozen) cells from all 16 different time points in one day was unrealistic. 
  * But by experience, we knew that the cells younger than day27 survive pretty well (viability >75%) after getting defrosted. So we decided to use the freeze-thawing strategy for those early time points and make libraries whenever we want. 

2. Time points after day 27: 

  * Since the cells after the neurogenic phase do not survive well after the freeze-thawing cycle, we had to use 'fresh' culture for these library preps. 
  * So I thawed & plated the day18 progenitor stock vials on several different days to do a sort of temporally 'staggered culture' 
  * I harvested the 5 groups of cells (d30, d35, d40, d45, d50) on the same day for library experiment. 
  * These 5 libraries were made on the same day. 
  
Did the library prep use multiplexed samples?    
https://support.10xgenomics.com/single-cell-gene-expression/software/pipelines/latest/what-is-cellplex -> 

> No. I used one library per GEM well, but not mixing the libraries until the actual sequencing run with the Illumina cartridge. Please refer to the 10x protocol I used for all of the library prep: 

https://cdn.10xgenomics.com/image/upload/v1660261285/support-documents/CG000204_ChromiumNextGEMSingleCell3_v3.1_Rev_D.pdf

  
**Mack Lab diff protocol derives stem cells into ventral horn of the spinal cord which not only have motor neurons but different subtypes of interneurons.**


## Human iPSCs

https://www.nature.com/articles/ncomms7626

https://www.ncbi.nlm.nih.gov/books/NBK554616/

The neurons are differentiated from WTC11 iPSCs. https://hpscreg.eu/cell-line/UCSFi001-A. For the MN differentiation, I attached our MN diff protocol used for this experiment. 
>Population: Japanese.
Omics: Genome sequenced.
Derived from sampling site: Leg; skin. Cell type=Fibroblast.

To help with understanding what cell types we might expect at Day 0 and early time-points. -> for the undifferentiated iPSC, we expect the culture enriched with pluripotent cells, usually show high expression of OCT4 (POU5F1), SOX2, NANOG. 

https://github.com/regan-hamel/h-iPSCs-MNI/blob/master/R%20workflow_iMNs_LThiry_2020.Rmd

GTEX - fibroblasts
https://biospecimens.cancer.gov/resources/sops/docs/GTEx_SOPs/BBRB-PR-0004-W1%20GTEx%20Tissue%20Harvesting%20Work%20Instruction.pdf

>Preferred Location: Left or right leg (designate side) 2 cm below
patella on medial side. If not available, an “other” location should be
chosen.
GTEx Tissue Harvesting Work Instruction
PR-0004-W1 VER. 03.05 Effective Date: mm/dd/yyyy Page 7 of 21
4.3.6.6.2 Procedure: After cleaning with alcohol two times, remove a portion
of skin and send to aliquot processing station. From the skin portion,
prepare two 4 mm squared aliquots, place in fibroblast tube
containing culture medium, and tightly seal with parafilm for
shipment directly to the LDACC (Yellow Kit). Return to skin tissue and
prepare the remaining aliquots of skin and subcutaneous adipose
tissue.
4.3.6.6.3 Skin for Fibroblast Culture
4.3.6.6.3.1 Skin, fibroblast culture: Two 4 mm x 4 mm x thickness.
Thickness not to exceed 4 mm.
4.3.6.6.4 Skin Tissue for Fixation in PAXgene®
Underlying visible
subcutaneous fat should be trimmed off.


# Sample Manifest

See https://support.10xgenomics.com/single-cell-gene-expression/software/pipelines/latest/output/gex-metrics

```{r}
sample_manifest <- read.csv("samples/mack_d_iPSC_motor_neurons_sample_manifest_v3.csv")

head(sample_manifest)
```

### Define Manifest 

```{r eval=FALSE}
expn_mats <- dir("resources", pattern = "filtered_feature_bc.+h5|filtered_feature_bc_matrix.h5", 
                 recursive = TRUE, full.names = TRUE) %>% 
  grep("too few", ., value=TRUE, invert = TRUE)

raw_mats <- dir("resources", pattern = "raw_feature_bc", 
                recursive = TRUE, full.names = TRUE) 

length(expn_mats)
length(raw_mats)

summaries <- dir("resources/summary_csv", 
                 pattern = "*.csv", 
                 recursive = FALSE, full.names = TRUE) %>% 
  grep("too few", ., value=TRUE, invert = TRUE)

length(summaries) 
```

```{r eval=FALSE, warning=FALSE}
sample_manifest <- data.frame(expression_matrix_path = expn_mats, 
                              raw_matrix_path = raw_mats, 
                              summary_path = summaries ) %>%
  mutate(time_point=str_split_fixed(expression_matrix_path, pattern="/", n=3)[,2]) %>% 
  mutate(sample_id=paste0("iPSC_", tolower(time_point)), 
         organism="human", 
         tissue="motor_neuron", 
         cell_type="iPSC") %>% 
  mutate(time_point=gsub("Day|Rerun_Day", "", time_point) %>% gsub("iPSC", 0, .) %>% as.numeric(.)) %>% 
  mutate(batch=case_when(
    time_point < 15 ~ "batch1",
    time_point >= 15 & time_point < 30 ~ "batch2",
    grepl("\\/Day(30|35|40|45|50)", expression_matrix_path) ~ "batch3",
    grepl("Rerun_Day(35|40|45|50)", expression_matrix_path) ~ "batch4"
    # time_point >= 30 & time_point <= 50 ~ "batch3"
  )) %>% 
  arrange(time_point) %>% 
  select(sample_id, time_point,batch, organism:cell_type, everything())

# sample_manifest
dim(sample_manifest)
table(sample_manifest$batch)

qc_data <- purrr::map_dfr(1:nrow(sample_manifest), function(i){
  p <- sample_manifest[i,'summary_path']
  read.csv(p) %>% 
      janitor::clean_names() %>% 
      mutate(sample_id=sample_manifest[i,'sample_id']) %>% 
      mutate_all(~as.character(.)) %>% 
      select(sample_id, everything())
}) 

sample_manifest <- sample_manifest %>% 
  left_join(., qc_data, by="sample_id") %>% 
  mutate(across(.cols = c(estimated_number_of_cells:number_of_reads, total_genes_detected:median_umi_counts_per_cell),
                .fns =  ~as.numeric(gsub(",","", .x)))) %>% 
  rename_at(vars(valid_barcodes:fraction_reads_in_cells), ~paste0(.,"_percent")) %>% 
  mutate(across(.cols = matches("_percent$"),
                .fns =  ~as.numeric(gsub("\\%","", .x))))

# any(duplicated(sample_manifest$sample_id))
```

### CellRanger Summary Plots

```{r}
qc_plots_data <- sample_manifest %>% 
  select(sample_id, batch, time_point,
         estimated_number_of_cells,
         median_genes_per_cell, 
         number_of_reads,
         sequencing_saturation_percent, 
         valid_barcodes_percent, 
         reads_mapped_confidently_to_genome_percent,
         reads_mapped_confidently_to_transcriptome_percent, 
         total_genes_detected) %>% 
  pivot_longer(cols = -c(sample_id,batch, time_point),
               names_to = "stat", 
               values_to = "value") %>% 
  mutate(sample_id=factor(sample_id, levels=unique(sample_id)))

# head(qc_plots_data)
```

```{r fig.height=10, fig.width=10}
p1 <- ggplot(qc_plots_data, aes(x = stat, y=value)) +
  geom_boxplot(outlier.color = NA) +
  geom_point(aes(color=sample_id), position = position_jitter(width = 0.2), 
             size=1.5) +
  facet_wrap(~stat, scales = 'free') +
  scale_color_manual(values=colors_vector) +
  theme_classic() +
  theme(legend.position = 'top', 
        text = element_text(size=8))

# pdf("figures/day0_day50/cellranger_qc_metrics_boxplots.pdf", height = 10, width = 10)
p1
# dev.off()
```

```{r fig.height=10, fig.width=10}

p2 <- ggplot(qc_plots_data, aes(x = batch, y=value, fill=batch)) +
  geom_boxplot(outlier.color = NA, alpha=0.25) +
  geom_point(aes(color=sample_id), 
             position = position_jitter(width = 0.2, height = 0, seed = 2023), 
             size=1.5) +
  facet_wrap(~stat, scales = 'free') +
  scale_fill_manual(values=c("seashell3", "paleturquoise3", "pink","dodgerblue1")) +
  scale_color_manual(values=colors_vector) +
  ggrepel::geom_text_repel(aes(label = time_point), size = 3, position = position_jitter(width = 0.2, height = 0, seed = 2023)) +
  theme_classic() +
  theme(legend.position = 'top', 
        text = element_text(size=8))

# pdf("figures/day0_day50/cellranger_qc_metrics_byBatch_boxplots.pdf", height = 10, width = 10)
p2
# dev.off()
```


# Genome Refs

```{r eval=FALSE}
suppressPackageStartupMessages(library(ensembldb))

# db <- ensDbFromGtf("resources/genome/Homo_sapiens.GRCh38.109.chr.gtf.gz")

#Warning: Could not determine length for all seqnames
db <- ensDbFromGtf(gtf = "/gpfs/shared_data/10X/cellranger-7.0.0/refdata-gex-GRCh38-2020-A/genes/genes.gtf", 
                   genomeVersion = "GRCh38",
                   organism = "Homo_sapiens",
                   version = 98)
```

```{r, eval=FALSE}
edb <- ensembldb::EnsDb("resources/genome/Homo_sapiens.GRCh38.98.sqlite")

# edb

gids <- ensembldb::keys(edb, keytype = "GENEID")
idmap <- AnnotationDbi::select(edb, keytype="GENEID", 
                      keys = gids, 
                      columns = c("GENEID","GENEBIOTYPE","GENENAME","SYMBOL")) %>% 
  janitor::clean_names()

# head(idmap)
# dim(idmap) #36601
```

```{r}
changho_refs_file <- "references/changho_updated_marker_genes_MN_IN_annotation.xlsx"
marker_genes_chun <- purrr::map_dfr(openxlsx::getSheetNames(changho_refs_file)[2:4], function(x){
  openxlsx::read.xlsx(changho_refs_file, sheet = x)
}) %>% 
  janitor::clean_names() %>% 
  distinct() %>% 
  mutate(group=paste(author, tolower(neural_pop)) %>% 
           gsub("\\s","_",.)) %>% 
  mutate(specific_markers_for_each_type_of_neuron=gsub("\\s","", specific_markers_for_each_type_of_neuron))

# marker_genes_chun
marker_genes_chun_list <- purrr::map(unique(marker_genes_chun$group), function(x){
  marker_genes_chun %>%
    filter(group == x) %>%
    pull(specific_markers_for_each_type_of_neuron)
}) %>% 
  set_names(unique(marker_genes_chun$group))
marker_genes_chun_list[["pan_neuronal_markers"]] <- str_split(marker_genes_chun[1,"pan_neuronal_markers"], pattern = ", ", n=3)[[1]]

# marker_genes_chun_list
```

```{r}
marker_genes_endoderm <- c("CXCR4", "HDE1", "HDE2", "SOX17", "KLF8", "MYCT1", "DKK4",
                           "CLDN6","KRT19","EOMES", "FABP1", "FABP2","GATA4","GSC",
                           "KRT12","FOXA1","FOXA2","TGFB1","SOX7","SOX17", "HNF1B")

length(marker_genes_endoderm)
```

```{r}
# https://github.com/regan-hamel/h-iPSCs-MNI/blob/master/R%20workflow_iMNs_LThiry_2020.Rmd
marker_genes_iPSC <- list(MNPCs = c("CHAT", "ISL1", "ISL2", "MNX1", "OLIG2", "NEUROG2"),
                INs = c("PAX3", "VSX2", "GATA3", "SOX14", "SIM1", "LBX1", "TLX3"),
                NPCs = c("SOX1", "SOX2", "MKI67"),
                Glial = c("SOX9", "S100B", "GFAP"),
                Oligodendrocytes = c("PDGFRA", "GALC"),
                iPSCs = c("NANOG", "POU5F1"))
```

```{r warning=FALSE}
rayon_marker_genes <- openxlsx::read.xlsx(xlsxFile = "resources/cell_refs/Rayon_2021/TableS2.xlsx") %>% 
  janitor::clean_names() %>% 
  mutate(id = paste("rayon", type, neural_pop, sep="_") %>% 
           gsub("\\s", "_", .)) %>% 
  mutate(description = case_when(
    grepl("FP", id) ~ gsub("FP","floor plate", id),
    grepl("RP", id) ~ gsub("RP","roof plate", id),
    grepl("dp", id) ~ gsub("dp[0-9]", "dorsal interneuron progenitors", id),
    grepl("p[0-2]", id) ~ gsub("p[0-2]", "intermediate interneuron progenitors", id),
    grepl("p3", id) ~ gsub("p3","ventral interneuron progenitors p3", id), 
    grepl("V[0-3]", id) ~ gsub("V[0-9].?", "ventral neurons", id),
    grepl("MN", id) ~ gsub(".?MN","motor neuron", id),
    grepl("dl[0-6]", id) ~ gsub("dl[0-9]", "dorsal Interneuron", id),
    grepl("LTMR|LMTR", id) ~ gsub("C?-{0,1}(LTMR|LMTR).{0,}", "mechanoreceptor", id),
    grepl("Proprioceptor|nociceptor", id) ~ gsub("Peripheral","PNS Peripheral",id),
    grepl("Mesoderm|Eryt|Blood|Hema|Myoblast|Oligo", id) ~ paste("rayon",str_split_fixed(id, "_", n=3)[,2]),
    TRUE ~ id
  ) %>% gsub("_"," ", .) %>% gsub("rayon ","", .))


# View(rayon_marker_genes)
# head(rayon_marker_genes)

rayon_marker_genes_long <- rayon_marker_genes %>% 
  separate(genes_map_step1, into = paste0("gene",1:5), sep=", ") %>% 
  separate(genes_map_step2, into = paste0("gene",5:20), sep = ", ") %>% 
  pivot_longer(cols = matches("^gene"),
               names_to = "colname",
               values_to = "genes") %>% 
  filter(!is.na(genes)) 

# rayon_marker_genes_long

rayon_marker_gene_list <-  purrr::map(unique(rayon_marker_genes_long$id), function(x){
  rayon_marker_genes_long %>% 
    filter(id == x) %>% 
    pull(genes) %>% 
    unique()
})
names(rayon_marker_gene_list) <- unique(rayon_marker_genes_long$id)
# rayon_marker_gene_list
```

```{r}
rayon_degs <- openxlsx::read.xlsx("resources/cell_refs/Yadav_2023/1-s2.0-S0896627323000314-mmc5.xlsx", sheet = 1, check.names = FALSE, sep.names = " ") %>% 
  pivot_longer(cols = everything(),
               names_to = "subtype_annotation", 
               values_to = "degs") %>% 
  mutate(names = gsub("-[0-9]{1,2}$","", subtype_annotation) %>% 
           gsub(".+\\s(.+)$", "\\1", .) %>% 
           gsub("\\/|-","_", .))

esc_celltypes <- unique(rayon_degs$names)
rayon_deg_gene_list <-  purrr::map(esc_celltypes, function(x){
  rayon_degs %>%
    filter(names == x) %>%
    pull(degs) %>%
    unique()
})
names(rayon_deg_gene_list) <- esc_celltypes
```

```{r}
mn_subtype_markers <- openxlsx::read.xlsx("references/11122023_Alpha_Gamma_MNs_consolidated marker list.xlsx", sheet = 2)
head(mn_subtype_markers)
# table(mn_subtype_markers$celltype)
```


# Read in iPSC Object

```{r}
current_path <- file.path("results/day0_day50/seurat")
current_obj <- "iPSC_motor_neuron_day0-day50_time-course_filtered_merged_soupX_normalized_seurat_obj_v5.RDS" #v5 Seurat Object

merged_norm_obj <- readRDS(file.path(current_path, current_obj))
```


# Generate iPSC Seurat Object 

```{r}
filtered_matrices <- sample_manifest %>% 
  pull(expression_matrix_path, name = sample_id)

length(filtered_matrices)

# temp <- Read10X_h5(filtered_matrices[19])
# head(temp[,1:5])
# head(rownames(temp)) #gene symbols
# grep("^MT-", rownames(temp), value = TRUE) #OK
```

```{r eval=FALSE}
seurat_objs <- purrr::map(seq_along(filtered_matrices), function(i){
  id <- names(filtered_matrices)[i]
  path <- filtered_matrices[i]
  counts <- Read10X_h5(path)
  seurat_obj <-  CreateSeuratObject(counts=counts,
                                    assay="RNA",
                                    project=id)
  
  seurat_obj <- PercentageFeatureSet(seurat_obj,
                                   assay="RNA",
                                   pattern = "^MT-",
                                   col.name = "percent.mt")
  seurat_obj <- PercentageFeatureSet(seurat_obj,
                                     assay="RNA",
                                     pattern = "^RP[SL]", 
                                     col.name = "percent.ribo")
})
names(seurat_objs) <- names(filtered_matrices)
# seurat_objs$iPSC_ipsc$percent.ribo %>% quantile()
# seurat_objs$iPSC_ipsc$percent.mt %>%  quantile()

if(exists("seurat_objs")){
  job::job({
      dir.create("results/day0_day50/seurat/individual_objs", recursive = TRUE)
      base::saveRDS(seurat_objs, "results/individual_objs/mack_iPSC_motor_neuron_day0-day50_seurat_obj_list.RDS")
  }, import = c("seurat_objs"))
}
```

```{r eval=FALSE}
if(!exists("seurat_objs")){
  seurat_objs <- readRDS("results/day0_day50/seurat/individual_objs/mack_iPSC_motor_neuron_day0-day50_seurat_obj_list.RDS")
}

length(seurat_objs) #19
names(seurat_objs)
# sapply(seurat_objs, dim)

# missing 1,630 - need to map these. 
table(rownames(seurat_objs$iPSC_ipsc@assays$RNA) %in% idmap$genename) 

merged_obj <- merge(x = seurat_objs$iPSC_ipsc,
                    y = seurat_objs[grep("iPSC_ipsc", names(seurat_objs), invert = TRUE)],
                    add.cell.ids=names(filtered_matrices),
                    project="iPSC")


# An object of class Seurat 
# 33538 features across 61518 samples within 1 assay 
# Active assay: RNA (33538 features, 0 variable features)
#  2 layers present: counts, data
merged_obj 

if(exists("merged_obj")) {
  job::job({
      saveRDS(merged_obj,"results/day0_day50/seurat/iPSC_motor_neuron_day0-day50_time-course_merged_seurat_obj.RDS")
  }, import = c("merged_obj"))
}
```

## QC Plots

nFeature_RNA is the number of genes detected in each cell. 
* Low nFeature_RNA for a cell indicates that it may be dead/dying or an empty droplet.

nCount_RNA is the total number of molecules (UMI) detected within a cell. 

* High nCount_RNA and/or nFeature_RNA indicates that the "cell" may in fact be a doublet (or multiplet).

```{r eval=FALSE, fig.height=5, fig.width=10}
# pdf("figures/day0_day50/iPSC_MN_seurat_all_QC_metrics_noFilter.pdf", height = 10, width = 15)
Idents(merged_obj) <- merged_obj$orig.ident
VlnPlot(
  object = merged_obj,
  features = c("nCount_RNA", "nFeature_RNA", "percent.mt","percent.ribo"),
  ncol = 2,
  alpha = 0.5,
  pt.size = 0
)
# dev.off()
```

# Preprocess QC 

https://satijalab.org/seurat/articles/sctransform_vignette.html
https://nbisweden.github.io/workshop-scRNAseq/labs/compiled/seurat/seurat_01_qc.html#MitoRibo_filtering

```{r eval=FALSE}
if(!exists("merged_obj")) {
  merged_obj <- readRDS("results/day0_day50/seurat/iPSC_motor_neuron_day0-day50_time-course_merged_seurat_obj.RDS")
}

merged_obj <- SCTransform(merged_obj, vst.flavor = "v2", verbose = T) %>%
    RunPCA(npcs = 50, verbose = T) %>%
    RunUMAP(n.components = 3L, reduction = "pca", dims = 1:50, verbose = T) %>%
    FindNeighbors(reduction = "pca", dims = 1:50, verbose = T) %>%
    FindClusters(resolution = 0.8, verbose = T)

# merged_obj

new_meta <- merged_obj@meta.data %>% 
  rownames_to_column("barcode") %>% 
  left_join(., sample_manifest, by=c("orig.ident"="sample_id"))

merged_obj <- AddMetaData(merged_obj,metadata = new_meta)
merged_obj@meta.data %>% head()

# saveRDS(merged_obj, "results/day0_day50/seurat/iPSC_motor_neuron_day0-day50_time-course_SCT_UMAP_Seurat_obj.RDS")
```

```{r eval=FALSE}
# include RNA lognormalized counts for certain data processing steps that require it. 
DefaultAssay(merged_obj) <- "RNA"
merged_obj <- NormalizeData(merged_obj, normalization.method = "LogNormalize")
merged_obj <- FindVariableFeatures(merged_obj, nfeatures = 3000)
```

```{r}
# Cannot visualize the 3000 var genes in SCT with layers.
# Instead Extract the individual var feature dataframes per individual sample. 
DefaultAssay(merged_obj) <- "SCT"
# Identify the 10 most highly variable genes
top10 <- head(VariableFeatures(merged_obj), 10)
var_feats_df <- SCTResults(merged_obj, slot = "feature.attributes")
```

```{r fig.height=10, fig.width=10, eval=FALSE}
pdf("figures/day0_day50/iPSC_MN_seurat_UMAP_noFilter.pdf", height = 15, width = 15)
DimPlot(merged_obj, label = T, repel = T, label.size = 7) + 
  scale_color_manual(values = colors_vector) +
  ggtitle("Unsupervised clustering")
dev.off()

merged_obj$time_point_day <- factor(paste0("day_",merged_obj$time_point),
                                    levels=unique(paste0("day_",merged_obj$time_point)))

# as.data.frame(table(merged_obj$batch, merged_obj$time_point_day))

d1 <- DimPlot(merged_obj, 
        group.by = c("batch","time_point_day"),
        label = T, 
        repel = T,
        label.size = 7) + 
  scale_color_manual(values = colors_vector)

pdf("figures/day0_day50/iPSC_MN_seurat_UMAP_batch_day_noFilter.pdf", height = 15, width = 20)
d1
dev.off()

pdf("figures/day0_day50/iPSC_MN_seurat_PCA_elbow_noFilter.pdf", height = 5, width = 10)
ElbowPlot(merged_obj,ndims = 50)
dev.off()

pdf("figures/day0_day50/iPSC_MN_seurat_PCA_loadings_noFilter.pdf", height = 10, width = 10)
VizDimLoadings(merged_obj, dims = 1:4, reduction = "pca")
dev.off()

n_cells_barplot <- merged_obj@meta.data %>% 
  mutate(id=factor(orig.ident, levels=unique(orig.ident))) %>% 

  ggplot(., aes(x=id,fill=id)) +
  geom_bar() +
  scale_fill_manual(values=colors_vector) +
  theme_classic() +
  theme(axis.text.x = element_text(angle=25, vjust=1, hjust=1))

png("figures/day0_day50/iPSC_MN_seurat_number_cells_per_day_noFilter.png", height = 5, width = 8, units = "in", res = 150)
n_cells_barplot
dev.off()

median_umis <- merged_obj@meta.data %>% 
  mutate(id=factor(orig.ident, levels=unique(orig.ident))) %>% 
  select(id, median_umi_counts_per_cell, batch) %>% 
  distinct() %>% 

  ggplot(., aes(y=id, x = median_umi_counts_per_cell, fill = batch)) +
  geom_col() +
  theme_classic()

png("figures/day0_day50/cellranger_qc_metrics_byBatch_median_UMIs.png", height = 8, width = 7, units = "in",res = 150)
median_umis
dev.off()
```

# Doublet Scores

scDblFinder operation
  * The input data for scDblFinder (denoted x below) can be either i) a count matrix (full or sparse), with genes/features as rows and cells/droplets as columns; or ii) an object of class SingleCellExperiment. 
  * the object should not contain empty drops, but should **not otherwise have undergone very stringent filtering** (which would bias the estimate of the doublet rate). 
  
> initial processing, artificial doublets (either random or between-cluster, depending on the settings) are generated, then a nearest neighbor (kNN) network is generated. 

> Rather than selecting a single neighborhood size, as most kNN-based methods do, scDblFinder gathers statistics at various neighborhood sizes, thereby enabling the downstream classifier to select the most informative size(s), which might also differ across the expression space. 

Doublet Considerations:
  * https://bioinformatics-core-shared-training.github.io/CrukCiScRnaSeqMatDev/AnaWiSce/AnaCourse1/BookDownCourse1/doubletDetectionTop.html
  * "Doublet detection procedures should only be applied to libraries generated in the same experimental batch. It is obviously impossible for doublets to form between two cells that were captured separately." 
  * "It is also difficult to interpret doublet predictions in data containing cellular trajectories."

10x Doublets expected:
  * https://kb.10xgenomics.com/hc/en-us/articles/360001378811-What-is-the-maximum-number-of-cells-that-can-be-profiled-
  * closer to 4.8% expected by the docs, though many must be excluded by CellRanger in the filtered_bc_matrix

Benchmarks:
 - https://f1000research.com/articles/10-979/v2#ref19
 - https://arxiv.org/pdf/2101.08860.pdf
 - https://www.ncbi.nlm.nih.gov/pmc/articles/PMC7897250/

```{r eval=FALSE}
if(!exists("seurat_objs")){
  seurat_objs <- readRDS("results/individual_objs/mack_iPSC_motor_neuron_day0-day50_seurat_obj_list.RDS")
}

# only run for new samples. outputs for previous data are on gpfs not local. 
seurat_objs_all <- seurat_objs
seurat_objs <- seurat_objs[grep("rerun_", names(seurat_objs))]
print(length(seurat_objs))

job::job({
  
  doublet_scores <- purrr::map_dfr(names(seurat_objs), function(x){
    
        outfile <- glue::glue("results/individual_objs/mack_{x}_motor_neuron_SCT_doublets_seurat_obj.RDS")
        
        if(!file.exists(outfile)){
          
          print(glue("Processing {x}"))
          # normalize
          obj <- SCTransform(seurat_objs[[x]], method = "glmGamPoi")
          
          # cluster
          obj <- obj %>%
            RunPCA(npcs = 50, verbose = F) %>%
            RunUMAP(n.components = 3, reduction = "pca",
                    dims = 1:50, verbose = F) %>%
            FindNeighbors(reduction = "pca", dims = 1:50, verbose = F) %>%
            FindClusters(resolution = 0.8, verbose = F)
          
          print(glue("SCE to doublet finder {x}"))
          sce <- Seurat::as.SingleCellExperiment(obj, assay = "SCT")
          doublets <- computeDoubletDensity(sce,  
                                            k = 50, #default
                                            subset.row = VariableFeatures(obj))
          doublets_clust <- scDblFinder(sce,
                                        clusters = "seurat_clusters", 
                                        nfeatures = VariableFeatures(obj), 
                                        k = NULL, #default - allow alg to select K from examining a number of different values. 
                                        returnType = "table")
          
          print(glue("Update Metadata for {x}"))
          obj <- AddMetaData(obj, metadata = as.data.frame(obj@reductions$umap@cell.embeddings))
          obj$doublet_score <- doublets
          obj$doublet_outlier <- obj$doublet_score > quantile(obj$doublet_score, probs = c(0.98)) # assume 2% doublet rate?
          obj <- AddMetaData(obj, metadata = filter(as.data.frame(doublets_clust), type =="real"))
          
          print(glue("Saving {outfile}"))
          base::saveRDS(obj,outfile)
        }else{
          print(glue("Reading in {x}"))
          obj <- readRDS(outfile)
        }
        
        meta <- as.data.frame(obj@meta.data)
        return(meta)
      })
  # save the results in a csv file
  write.csv(doublet_scores, "results/doublet_scores/mack_iPSC_MN_day0-day50_rerun_scDblFinder_scores.csv", row.names = TRUE)
}, import = c("seurat_objs"))
```

```{r}
doublet_scores <- purrr::map_dfr(dir("results/doublet_scores", full.names = TRUE), function(x){
  read.csv(x) %>%
  mutate(id=factor(orig.ident, levels=unique(orig.ident)),
         barcode=X)
}) %>%
  left_join(., sample_manifest, by=c("orig.ident"="sample_id")) %>%
  rename_at(vars(cluster,SCT_snn_res.0.8, seurat_clusters), ~paste0(.,"_per_sample")) %>%
  arrange(time_point, orig.ident) %>% 
  mutate(sample_id=factor(orig.ident, levels=unique(orig.ident))) %>% 
  arrange(sample_id) %>%
  select(sample_id, barcode, everything(), -X)

head(doublet_scores)
dim(doublet_scores) #98532    76
# table(doublet_scores$batch)
# table(doublet_scores$sample_id)
```

```{r eval=FALSE}
doublet_scores %>% 
  select(orig.ident,barcode,
         distanceToNearest,score,
         class,matches("^ratio")) %>% 
  head()
```

```{r eval=FALSE}
purrr::map(unique(doublet_scores$orig.ident), function(x){
  
  basefile <- glue("figures/day0_day50/doublets/iPSC_MN_doublet_scores_{x}")
  chk <- doublet_scores %>% 
    filter(orig.ident == x)
  
  p1 <- ggplot(chk, aes(x=umap_1, y=umap_2, color = as.factor(seurat_clusters_per_sample))) +
      geom_point(alpha=0.7) +
      scale_color_manual(values=colors_vector) +
      theme_classic()

  p2 <-  ggplot(chk, aes(x=umap_1, y=umap_2, color = doublet_score)) +
    geom_point() +
    scale_color_viridis_c() +
    theme_classic()
  
  p3 <- ggplot(chk, aes(x=umap_1, y=umap_2, color = doublet_outlier)) +
    geom_point(alpha=0.7) +
    scale_color_viridis_d(direction = -1) +
    theme_classic()
  
  p4 <- ggplot(chk, aes(x=umap_1, y=umap_2, color = score)) +
    geom_point() +
    scale_color_viridis_c() +
    theme_classic()
  
  p5 <- ggplot(chk, aes(x=umap_1, y=umap_2, color = class)) +
    geom_point(alpha=0.7) +
    scale_color_viridis_d() +
    theme_classic()
  
  png(glue(basefile, "_computeDoubletDensity.png"), width = 20, height = 8, res=150, units = "in")
  print(p1 + p2 + p3 + patchwork::plot_layout(guides = 'collect') + patchwork::plot_annotation(title = x))
  dev.off()
  
  png(glue(basefile, "_scDblFinder.png"), width = 20, height = 8, res=150, units = "in")
  print(p1 + p4 + p5 + patchwork::plot_layout(guides = 'collect') + patchwork::plot_annotation(title = x))
  dev.off()

})
```

```{r}
# pdf("figures/day0_day50/doublets/iPSC_MN_doublet_scores_scDblFinder_barplot.pdf", height = 7, width = 12)
doublet_scores %>% 
  mutate(class=factor(class, levels=rev(c("doublet","singlet")))) %>% 
ggplot(., aes(x=sample_id, fill=class)) +
  geom_bar() +
  scale_fill_manual(values=colors_vector) +
  labs(y="number of cells",x="") +
  theme_classic() +
  theme(axis.text.x = element_text(angle=25, vjust=1, hjust=1))
# dev.off()
```


```{r fig.height=5, fig.width=10, eval=FALSE}
# pdf("figures/day0_day50/doublets/iPSC_MN_scDblFinder_noFilter_ridgePlot.pdf", height = 10, width = 10)
ggplot(doublet_scores, aes(y=sample_id, x=score, fill=id)) +
  ggridges::stat_density_ridges(quantile_lines = TRUE, 
                                quantiles = 0.5, alpha=0.75, 
                                scale = 0.9) +
  geom_point(aes(color=sample_id), 
             shape="|",
             size=2,
             alpha=0.7,
             position = position_nudge(y=-0.15)) +
  scale_fill_manual(values=colors_vector) +
  scale_color_manual(values=colors_vector) +
  theme_classic()
# dev.off()
```


# Filter Cells

https://www.10xgenomics.com/resources/analysis-guides/common-considerations-for-quality-control-filters-for-single-cell-rna-seq-data

From Yadav 2023

>All the 10x runs for each human sample were initially filtered with an nUMI cutoff of >1000 and then nuclei with less than 5% mitochondrial gene contamination were retained. Next, the mitochondrial genes were also removed from the matrices. A total of 55,289 nuclei that passed quality control filtering, with mean detection of 2,187 genes per nucleus (Figure S1).

nFeature_RNA is the number of genes detected in each cell. 
  * Low nFeature_RNA for a cell indicates that it may be dead/dying or an empty droplet.

nCount_RNA is the total number of molecules (UMI) detected within a cell. 

```{r}
seurat_objs_dbls <- dir("results/individual_objs", 
                        pattern = "mack_.+_motor_neuron_SCT_doublets_seurat_obj.RDS", full.names = TRUE) %>% 
  set_names(gsub("mack_iPSC_|_motor_neuron_.+$", "", basename(.)))

# head(seurat_objs_dbls)
# tail(seurat_objs_dbls)
length(seurat_objs_dbls) # 19
```

```{r eval=TRUE}
job::job({
  # loop through each sample and create dynamic filting thresholds
  filter_objs <- purrr::map(names(seurat_objs_dbls), function(x){
    
        outfile <- glue::glue("results/individual_objs/mack_{x}_motor_neuron_filtered_seurat_obj.RDS")
        out_summary <- glue("results/day0_day50/seurat/filtering_stats/mack_iPSC_{x}_day0-day50_cell_filtering_threshold_summary.csv")
        input <- readRDS(seurat_objs_dbls[x])
    
        if( any(!file.exists(outfile) | !file.exists(out_summary)) ){
          
          print(glue("Processing {x}"))
          # nmads = 3 default
          # number of MADs away from median required for a value to be called an outlier.
          mito_outlier <- scuttle::isOutlier(input$percent.mt, type="higher")
          rb_outlier <- scuttle::isOutlier(input$percent.ribo, type="lower")
          ncount_outlier <- scuttle::isOutlier(input$nCount_RNA, type="both")
          nfeat_outlier <- scuttle::isOutlier(input$nFeature_RNA, type="both")
          
          
          mito_th <- attr(mito_outlier,which = "thresholds")["higher"]
          rb_th <- attr(rb_outlier,which = "thresholds")["lower"]
          
          ncount_upl <- attr(ncount_outlier,which = "thresholds")["higher"]
          ncount_lowl <- attr(ncount_outlier,which = "thresholds")["lower"]
          
          nfeat_upl <- attr(nfeat_outlier,which = "thresholds")["higher"]
          nfeat_lowl <- attr(nfeat_outlier,which = "thresholds")["lower"]
          
          # hard thresholds for lower bounds
          #  at least 200 genes assayed per cell
          #  at least 500 reads per cells
          to_retain <- WhichCells(input, 
                                  expression = 
                                    nFeature_RNA > 200 & 
                                    nFeature_RNA < nfeat_upl &
                                    nCount_RNA > 500 &
                                    nCount_RNA < ncount_upl &
                                    
                                    percent.ribo > rb_th &
                                    percent.mt < mito_th &
                                    class == "singlet")
          input$to_retain <- as.numeric(colnames(input) %in%  to_retain)
          
          d1 <- DimPlot(input)
          f1 <- FeaturePlot(input, 
                            features = c("percent.mt","percent.ribo","to_retain"),
                            ncol=3)
          
          outplot <- glue("figures/day0_day50/filtering/mack_{x}_motor_neuron_filtered_seurat_UMAP.png")
          png(outplot,height = 7, width = 20, units="in", res=150)
          print(d1 + f1 + patchwork::plot_annotation(title=x) + patchwork::plot_layout(widths = c(0.5, 1)))
          dev.off()
          
          sub_filt_obj <- subset(
                          x = input,
                          cells = to_retain)

          print(glue("Saving {outfile}"))
          base::saveRDS(sub_filt_obj, outfile)
          # Save the thresholds to a file
          ths <-  data.frame(sample=x,
                           mito_th=mito_th,
                           rb_th=rb_th,
                           ncount_rna_th=500,
                           nfeat_rna_th=200,
                           ncount_rna_upl=ncount_upl,
                           ncount_rna_lowl=ncount_lowl,
                           nfeat_rna_upl=nfeat_upl,
                           nfeat_rna_lowl=nfeat_lowl,
                           input_number_cells=ncol(input),
                           output_number_cells=ncol(sub_filt_obj))
          write.csv(ths,out_summary, row.names = FALSE)

        }else{
          print(glue("Reading in RDS results for {x}"))
          sub_filt_obj <- readRDS(outfile)
        }
        return(sub_filt_obj)
      })
  names(filter_objs) <- paste0("iPSC_", names(seurat_objs_dbls))
  
}, import = c("seurat_objs_dbls"))
```

```{r}
outpaths <- dir("results/day0_day50/seurat/filtering_stats",
                pattern = "filtering_threshold_summary.csv" , 
                full.names = TRUE)

threshold_summary <- purrr::map_dfr(outpaths, function(x){
  read.csv(x) 
}) %>% 
  mutate(sample_id = paste0("iPSC_", sample), 
         percent = round(output_number_cells / input_number_cells * 100, digits = 2)) %>%
  left_join(., sample_manifest, by = c("sample_id")) %>%
  arrange(time_point, sample_id) %>%
  mutate(sample_id = factor(sample_id, levels=unique(sample_id))) %>%
  select(sample_id, everything()) %>%
  arrange(sample_id)

threshold_summary %>% head()
# dim(threshold_summary) #19 35
```

```{r}
# pdf("figures/day0_day50/filtering/mack_iPSC_motor_neuron_day0-day50_filtered_seurat_mito_thresholds.pdf", height = 8, width = 10)
ggplot(threshold_summary, aes(x=batch, y=mito_th, fill=batch)) +
  geom_boxplot(alpha=0.25) +
  geom_point(aes(color=sample_id),
             size=2,
             position = position_jitter(width = 0.2, seed=2023)) +
  scale_fill_brewer(palette = "Blues") +
  scale_color_manual(values = colors_vector) +
  ggrepel::geom_text_repel(aes(label=sample)) +
  labs(x="",y="Mitochondrial Reads Threshold (%)") +
  guides(color="none") +
  theme_classic() +
  theme(axis.text.x = element_text(angle=25, vjust=1, hjust=1))
# dev.off()
```

```{r fig.width=15}
ths_to_plot <- threshold_summary %>% 
  select(sample_id, input_number_cells, output_number_cells) %>% 
  pivot_longer(cols = -sample_id, 
               names_to = "statistic",
               values_to = "number_of_cells") 

labels_df <- threshold_summary %>% 
  select(sample_id, percent, number_of_cells = input_number_cells) %>% 
  mutate(statistic = "input_number_cells") %>% 
  rowwise() %>% 
  mutate(label =paste0(percent,"%\nretained")) %>% 
  ungroup()

bplot <- ggplot(ths_to_plot, aes(x = sample_id,
                        y = number_of_cells,
                        fill = statistic)) +
  geom_col(position = position_dodge()) +
  labs(x="") +
  scale_y_continuous(limits = c(0, 12500), breaks = seq(0,12500, by=1000)) +
  geom_text(data = labels_df,
            mapping = aes(x = sample_id,
                          y = number_of_cells,
                          label = label),
            nudge_y = 400) +
  scale_fill_viridis_d(option = "turbo", begin = 0.1) +
  theme_classic() +
  theme(axis.text.x = element_text(angle=25, vjust=1, hjust=1))

# png("figures/day0_day50/filtering/mack_iPSC_motor_neuron_day0-day50_filtered_seurat_barplot.png",height = 8, width = 16, unit="in", res=150)
bplot
# dev.off()
```


### Day 5 and Day 8 

Day5 and Day8 are outliers in terms of %mito - I'll manually set these to the mean of all the other time-points and filter them again. 

```{r}
threshold_summary %>% 
  filter(grepl("day5$|day8$", sample_id))
```

```{r}
mean_th <- threshold_summary %>% 
  filter(!grepl("day5$|day8$", sample)) %>% 
  summarize(mean_mito_th = mean(mito_th)) %>% 
  pull(mean_mito_th)

mean_th # 7.429377
```

Move the original files to a seperate subdirectory for later, if needed. 

```{bash}
cd results/individual_objs
mkdir -p first_pass_filter
mv mack_day{5,8}_* first_pass_filter/
```

```{r}
redo <- c("iPSC_day5","iPSC_day8")
filter_objs_d5_d8 <- purrr::map(redo, function(x) {
    outfile <- glue::glue("results/individual_objs/mack_{x}_motor_neuron_filtered_seurat_obj.RDS")
    obj <- filter_objs[[x]]
    
    sub_filt_obj <- subset(
            x = obj,
            subset = percent.mt < mean_th)
    base::saveRDS(sub_filt_obj, outfile)
    return(sub_filt_obj)
})
names(filter_objs_d5_d8) <- redo

filter_objs_d5_d8$iPSC_day5$percent.mt %>% quantile()
filter_objs_d5_d8$iPSC_day8$percent.mt %>% quantile()

# Update the filtered objects list
filter_objs[redo] <- filter_objs_d5_d8
```

```{r}
threshold_summary_update <- threshold_summary %>% 
  mutate_at(vars(mito_th), ~case_when(
    sample == "day5" ~ mean_th,
    sample == "day8" ~ mean_th,
    TRUE ~ .
    )) %>%
  mutate_at(vars(output_number_cells), ~case_when(
    sample == "day5" ~ ncol(filter_objs_d5_d8$iPSC_day5),
    sample == "day8" ~ ncol(filter_objs_d5_d8$iPSC_day8),
    TRUE ~ .)) %>% 
  mutate(percent = round(output_number_cells/input_number_cells * 100, digits = 1))

threshold_summary_update
write.csv(threshold_summary_update, "results/day0_day50/seurat/filtering_stats/mack_iPSC_MN_day0-day50_cell_filtering_final_threshold_summary.csv", row.names = FALSE)
```

```{r}
pdf("figures/day0_day50/filtering/mack_iPSC_motor_neuron_day0-day50_filtered_seurat_mito_thresholds_update.pdf", height = 7, width = 10)
ggplot(threshold_summary_update, aes(x=batch, y=mito_th, fill=batch)) +
  geom_boxplot(alpha=0.25) +
  geom_point(aes(color=sample_id),
             size=2,
             position = position_jitter(width = 0.2, seed=2023)) +
  scale_fill_viridis_d() +
  scale_color_manual(values = colors_vector) +
  scale_y_continuous(limits = c(0,15)) +
  ggrepel::geom_text_repel(aes(label=sample),
                           position = position_jitter(width = 0.2, seed=2023)) +
  labs(x="",y="Mitochondrial Reads Threshold (%)") +
  guides(color="none") +
  theme_classic() +
  theme(axis.text.x = element_text(angle=25, vjust=1, hjust=1))
dev.off()
```

```{r fig.width=10}
ths_to_plot <- threshold_summary_update %>% 
  select(sample_id, input_number_cells, output_number_cells) %>% 
  pivot_longer(cols = -sample_id, 
               names_to = "statistic",
               values_to = "number_of_cells") 

labels_df <- threshold_summary_update %>% 
  select(sample_id, percent, number_of_cells = input_number_cells) %>% 
  mutate(statistic = "input_number_cells") %>% 
  rowwise() %>% 
  mutate(label =paste0(percent,"%\nretained")) %>% 
  ungroup()

bplot2 <- ggplot(ths_to_plot, aes(x = sample_id,
                        y = number_of_cells,
                        fill = statistic)) +
  geom_col(position = position_dodge()) +
  labs(x="") +
  scale_y_continuous(limits = c(0, 12500), breaks = seq(0,12500, by = 1000)) +
  geom_text(data = labels_df,
            mapping = aes(x = sample_id,
                          y = number_of_cells,
                          label = label),
            nudge_y = 400) +
  scale_fill_viridis_d(option = "turbo", begin = 0.1) +
  theme_bw() +
  theme(axis.text.x = element_text(angle=25, vjust=1, hjust=1))

png("figures/day0_day50/filtering/mack_iPSC_motor_neuron_day0-day50_filtered_seurat_barplot_update.png",height = 8, width = 16, unit="in", res=150)
bplot2
dev.off()
```


# SoupX

SoupX
  * https://rawcdn.githack.com/constantAmateur/SoupX/204b602418df12e9fdb4b68775a8b486c6504fe4/inst/doc/pbmcTutorial.html
  * https://academic.oup.com/gigascience/article/9/12/giaa151/6049831
  * https://github.com/constantAmateur/SoupX/issues/44
    * "Ideally you should run doublet removal first and exclude these cells when running SoupX, but it will make little practical difference." 
  * https://github.com/constantAmateur/SoupX/issues/47


The contamination fraction is parametrised as rho in the code, with rho=0 meaning no contamination and rho=1 meaning 100% of UMIs in a droplet are soup.

While it is possible to run SoupX without clustering information, you will get far better results if some basic clustering is provided. Therefore, it is strongly recommended that you provide some clustering information to SoupX. 


>  If you try and run it on a channel with  (e.g. a cell line, flow-sorted cells), you will likely get a warning, an error, and/or an extremely high contamination estimate. In such circumstances your best option is usually to manually set the contamination to something reasonable.

```bash
mamba -h 
mamba create -n hdf5 conda-forge::r-hdf5r python==3.10
conda
```

Sys.setenv(LD_LIBRARY_PATH=paste("/home/jsmi26/miniforge3/envs/hdf5/lib", Sys.getenv("LD_LIBRARY_PATH"), sep =":"))
Sys.getenv("LD_LIBRARY_PATH")
install.packages("hdf5r", configure.args = "--with-hdf5=/home/jsmi26/miniforge3/envs/hdf5/bin/h5cc")
Sys.getenv("LD_LIBRARY_PATH")
Sys.setenv(PATH=paste("/home/jsmi26/miniforge3/envs/hdf5/bin",Sys.getenv("PATH"), sep = ":"))
Sys.getenv("PATH")
library(hdf5r)
Error in dyn.load(file, DLLpath = DLLpath, ...) : 
  unable to load shared object '/home/jsmi26/R/x86_64-pc-linux-gnu-library/4.3/hdf5r/libs/hdf5r.so':
  libhdf5_hl.so.310: cannot open shared object file: No such file or directory


```{r eval=TRUE}
if(!exists("filter_objs")){
  seurat_objs_filt <- dir("results/individual_objs", 
                          pattern = "mack_.+_motor_neuron_filtered_seurat_obj.RDS",
                          full.names = TRUE) %>% 
    set_names(gsub("mack_|_motor_neuron_filtered.+","", basename(.)) %>% 
                gsub("iPSC_", "", .))
  
  filter_objs <- purrr::map(seurat_objs_filt, function(x) {
          obj <- readRDS(x) 
    })
  names(filter_objs) <- paste0("iPSC_", names(filter_objs))
}
length(filter_objs) #19


# define output directory locations
outdirs <- glue("results/soupX_counts/{names(filter_objs)}") %>% 
  as.character() %>% 
  set_names(basename(.))

#re-order the entries by time
outdirs <- outdirs[sample_manifest$sample_id] 
length(outdirs) #19

# Processes all data sets
soup_channels <- list()
for(dir in outdirs){
  if(! dir %in% names(soup_channels)){
    x <- basename(dir)
    print(x)
    subset <- sample_manifest %>%
      filter(sample_id == x)

    full_counts <- Read10X_h5(subset$raw_matrix_path)
    filt_obj <- filter_objs[[x]]
    cell_counts <- LayerData(filt_obj, assay = "RNA", layer = "counts")
    clusts <- filt_obj@meta.data$seurat_clusters
    dim_red <- filt_obj@reductions$umap@cell.embeddings

    sc <- SoupChannel(tod=full_counts,
                      toc=cell_counts)
    sc <- setClusters(sc, clusts)
    sc <- suppressWarnings(setDR(sc, dim_red))
    soup_channels[[x]] <- sc
  }
}
length(soup_channels) # 19

# save the filtered and raw bc counts soupX channel objects.
job::job({
  saveRDS(soup_channels, "results/soupX_counts/mack_iPSC_MN_day0-day50_soupX_channel_objs_list.RDS")
}, import = c("soup_channels"))
```

```{r, eval=TRUE}
if(!exists("soup_channels")){
  soup_channels <- readRDS("results/soupX_counts/mack_iPSC_MN_day0-day50_soupX_channel_objs_list.RDS")
}

# Calculate estimate of contamination with soupX
est_first_pass <- purrr::map(outdirs, function(dir){
    min <- 1
    sc <- soup_channels[[basename(dir)]]
    outfile2 <- glue("figures/day0_day50/soupX/{basename(dir)}_autoEstCont_figure.pdf")
    
     print(glue("Processing {dir}"))
     # attempt to run the contamination estimate, but some samples will fail due celltype composition
     tryCatch(expr = {
      # estimate contamination fraction
      adj_sc <-  autoEstCont(sc, tfidfMin = min,
                             doPlot = FALSE,
                             verbose = FALSE)
  
    }, error = function(err){
      print(glue("{dir} Too homogenous for reliable estimate"))
      return(NULL)
    })
     
    # generate a plot with the estimated rho if estimate was generated
    if(exists("adj_sc")){
      pdf(outfile2, height = 7, width = 10)
      autoEstCont(adj_sc, tfidfMin = min, verbose = FALSE)
      dev.off()
      return(adj_sc)
    } else {
      # or return the name of the sample that couldn't be analyzed
      return(dir)
    }
})
names(est_first_pass) <- names(outdirs)
```

SoupX Overview:

iPSC_ipsc
  * results/soupX_counts/iPSC_ipsc Too homogenous for reliable estimate
  * regardless of level of filtering
  * has to due with this population being lowerer completexity/ mostly 1 cell-type 
    
iPSC_day3
  * Warning: Fewer than 10 marker genes found.  Is this channel low complexity (see help)?  If not, consider reducing tfidfMin or soupQuantileWarning: Fewer than 10 independent estimates, rho estimation is likely to be unstable.
  
iPSC_day5
  * results/soupX_counts/iPSC_day5 Too homogenous for reliable estimate

* iPSC_day40
4833 cells default filters 
  - estimates ~20% contamination fraction which is wildly high. 
4497 cells after additional filters
 - estimates ~6% contamination fraction which is FAR more sensible
 
    
```{r eval=FALSE}
# sapply(est_first_pass, class)
ests <- sapply(est_first_pass, function(x) ifelse(!is.character(x), unique(x$metaData$rho), NA))

round(mean(ests, na.rm = TRUE), digits = 3)
```

```{r, eval=TRUE}
# Manually adjust the missing datasets using the mean rho value from all other samples  
missing <- grepl("ipsc|y3$|y5$", names(est_first_pass))
ave_rho <- round(mean(sapply(est_first_pass[!missing],  function(x) unique(x$metaData$rho))), digits = 3)
print(ave_rho) #0.052

# update the soup channel objects with the mean estimated fraction
remaining_est <- purrr::map(names(est_first_pass[missing]), function(x){
  print(x)
   sc <- soup_channels[[x]]
    # set contamination fraction
    adj_sc <-  setContaminationFraction(sc,ave_rho)
})
names(remaining_est) <- names(est_first_pass[missing])

# update the final objects list with those that needed manual contamination fraction estimation
final_estimates <- c(est_first_pass[!missing], remaining_est)
final_estimates <- final_estimates[names(outdirs)]
length(final_estimates) #19

# export the corrected counts 
# job::job({
  save_corrected_counts <- purrr::map(outdirs, function(outdir){
    if(!dir.exists(outdir)){
      print(outdir)
      x <- basename(outdir)
      out = adjustCounts(final_estimates[[x]])
      DropletUtils:::write10xCounts(outdir, out)
    }
  })
# }, import = c("final_estimates", "outdirs"))
```

```{r eval=TRUE}
estimates_df <- purrr::map_dfr(names(final_estimates), function(x){
  final_estimates[[x]]$metaData %>% 
    rownames_to_column("barcode") %>% 
    mutate(sample_id = x)
}) %>% 
  mutate(sample_id=factor(sample_id, levels=unique(sample_id)))

head(estimates_df)
# table(estimates_df$sample_id)
write.csv(estimates_df, "results/soupX_counts/mack_iPSC_MN_day0-day50_soupX_contamination_estimates.csv", row.names = FALSE)
```

```{r}
est_df_subset <- estimates_df %>% 
  select(sample_id, rho) %>% 
  distinct()

est_plot <- ggplot(est_df_subset, aes(x =  sample_id, y=rho, fill = sample_id)) +
  geom_col() +
  scale_fill_manual(values = colors_vector) +
  geom_hline(yintercept = 0.05, linetype="dashed") +
  labs(title="SoupX Ambient DNA Contamination Estimates", y="contamination fraction", x="") +
  theme_classic() +
  scale_y_continuous(limits=c(0,0.2)) +
  theme(axis.text.x = element_text(angle = 25, vjust = 1, hjust = 1))

# png("figures/day0_day50/soupX/iPSC_MN_contamination_estimates_update.png", height = 7, width = 10, units = "in", res = 150)
est_plot
# dev.off()
```

There are some issues in the plotting functions that haven't been updated. 
* https://github.com/constantAmateur/SoupX/issues/102

```{r eval=FALSE}
plotMarkerDistribution(sc = soup_channels, 
                       nonExpressedGeneList = NULL,
                       maxCells = 150, 
                       tfidfMin = 1)

```


# Merge Filtered Objects

```{r eval=TRUE}
preprocess_merge_obj <- "iPSC_motor_neuron_day0-day50_time-course_SCT_UMAP_Seurat_obj.RDS"

if(!exists("merged_obj")){
  merged_obj <- readRDS(file.path("results/day0_day50/seurat", preprocess_merge_obj))
}
merged_obj
```

```{r}
print(options()$Seurat.object.assay.version)
```

```{r eval=TRUE}
outs <- dir("results/soupX_counts",pattern = "^iPSC", full.names = TRUE)
names(outs) <- basename(outs)
length(outs) #19

metadata <- merged_obj@meta.data

soupx_objs <- purrr::map(outs, function(res){

  counts <- Read10X(res)
  id <- basename(res)
  print(glue("{id}"))
  
  mdata <- metadata %>% 
    filter(orig.ident == id) %>% 
    mutate(barcode = gsub("^iPSC_[A-Za-z].+_","", barcode)) %>% 
    filter(barcode %in% intersect(colnames(counts), barcode)) %>% 
    set_rownames(.$barcode) %>% 
    as.data.frame()
  
  print(dim(mdata))
  
  seurat_obj <-  CreateSeuratObject(counts=counts, 
                                    assay="RNA",
                                    project = id, 
                                    meta.data = mdata)
  
  seurat_obj <- PercentageFeatureSet(seurat_obj,
                                 assay="RNA",
                                 pattern = "^MT-",
                                 col.name = "filtered_percent.mt")
  
  seurat_obj <- PercentageFeatureSet(seurat_obj,
                                     assay="RNA",
                                     pattern = "^RP[SL]", 
                                     col.name = "filtered_percent.ribo")
})

# reorder the objects
soupx_objs <- soupx_objs[unique(sample_manifest$sample_id)]
names(soupx_objs)
```

```{r eval=TRUE}
job::job({
  sapply(names(soupx_objs), function(x)
    saveRDS(soupx_objs[[x]], glue("results/individual_objs/mack_{x}_motor_neuron_filtered_soupX_seurat_obj.RDS")))
}, import = c("soupx_objs"))
```

```{r eval=TRUE}
VERSION="v5"
options(Seurat.object.assay.version = VERSION)

merged_filt_obj <-  merge(x = soupx_objs$iPSC_ipsc, 
                          y = soupx_objs[grep("ipsc", names(soupx_objs), invert = TRUE)],
                          merge.data = FALSE,
                          add.cell.ids=names(soupx_objs),
                          project="iPSC")


# An object of class Seurat 
# 33538 features across 87870 samples within 1 assay 
# Active assay: RNA (33538 features, 0 variable features)
merged_filt_obj 
saveRDS(merged_filt_obj,glue("results/day0_day50/seurat/iPSC_motor_neuron_day0-day50_time-course_filtered_merged_soupX_seurat_obj_{VERSION}.RDS"))
```


# Filtered Dataset Processing

```{r}
#https://github.com/satijalab/seurat/issues/3622
options(future.rng.onMisuse="ignore")
```

From Yadav 2023

> All the 10x runs for each human sample were initially filtered with an nUMI cutoff of >1000 and then nuclei with less than 5% mitochondrial gene contamination were retained. Next, the mitochondrial genes were also removed from the matrices. A total of 55,289 nuclei that passed quality control filtering, with mean detection of 2,187 genes per nucleus (Figure S1).

The FindClusters() function implements this procedure, and contains a resolution parameter that sets the ‘granularity’ of the downstream clustering, with increased values leading to a greater number of clusters. 

We find that setting this parameter between 0.4-1.2 typically returns good results for single-cell datasets of around 3K cells. Optimal resolution often increases for larger datasets. 

https://satijalab.org/seurat/articles/seurat5_essential_commands#create-seurat-or-assay-objects
* convert a v5 assay to a v3 assay
`pbmc3k[["RNA3"]] <- as(object = pbmc3k[["RNA"]], Class = "Assay")`

* convert a v3 assay to a v5 assay
`pbmc3k[["RNA5"]] <- as(object = pbmc3k[["RNA3"]], Class = "Assay5")`


```{r eval=TRUE}
if(!exists("merged_filt_obj")){
  merged_filt_obj <- readRDS("results/day0_day50/seurat/iPSC_motor_neuron_day0-day50_time-course_filtered_merged_soupX_seurat_obj_v5.RDS")
}

merged_filt_obj

versions = c("v5","v3")

for(VERSION in versions){
  options(Seurat.object.assay.version = VERSION)
  print(glue("The seurat object version is set to: {options()$Seurat.object.assay.version}"))

  # remove MT genes
  temp <- merged_filt_obj[grep("^MT-", rownames(merged_filt_obj), invert = TRUE), ]
  
  # object version 
  seurat_class <- class(temp[['RNA']])
  
  # convert if necessary
  if( seurat_class == "Assay5" & VERSION == "v3" ){
    temp <- JoinLayers(temp)
    temp[["RNA"]] <- as(object = temp[["RNA"]], Class = "Assay")
  }
  if( seurat_class == "Assay" & VERSION == "v5" ){
     temp[["RNA"]] <- as(object = temp[["RNA"]], Class = "Assay5")
  }
  print(glue("The object class is set as {class(temp[['RNA']])}"))
  
  #regularized negative binomial regression to normalize UMI count data
  #Note that this single command replaces NormalizeData(), ScaleData(), and FindVariableFeatures().
  merged_norm_obj <- SCTransform(temp,
                           assay="RNA",
                           new.assay.name = "SCT",
                           vars.to.regress = "percent.mt",
                           method = "glmGamPoi",
                           return.only.var.genes = FALSE,
                           verbose = TRUE)
  
  merged_norm_obj <-   RunPCA(merged_norm_obj,
                              assay = "SCT",
                              npcs = 50,
                              verbose = TRUE) %>% 
        RunUMAP(reduction = "pca",
                dims = 1:50,
                n.components = 3,
                n.neighbors = 30,# default 30
                metric = "cosine",
                min.dist = 0.1, # default 0.3
                return.model = TRUE,
                verbose = T)
  
    merged_norm_obj <- merged_norm_obj %>%
        FindNeighbors(reduction = "pca",
                      dims = 1:50,
                      k.param = 20,
                      nn.method = "annoy",
                      annoy.metric = "cosine",
                      n.trees = 100,
                      n.epochs = 500,
                      verbose = T)
  
    merged_norm_obj <- merged_norm_obj %>%
        FindClusters(resolution = c(0.5, 1.0, 1.5),
                     algorithm = 2,
                     verbose = T)
  
    merged_norm_obj <- AddMetaData(merged_norm_obj,
                                   as.data.frame(merged_norm_obj@reductions$umap@cell.embeddings))
    
    saveRDS(merged_norm_obj, glue("results/day0_day50/seurat/iPSC_motor_neuron_day0-day50_time-course_filtered_merged_soupX_normalized_seurat_obj_{VERSION}.RDS"))
}
rm(merged_norm_obj)
```

```{r}
if(!exists("merged_norm_obj")){
  merged_norm_obj <- readRDS("results/day0_day50/seurat/iPSC_motor_neuron_day0-day50_time-course_filtered_merged_soupX_normalized_seurat_obj_v5.RDS")
}

# Add metadata and idents
merged_norm_obj$id <- factor(merged_norm_obj$orig.ident, levels=unique(merged_norm_obj$orig.ident))
merged_norm_obj$seurat_clusters <- merged_norm_obj$SCT_snn_res.1
Idents(merged_norm_obj) <- merged_norm_obj$orig.ident

merged_norm_obj
class(merged_norm_obj[["RNA"]]) #v5
```

min.dist	
This controls how tightly the embedding is allowed compress points together. Larger values ensure embedded points are moreevenly distributed, while smaller values allow the algorithm to optimise more accurately with regard to local structure. Sensible values are in the range 0.001 to 0.5.

n.neighbors	
This determines the number of neighboring points used in local approximations of manifold structure. Larger values will result in more global structure being preserved at the loss of detailed local structure. In general this parameter should often be in the range 5 to 50.

```{r fig.height=10}
redo_umap = FALSE
if(redo_umap){
  merged_norm_obj <- merged_norm_obj %>% 
          RunUMAP(reduction = "pca",
                dims = 1:30,
                # features = VariableFeatures(merged_norm_obj),
                # assay = 'SCT',
                n.components = 3,
                n.neighbors = 30,# default 30
                metric = "cosine",
                min.dist = 0.01, # default 0.3
                n.epochs = 500,
                return.model = TRUE,
                verbose = T)

  merged_norm_obj <- AddMetaData(merged_norm_obj,as.data.frame(merged_norm_obj@reductions$umap@cell.embeddings))
}

# png("figures/day0_day50/filtered_merged_results/day0-day50_time-course_filtered_merged_byTimePoint_sct_UMAP.png",res = 150, units = "in", height = 15, width= 17)
DimPlot(merged_norm_obj, 
        reduction = "umap",
        label = TRUE,
        label.size = 8,
        repel = TRUE,
        dims = c(1,2)) +
  scale_color_manual(values = colors_vector) +
  theme(legend.position = 'bottom')
# dev.off()


# png("figures/day0_day50/filtered_merged_results/day0-day50_time-course_filtered_merged_byLouvainCluster_sct_UMAP.pdf", res = 150, units = "in",height = 15, width= 17)
DimPlot(merged_norm_obj, 
        reduction = "umap",
        group.by = 'seurat_clusters',
        label = TRUE,
        label.size = 10,
        repel = TRUE,
        dims = c(1,2)) +
  scale_color_manual(values = colors_vector) +
  theme(legend.position = 'bottom')
# dev.off()
```

```{r fig.height=10, warning=FALSE}
# filt_d1 <- DimPlot(merged_norm_obj, 
#         group.by = c("batch","id"),
#         label = T, 
#         repel = T,
#         label.size = 7) + 
#   scale_color_manual(values = colors_vector)
# 
# filt_s1 <- DimPlot(merged_norm_obj,
#         group.by = c("id"),
#         split.by = "batch",
#         label = T,
#         repel = T,
#         label.size = 7) +
#   scale_color_manual(values = colors_vector)



# pdf("figures/day0_day50/filtered_merged_results/sct_transform_100PCs_elbow_plot.pdf", height = 7, width=10)
ElbowPlot(merged_norm_obj,ndims = 50, reduction = "pca")
# dev.off()

# pdf("figures/day0_day50/filtered_merged_results/transform_1-4PCs_loadings.pdf", height = 10, width=7)
VizDimLoadings(merged_norm_obj, dims = 1:4, reduction = "pca")
# dev.off()

filt_batch <- custom_dimplot(metadata = merged_norm_obj@meta.data,
                         colorby = "batch", 
                         dimred_colnames = "umap", 
                         custom_colors = ggsci::pal_jco()(4))
                           
# filt_batch


filt_id <- custom_dimplot(metadata = merged_norm_obj@meta.data,
                         colorby = "id", 
                         dimred_colnames = "umap", 
                         custom_colors = colors_vector)
                           
# filt_id

png("figures/day0_day50/filtered_merged_results/iPSC_MN_seurat_UMAP_day_filtered.png", height = 15, width = 25, units = "in", res = 150)
filt_id
dev.off()

filt_b34_id <- custom_dimplot(metadata = merged_norm_obj@meta.data %>% 
                            filter(time_point > 30),
                         colorby = "id", 
                         add_text = FALSE,
                         dimred_colnames = "umap", 
                         custom_colors = colors_vector)

# png("figures/day0_day50/filtered_merged_results/iPSC_MN_seurat_UMAP_splitBy_batch_day_filtered.png",  height = 15, width = 25, units = "in", res = 150)
filt_b34_id + 
  facet_wrap(~time_point)
# dev.off()

# png("figures/day0_day50/filtered_merged_results/iPSC_MN_seurat_UMAP_batch_filtered.png",  height = 15, width = 25, units = "in", res = 150)
filt_batch
# dev.off()
```

```{r}
merged_3d <- make_3D_umap(metadata = merged_norm_obj@meta.data, 
             idents_column = c(paste0("umap_",1:3)), 
             label_cols = c("id","batch"), 
             selected_colors = colors_vector)

merged_3d
```

```{r eval=FALSE}
Idents(merged_norm_obj) <- merged_norm_obj$orig.ident
purrr::map(names(marker_genes_iPSC), function(type){
 
   h <- ifelse(length(marker_genes_iPSC[[type]]) <= 4, 12, 20)
  outfile <- glue("figures/day0_day50/filtered_merged_results/iPSC_MN_expression_{type}_marker_genes.png")
  
  png(outfile, height = h, width = 20, units = "in", res = 100)
  print(FeaturePlot(merged_norm_obj, 
                    features = marker_genes_iPSC[[type]],
                    label = TRUE) +
          patchwork::plot_annotation(title = glue("{type} marker genes")))
  dev.off()
  
})
```

```{r eval=FALSE, fig.height=10, fig.width=10}
Idents(merged_norm_obj) <- merged_norm_obj$orig.ident

purrr::map(names(marker_genes_chun_list), function(type){
 
  h <- ifelse(length(marker_genes_chun_list[[type]]) <= 4, 12, 20)
  base <- glue("figures/day0_day50/filtered_merged_results/iPSC_MN_expression_{type}_marker_genes_")
  
  # png(paste0(base,"FeaturePlot.png"), height = h, width = 20, units = "in", res = 100)
  # print(FeaturePlot(merged_norm_obj, 
  #                   reduction = "umap",
  #                   features = marker_genes_chun_list[[type]],
  #                   label = FALSE) +
  #         patchwork::plot_annotation(title = glue("{type} marker genes")))
  # dev.off()
  # 
  h <- ifelse(length(marker_genes_chun_list[[type]]) <= 4, 8, 15)
  png(paste0(base,"ViolinPlot.png"), height = 8, width = 20, units = "in", res = 100)
print(VlnPlot(merged_norm_obj,
              pt.size = 0,
              features = marker_genes_chun_list[[type]]) +
          patchwork::plot_annotation(title = glue("{type} marker genes")))
  dev.off()
  
})
```

```{r fig.height=10, fig.width=10}
marker_genes_endoderm2 <- marker_genes_endoderm[marker_genes_endoderm %in% rownames(merged_norm_obj)]
Idents(merged_norm_obj) <- merged_norm_obj$orig.ident


# png("figures/day0_day50/filtered_merged_results/filtered_merged_results_iPSC_MN_seurat_endoderm_markers_p1.png", height = 12, width = 18, res = 100, units="in")
VlnPlot(merged_norm_obj,
        features = marker_genes_endoderm2[1:9])
# dev.off()

# png("figures/day0_day50/filtered_merged_results/filtered_merged_results_iPSC_MN_seurat_endoderm_markers_p2.png", height = 12, width = 18, res = 100, units="in")
VlnPlot(merged_norm_obj,
        features = marker_genes_endoderm2[10:18])
# dev.off()
```

```{r}
most_var_genes_per_sample <- SCTResults(merged_norm_obj, slot = "feature.attributes")

# most_var_genes_per_sample
```

```{r eval=FALSE}
# Identify the 10 most highly variable genes
top10 <- head(VariableFeatures(merged_norm_obj), 10)

# plot variable features with and without labels
# not possible to plot with SCT norm within layers
plot1 <- VariableFeaturePlot(merged_norm_obj)
plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)

# pdf("figures/day0_day50/filtered_merged_results/iPSC_MN_seurat_topVarFeatures.pdf", height = 5, width = 10)
plot2
# dev.off()
```

nFeature_RNA is the number of genes detected in each cell. 
  * Low nFeature_RNA for a cell indicates that it may be dead/dying or an empty droplet.

nCount_RNA is the total number of molecules (UMI) detected within a cell. 

https://github.com/satijalab/seurat/issues/2101
nFeatures counts any gene with at least 1 UMI count
nFeature_RNA column reports the total number of genes in each cell that have at least one UMI count.
- seems inaccurate, should be > 0 UMI count?

https://www.bioinformatics.babraham.ac.uk/training/10XRNASeq/seurat_workflow.html
nFeature_RNA the number of observed genes (anything with **a nonzero count**)

https://bioconductor.org/books/3.18/OSCA.basic/quality-control.html
The number of expressed features in each cell is defined as the number of endogenous genes with **non-zero counts** for that cell.

### Genes Detected After Filtering 

```{r}
genes_detected <- merged_norm_obj@meta.data %>% 
  mutate(time_point_day = paste0("day", time_point)) %>% 
  # filter(grepl("day35|day40|day45|day50", time_point_day)) %>% 
  group_by(orig.ident, time_point_day, time_point) %>% 
  summarize(num_cells = n(),
            mean_num_genes_detected_RNA = mean(nFeature_RNA), 
            median_num_genes_detected_RNA = median(nFeature_RNA)) %>% 
  ungroup() %>% 
  arrange(time_point) %>% 
  mutate(time_point_day = factor(time_point_day, levels = unique(time_point_day)))
  # arrange(median_num_genes_detected_RNA)


merged_norm_obj@meta.data %>% 
  summarize(mean = mean(nFeature_RNA),
            median = median(nFeature_RNA))
```

```{r fig.height=10}
meta <- merged_norm_obj@meta.data %>% 
  mutate(nCount_RNA_lims = ifelse(nCount_RNA > quantile(nCount_RNA, probs = c(0.95)), quantile(nCount_RNA, probs = c(0.95)), nCount_RNA))

# png("figures/day0_day50/filtered_merged_results/iPSC_MN_seurat_nFeature_UMAP.png", height = 10, width = 12, units = "in", res = 125)
ggplot(meta, 
       aes(x=umap_1, y=umap_2, color = nFeature_RNA)) +
  geom_point(alpha = 0.5) +
  scale_color_gradient(low = 'azure2', high = 'red') +
  theme_classic()
# dev.off()

# png("figures/day0_day50/filtered_merged_results/iPSC_MN_seurat_nCount_RNA_UMAP.png", height = 10, width = 12, units = "in", res = 125)
ggplot(meta, 
       aes(x=umap_1, y=umap_2, color = log2(nCount_RNA))) +
  geom_point(alpha = 0.5) +
  scale_color_gradient(low = 'azure2', high = 'red') +
  theme_classic()
# dev.off()
```



```{r fig.width=7}
# pdf("figures/day0_day50/filtered_merged_results/iPSC_MN_seurat_nFeature_barplot.pdf", height = 8, width = 15)
ggplot(genes_detected, aes(x=time_point_day, 
                           y=mean_num_genes_detected_RNA,
                           fill=orig.ident)) +
  geom_col(position = position_dodge()) +
  scale_fill_manual(values=colors_vector) +
  scale_y_continuous(breaks=seq(0,6500, by=500)) +
  theme_classic()
# dev.off()
```


```{r}
umi_counts_filt <-  sapply( Layers(merged_norm_obj@assays$RNA), function(x) {
   colSums(merged_norm_obj@assays$RNA[[x]] > 0)
})


# mean(umi_counts_filt)
med_per_day <- sapply(umi_counts_filt, median)
mean_per_day <- sapply(umi_counts_filt, mean)

# unlist(umi_counts_filt) %>% length()

median(unlist(umi_counts_filt)) # 1723 genes detected across all cells
mean(unlist(umi_counts_filt)) #1885 genes detected across all cells
```

```{r}
med_per_day[order(med_per_day)]
```

```{r}
data.frame(counts=umi_counts_filt$counts.iPSC_day40) %>% 
  ggplot(., aes(x=counts)) +
  geom_histogram(binwidth = 100)

data.frame(counts=umi_counts_filt$counts.iPSC_ipsc) %>% 
  ggplot(., aes(x=counts)) +
  geom_histogram(binwidth = 100)
```



# Batch Effect Correction 

return.only.var.genes -
If set to TRUE the scale.data matrices in output assay are subset to contain only the variable genes; default is TRUE

vars.to.regress	- 
Variables to regress out in a second non-regularized linear regression. For example, percent.mito. 

Note on scale_data and return.only.var.genes
- https://github.com/satijalab/seurat/discussions/4259

https://www.sc-best-practices.org/cellular_structure/integration.html
* "one can say that Harmony and Seurat consistently perform well for simple batch correction tasks,"

## RPCA

https://satijalab.org/seurat/articles/integration_rpca.html

k.anchor	
* How many neighbors (k) to use when picking anchors

k.filter	
* How many neighbors (k) to use when filtering anchors

from Yadav 2023:
> The 7 human datasets were integrated using SCTransform normalization followed by CCA based integration using the Seurat 4 package

from Rayon 2023:
> Replicate datasets were subsequently filtered to remove contaminant cells (such as mesoderm and blood). The resulting datasets were then normalised and integrated using the SCTransform/IntegrateData workflow implemented in Seurat 3.2.2
> Replicates were then integrated together to create the time point and species datasets.


Possible Layer Groups
- 1 layer per sample
- 1 layer per batch
- 1 layer per time-point

* would you want to integrate the replicate samples and then merge with unintegrated samples? That seems like a bad idea since it would adding to the technical differences between batch1/2 vs batch3/4. 

```{r eval=TRUE}
VERSION = 'v5'
if(!exists("merged_norm_obj")){
  merged_norm_obj <- readRDS("results/day0_day50/seurat/old_thresholds/iPSC_motor_neuron_day0-day50_time-course_filtered_merged_soupX_normalized_seurat_obj_v5.RDS")
}

# defaults to Layers which are the sample IDs in this case
merged_rpca_obj <- IntegrateLayers(
    object = merged_norm_obj,
    method = RPCAIntegration,
    orig.reduction = "pca",
    new.reduction = "rpcaorder",
    normalization.method = 'SCT', #why is this required?
    assay = "SCT",
    k.anchor = 5,
    preserve.order = TRUE, #keep time-course samples in order day3 into day0. Then Day8 into Day0/3 obj
    verbose = TRUE) 

dims <- 1:30
merged_rpca_obj <-  IntegrateLayers(
      object = merged_rpca_obj,
      method = RPCAIntegration,
      orig.reduction = "pca",
      new.reduction = "rpca",
      normalization.method = 'SCT', #why is this required?
      assay = "SCT",
      k.anchor = 5,
      preserve.order = FALSE, # merge by largest sized dataset
      verbose = TRUE)
  
  merged_rpca_obj <- merged_rpca_obj %>% 
     RunUMAP(reduction = "rpca",
             n.components = 3,
             dims = dims,
             n.neighbors = 30,# default 30
             metric = "cosine",
             min.dist = 0.01, # default 0.3
             n.epochs = 500,
             reduction.name = "umap.rpca") %>% 
       RunUMAP(reduction = "rpcaorder",
             n.components = 3,
             dims = dims,
             n.neighbors = 30,# default 30
             metric = "cosine",
             min.dist = 0.01, # default 0.3
             n.epochs = 500,
             reduction.name = "umap.rpcaorder")
  
  merged_rpca_obj <- merged_rpca_obj %>%
     FindNeighbors(graph.name = c("rpca_nn","rpca_snn"),
                   reduction = "rpca",
                   dims = dims) %>% 
     FindNeighbors(graph.name = c("rpcaorder_nn","rpcaorder_snn"),
                   reduction = "rpca",
                   dims = dims) 
     # FindClusters(resolution = c(0.8, 1.0, 1.5),
     #              algorithm = 2)
  
  merged_rpca_obj$id <- factor(merged_rpca_obj$orig.ident,
                                  levels=unique(merged_rpca_obj$orig.ident))
  merged_rpca_obj <- AddMetaData(merged_rpca_obj,
                                    merged_rpca_obj@reductions$umap.rpca@cell.embeddings)
  merged_rpca_obj <- AddMetaData(merged_rpca_obj,
                                    merged_rpca_obj@reductions$umap.rpcaorder@cell.embeddings)
  
  job::job({
    saveRDS(merged_rpca_obj, glue("results/day0_day50/seurat/iPSC_MN_time-course_filtered_merged_soupX_normalized_RPCAIntegration_seurat_obj_v5.RDS"))
  }, import = c("merged_rpca_obj"))

# pdf(glue("figures/day0_day50/filtered_merged_rpca/merged_rpca_sct_transform_100PCs_elbow_plot.pdf"), height = 7, width=10)
# ElbowPlot(merged_rpca_obj, ndims = 50, reduction = "pca")
# dev.off()
# 
# pdf("figures/day0_day50/filtered_merged_rpca/merged_rpca_transform_1-4PCs_loadings.pdf", height = 10, width=7)
# VizDimLoadings(merged_rpca_obj, dims = 1:4, reduction = "pca")
# dev.off()
  
purrr::map(c("umaprpca","umaprpcaorder"), function(x){
  rpcafilt_batch <- custom_dimplot(metadata = merged_rpca_obj@meta.data,
                           colorby = "batch", 
                           dimred_colnames = x, 
                           custom_colors = ggsci::pal_jco()(4))
                             
  rpcafilt_id <- custom_dimplot(metadata = merged_rpca_obj@meta.data,
                           colorby = "id", 
                           dimred_colnames = x, 
                           custom_colors = sample_id_colors)
  
  rpcafilt_b34_id <- custom_dimplot(metadata = merged_rpca_obj@meta.data %>% 
                              filter(time_point > 30),
                           colorby = "id", 
                           label_samples = FALSE,
                           dimred_colnames = x, 
                           custom_colors = colors_vector)          
  
  png(glue("figures/day0_day50/filtered_merged_rpca/iPSC_MN_seurat_{x}_UMAP_day_filtered.png"), height = 15, width = 25, units = "in", res = 150)
  print(rpcafilt_id)
  dev.off()
  
  png(glue("figures/day0_day50/filtered_merged_rpca/iPSC_MN_seurat_{x}_UMAP_splitBy_batch_day_filtered.png"),  height = 15, width = 25, units = "in", res = 150)
  print(rpcafilt_b34_id + 
    facet_wrap(~time_point))
  dev.off()
  
  png(glue("figures/day0_day50/filtered_merged_rpca/iPSC_MN_seurat_{x}_UMAP_batch_filtered.png"),  height = 15, width = 25, units = "in", res = 150)
  print(rpcafilt_batch)
  dev.off()

  rpca_3d <- make_3D_umap(metadata = merged_rpca_obj@meta.data, 
             idents_column = c(paste0("umaprpca_",1:3)), 
             label_cols = c("id","batch"), 
             selected_colors = colors_vector)
  htmlwidgets::saveWidget(rpca_3d, glue("figures/day0_day50/filtered_merged_rpca/iPSC_MN_seurat_{x}_UMAP.html"))
})
```

```{r eval=FALSE}
Idents(merged_rpca_obj) <- merged_rpca_obj$orig.ident

purrr::map(names(marker_genes_iPSC), function(type){
 
   h <- ifelse(length(marker_genes_iPSC[[type]]) <= 4, 12, 20)
  outfile <- glue("figures/day0_day50/filtered_merged_rpca/merged_rpca_obj_batch_iPSC_MN_expression_{type}_marker_genes.png")
  
  png(outfile, height = h, width = 20, units = "in", res = 100)
  print(FeaturePlot(merged_rpca_obj, 
                    features = marker_genes_iPSC[[type]],
                    label = TRUE) +
          patchwork::plot_annotation(title = glue("{type} marker genes")))
  dev.off()
})
```


## Harmony 

n.neighbors
This determines the number of neighboring points used in local approximations of manifold structure. Larger values will result in more global structure being preserved at the loss of detailed local structure. In general this parameter should often be in the range 5 to 50.

repulsion.strength	
Weighting applied to negative samples in low dimensional embedding optimization. Values higher than one will result in greater weight being given to negative samples.

negative.sample.rate	
The number of negative samples to select per positive sample in the optimization process. Increasing this value will result in greater repulsive force being applied, greater optimization cost, but slightly more accuracy.

```{r eval=TRUE}
VERSION = 'v5'
if(!exists("merged_norm_obj")){
  merged_norm_obj <- readRDS("results/day0_day50/seurat/iPSC_motor_neuron_day0-day50_time-course_filtered_merged_soupX_normalized_seurat_obj_v5.RDS")
}

# defaults to Layers which are the sample IDs in this case
merged_harmony_obj <- IntegrateLayers(
    object = merged_norm_obj,
    method = HarmonyIntegration,
    orig.reduction = "pca",
    new.reduction = "harmony",
    assay = "SCT",
    preserve.order = FALSE,
    verbose = TRUE )

merged_harmony_obj <- IntegrateLayers(
    object = merged_norm_obj,
    method = HarmonyIntegration,
    orig.reduction = "pca",
    new.reduction = "harmonyorder",
    assay = "SCT",
    preserve.order = TRUE,
    verbose = TRUE )

dims <- 1:30
merged_harmony_obj <- merged_harmony_obj %>% 
   FindNeighbors(graph.name = c("harmony_nn","harmony_snn"), 
                 reduction = "harmony",
                 dims = dims) %>% 
   FindNeighbors(graph.name = c("harmonyorder_nn","harmonyorder_snn"), 
                 reduction = "harmonyorder",
                 dims = dims) 
   # FindClusters(resolution = c(0.8, 1.0, 1.5),
   #              algorithm = 2)


merged_harmony_obj <- merged_harmony_obj %>% 
   RunUMAP(reduction = "harmony",
           n.components = 3,
           dims = dims,
           n.neighbors = 30,# default 30
           metric = "cosine",
           min.dist = 0.1, # default 0.3
           negative.sample.rate = 10,
           n.epochs = 500,
           reduction.name = "umap.harmony") %>% 
     RunUMAP(reduction = "harmonyorder",
           n.components = 3,
           dims = dims,
           n.neighbors = 30,# default 30
           metric = "cosine",
           min.dist = 0.1, # default 0.3
           negative.sample.rate = 10,
           n.epochs = 500,
           reduction.name = "umap.harmonyorder")
  
merged_harmony_obj$id <- factor(merged_harmony_obj$orig.ident,
                                levels=unique(merged_harmony_obj$orig.ident))
merged_harmony_obj <- AddMetaData(merged_harmony_obj,
                                  merged_harmony_obj@reductions$umap.harmony@cell.embeddings)
merged_harmony_obj <- AddMetaData(merged_harmony_obj,
                                  merged_harmony_obj@reductions$umap.harmonyorder@cell.embeddings)

job::job({
  saveRDS(merged_harmony_obj, "results/day0_day50/seurat/iPSC_motor_neuron_day0-day50_time-course_filtered_merged_soupX_normalized_harmonyIntegration_seurat_obj_v5.RDS")
}, import = c("merged_harmony_obj"))

pdf("figures/day0_day50/filtered_merged_harmony/merged_harmony_obj_batch_sct_transform_100PCs_elbow_plot.pdf", height = 7, width=10)
ElbowPlot(merged_harmony_obj,ndims = 50, reduction = "pca")
dev.off()
# 
pdf("figures/day0_day50/filtered_merged_harmony/merged_harmony_obj_batch_transform_1-4PCs_loadings.pdf", height = 10, width=7)
VizDimLoadings(merged_harmony_obj, dims = 1:4, reduction = "pca")
dev.off()

purrr::map(c("harmony","harmonyorder"), function(x){

  pdf(glue("figures/day0_day50/filtered_merged_harmony/merged_{x}_obj_batch_byLouvainCluster_sct_UMAP.pdf"),height = 10, width= 17)
  print(DimPlot(merged_harmony_obj,
          reduction = "x",
          dims = c(1,2)) +
    scale_color_manual(values = colors_vector))
  dev.off()
  
  filt_id <- custom_dimplot(metadata = merged_harmony_obj@meta.data,
                           colorby = "id", 
                           add_text = TRUE,
                           label_samples = FALSE,
                           dimred_colnames = x, 
                           custom_colors = sample_id_colors)
  
  filt_batch <- custom_dimplot(metadata = merged_harmony_obj@meta.data,
                           colorby = "batch", 
                           add_text = TRUE,
                           label_samples = FALSE,
                           dimred_colnames = x, 
                           custom_colors = ggsci::pal_jco()(4))
  
  filt_b34_id <- custom_dimplot(metadata = merged_harmony_obj@meta.data %>% 
                              filter(time_point > 30),
                           colorby = "id", 
                           add_text = TRUE,
                           label_samples = FALSE,
                           dimred_colnames = x, 
                           custom_colors = colors_vector)
  
  png(glue("figures/day0_day50/filtered_merged_harmony/merged_{x}_obj_iPSC_MN_seurat_UMAP_splitBy_batch_day_filtered.png"),  height = 15, width = 25, units = "in", res = 150)
  print(filt_b34_id + 
    facet_wrap(~time_point))
  dev.off()
  
  png(glue("figures/day0_day50/filtered_merged_harmony/merged_{x}_obj_iPSC_MN_seurat_UMAP_day_filtered.png"), height = 15, width = 25, units = "in", res = 150)
  print(filt_id)
  dev.off()
  
  png(glue("figures/day0_day50/filtered_merged_harmony/merged_{x}_obj_iPSC_MN_seurat_UMAP_batch_filtered.png"), height = 15, width = 25, units = "in", res = 150)
  print(filt_batch)
  dev.off()
  
  harmony_3d <- make_3D_umap(metadata = merged_harmony_obj@meta.data, 
                 idents_column = c(paste0("umap",x,"_", 1:3)), 
                 label_cols = c("id","batch"), 
                 selected_colors = colors_vector)
  
  htmlwidgets::saveWidget(harmony_3d, glue("figures/day0_day50/filtered_merged_rpca/merged_{x}_obj_iPSC_MN_seurat_UMAP.html"))
})
```

```{r eval=FALSE}
Idents(merged_harmony_obj) <- merged_harmony_obj$orig.ident
purrr::map(names(marker_genes_iPSC), function(type){
 
   h <- ifelse(length(marker_genes_iPSC[[type]]) <= 4, 12, 20)
  outfile <- glue("figures/day0_day50/filtered_merged_harmony/merged_harmony_obj_batch_iPSC_MN_expression_{type}_marker_genes.png")
  
  png(outfile, height = h, width = 20, units = "in", res = 100)
  print(FeaturePlot(merged_harmony_obj, 
                    features = marker_genes_iPSC[[type]],
                    label = TRUE) +
          patchwork::plot_annotation(title = glue("{type} marker genes")))
  dev.off()
})
```

Claudin-6
Cytokeratin 19
EOMES
FABP1/L-FABP
FABP2/I-FABP
GATA-4
Goosecoid
HNF-3 alpha/FoxA1
HNF-3 beta/FoxA2
SOX7
SOX17
TCF-2/HNF-1 beta

```{r eval=FALSE fig.height=10, fig.width=10}
# table(marker_genes_endoderm %in% rownames(merged_harmony_obj))
# marker_genes_endoderm[!marker_genes_endoderm %in% rownames(merged_harmony_obj)]
# "HDE1"  "HDE2"  "FABP2" "TNF" 

marker_genes_endoderm3 <- marker_genes_endoderm[marker_genes_endoderm %in% rownames(merged_harmony_obj)]
marker_genes_endoderm3 <- marker_genes_endoderm3[order(marker_genes_endoderm3)]
length(marker_genes_endoderm3)

Idents(merged_harmony_obj) <- merged_harmony_obj$orig.ident

# png("figures/day0_day50/filtered_merged_harmony/merged_harmony_obj_batch_iPSC_MN_seurat_endoderm_markers_p1.png", height = 12, width = 18, res = 100, units="in")
VlnPlot(merged_harmony_obj,
        features = marker_genes_endoderm[1:9])
# dev.off()

# png("figures/day0_day50/filtered_merged_harmony/merged_harmony_obj_batch_iPSC_MN_seurat_endoderm_markers_p2.png", height = 12, width = 18, res = 100, units="in")
VlnPlot(merged_harmony_obj,
        features = marker_genes_endoderm[10:18])
# dev.off()
```

## Seurat regression 

Since each sample was made a "layer" and so in Layer1 these cells are in the same batch, so lacks 2 factor levels. 

> required or else Error in `contrasts<-`(`*tmp*`, value = contr.funs[1 + isOF[nn]]) :

https://github.com/satijalab/seurat/issues/3657

```{r eval=TRUE}
if(!exists("merged_filt_obj_v3")){
  obj_path <- "results/day0_day50/seurat/iPSC_motor_neuron_day0-day50_time-course_filtered_merged_soupX_normalized_seurat_obj_v3.RDS"
  merged_filt_obj_v3 <- readRDS(obj_path)
  DefaultAssay(merged_filt_obj_v3) <- "RNA"
  merged_filt_obj_v3 <- DietSeurat(object = merged_filt_obj_v3,
                                   assays = "RNA")
                                   
}
# merged_filt_obj_v3
class(merged_filt_obj_v3[["RNA"]]) #v3
quantile(merged_filt_obj_v3$percent.mt)
table(merged_filt_obj_v3$batch)
```

```{r eval=TRUE}
  # options(Seurat.object.assay.version = 'v3')
  #regularized negative binomial regression to normalize UMI count data
  #Note that this single command replaces NormalizeData(), ScaleData(), and FindVariableFeatures().

  DefaultAssay(merged_filt_obj_v3) <- "RNA"
  temp <- merged_filt_obj_v3[grep("^MT-", rownames(merged_filt_obj_v3), invert = TRUE), ]
  temp$batch <- as.factor(merged_filt_obj_v3$batch)
  
  merged_norm_batchcorr <- SCTransform(merged_filt_obj_v3,
                             assay="RNA",
                             new.assay.name = "SCT",
                             vars.to.regress = c("batch","percent.mt"),
                             method = "glmGamPoi",
                             return.only.var.genes = TRUE,
                             verbose = TRUE)
  
  merged_norm_batchcorr <- merged_norm_batchcorr %>%  
    RunPCA(npcs = 50, verbose = FALSE) 

  merged_norm_batchcorr <- merged_norm_batchcorr %>% 
    RunUMAP(reduction = "pca",
              dims = 1:50, 
              n.components = 3,
              n.neighbors = 30,# default 30
              metric = "cosine",
              min.dist = 0.2, # default 0.3
              return.model = TRUE,
              verbose = T) 
  
  merged_norm_batchcorr <- merged_norm_batchcorr %>% 
      FindNeighbors(reduction = "pca",
                    dims = 1:50, 
                    k.param = 20,
                    nn.method = "annoy",
                    annoy.metric = "cosine",
                    n.trees = 100,
                    verbose = T)
  
  merged_norm_batchcorr <- merged_norm_batchcorr %>% 
      FindClusters(resolution = c(0.8, 1.0, 1.5), 
                   algorithm = 2, 
                   verbose = T) 
  
  merged_norm_batchcorr <- AddMetaData(merged_norm_batchcorr,
                                 as.data.frame(merged_norm_batchcorr@reductions$umap@cell.embeddings))

job::job({
  saveRDS(merged_norm_batchcorr,
        "results/day0_day50/seurat/iPSC_motor_neuron_day0-day50_time-course_filtered_merged_soupX_normalized_batchcorrected_seurat_obj_v3.RDS")
}, import = c("merged_norm_batchcorr"))
```

```{r fig.height=10}
if(!exists("merged_norm_batchcorr")){
  merged_norm_batchcorr <- readRDS(file.path(current_path, "results/day0_day50/seurat/iPSC_motor_neuron_day0-day50_time-course_filtered_merged_soupX_normalized_batchcorrected_seurat_obj_v3.RDS"))
}

merged_norm_batchcorr$id <- factor(merged_norm_batchcorr$orig.ident, 
                                   levels = c(unique(merged_norm_batchcorr$orig.ident)))

merged_norm_batchcorr$seurat_clusters <- merged_norm_batchcorr$SCT_snn_res.1
Idents(merged_norm_batchcorr) <- merged_norm_batchcorr$SCT_snn_res.1

merged_norm_batchcorr

# pdf("figures/day0_day50/filtered_merged_batchcorrected/batchcorrected_sct_transform_100PCs_elbow_plot.pdf", height = 7, width=10)
ElbowPlot(merged_norm_batchcorr,ndims = 50, reduction = "pca")
# dev.off()

# pdf("figures/day0_day50/filtered_merged_batchcorrected/batchcorrected_transform_1-4PCs_loadings.pdf", height = 10, width=7)
VizDimLoadings(merged_norm_batchcorr, dims = 1:4, reduction = "pca")
# dev.off()

# pdf("figures/day0_day50/filtered_merged_batchcorrected/batchcorrected_byLouvainCluster_sct_UMAP.pdf",height = 10, width= 17)
DimPlot(merged_norm_batchcorr, dims = c(1,2)) +
  scale_color_manual(values = colors_vector)
# dev.off()
```

```{r eval=FALSE, fig.height=10}
bc_d1 <- DimPlot(merged_norm_batchcorr, 
        group.by = c("batch","id"),
        label = T, 
        repel = T,
        label.size = 7) + 
  scale_color_manual(values = colors_vector)

# png("figures/day0_day50/filtered_merged_batchcorrected/filtered_merged_results_iPSC_MN_seurat_batchcorrected_UMAP_batch_day_filtered.png", height = 15, width = 25, units = "in", res = 150)
bc_d1
# dev.off()

bc_s1 <- DimPlot(merged_norm_batchcorr, 
        group.by = c("id"),
        split.by = "batch",
        label = T, 
        repel = T,
        label.size = 7) + 
  scale_color_manual(values = colors_vector)

# png("figures/day0_day50/filtered_merged_batchcorrected/filtered_merged_results_iPSC_MN_seurat_batchcorrected_UMAP_splitBy_batch_day_filtered.png", height = 15, width = 25, units = "in", res = 150)
bc_s1
# dev.off()
``` 

```{r eval=FALSE}
Idents(merged_norm_batchcorr) <- merged_norm_batchcorr$orig.ident
purrr::map(names(marker_genes_iPSC), function(type){    
  h <- ifelse(length(marker_genes_iPSC[[type]]) <= 4, 12, 20)
  outfile <- glue("figures/day0_day50/filtered_merged_batchcorrected/iPSC_MN_batchcorrected_expression_{type}_marker_genes.png")
  
  # png(outfile, height = h, width = 20, units = "in", res = 100)
  print(
    FeaturePlot(merged_norm_batchcorr, 
                    features = marker_genes_iPSC[[type]],
                    label = TRUE) +
          patchwork::plot_annotation(title = glue("{type} marker genes"))
        )
  # dev.off()
  
})

# Identify the 10 most highly variable genes
top10 <- head(VariableFeatures(merged_norm_batchcorr), 10)

# plot variable features with and without labels
plot1 <- VariableFeaturePlot(merged_norm_batchcorr)
plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)

# pdf("figures/day0_day50/filtered_merged_batchcorrected/iPSC_MN_seurat_batchcorrected_topVarFeatures.pdf", height = 5, width = 10)
plot2
# dev.off()
```


# Session Info

```{r}
session_info()
```






