---
title: "iPSC Motor Neurons Time-series Data"
author: "Jenny L Smith"
date: "`R Sys.Date()`"
output: html_document
---

# Set-up 

```{r set-up, echo=FALSE}
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
knitr::opts_chunk$set(tidy.opts=list(width.cutoff=80),
                      tidy=TRUE,
                      fig.align='center',
                      fig.width = 10, fig.height = 10,
                      eval = TRUE)

options(stringsAsFactors = FALSE, max.print = 100)
options(Seurat.object.assay.version = 'v5')
table = function (..., useNA = 'ifany') base::table(..., useNA = useNA)
```

```{r message=FALSE,warning=FALSE}
library(dplyr)
library(tidyr)
library(magrittr)
library(stringr)
library(tibble)
library(glue)

library(ggplot2)
library(plotly)
library(RColorBrewer)

library(Seurat)
library(reticulate)
library(anndata)
```

```{r message=FALSE, warning=FALSE}
# python modules
if( Sys.info()[["nodename"]] == "pdlposit-0" ) {
  print(Sys.getenv("LD_LIBRARY_PATH"))
  mamba_path <- "miniforge3/envs/scanvi_scib"
  Sys.setenv(LD_LIBRARY_PATH="/home/jsmi26/miniforge3/envs/scanvi_scib/lib")
}else{
  mamba_path <- "opt/mambaforge/envs/scanvi_scib"
}

reticulate::use_condaenv(condaenv = file.path(Sys.getenv("HOME"), mamba_path))
sc <- import("scanpy", convert = FALSE)
scvi <- import("scvi", convert = FALSE)
scib <- import("scib_metrics.benchmark", convert = FALSE)
```

```{r}
conflicted::conflict_prefer("select", "dplyr")
conflicted::conflict_prefer("filter","dplyr")
conflicted::conflict_prefer("saveRDS","base")
```

# Define Functions

```{r}
colors_vector <- c(RColorBrewer::brewer.pal(12, "Paired"), 
            "blue1", "darkslategray3", "burlywood3", "#984EA3",
            "seagreen1", "yellow2", "orchid", "darkblue", 
            "lightsalmon2","slateblue1","lightskyblue4",
            "azure2", "chartreuse1",  "lemonchiffon2",
            "deeppink", "darkslategray1", "green4", "navajowhite", 
            "brown4", "darkgoldenrod2", "deepskyblue1", "lightpink") %>% 
  c(., ggpubr::get_palette("jco", 5)) %>% 
  c("mediumpurple4","magenta", "peru") %>% 
  c(ggsci::pal_igv()(51))

length(colors_vector) 
```

```{r}
make_3D_umap <- function(metadata, idents_column, label_cols, selected_colors=NULL){
    "
    idents_column is for labeling. ex) 'RNA_snn_res.0.7 as well as the UMAP colnames, eg UMAP_1, UMAP_2'
    "
    # 3D UMAP
    plot.data <- metadata
    plot.data$label <- paste(rownames(plot.data))

    plot.data  <- plot.data %>% 
          unite(col = label, all_of(c("label",label_cols)), sep = "\n", remove = FALSE) %>% 
          select(all_of(c("label",label_cols)), all_of(idents_column))

    
    if(is.null(selected_colors)){
      selected_colors <- c("lightseagreen", "gray50",  "darkgreen", "red4", "red", "turquoise4","black","yellow4","royalblue1","lightcyan3",
                 "peachpuff3","lightskyblue","gray20","orange2","royalblue4","yellow3","gray80","darkorchid1","lawngreen","plum2", 
                 "darkorange4","darkmagenta","mediumorchid1","lightslateblue","midnightblue", "tan2") #26
    }

    cnames <- colnames(plot.data)
    formulas <- sapply(1:3, function(x) as.formula(paste0("~", grep(glue("_{x}$"), cnames, value = TRUE))))
    fig <- plot_ly(data = plot.data, 
        x = formulas[[1]], y = formulas[[2]], z = formulas[[3]], 
        color = as.formula(paste0("~", label_cols[1])), 
        colors = selected_colors, 
        type = "scatter3d", 
        mode = "markers", 
        marker = list(size = 1, width=2), # controls size of points
        text=~label, # This is that extra column we made earlier for which we will use for cell ID
        hoverinfo="text") #When you visualize your plotly object, hovering your mouse pointer over a point shows cell names

    return(fig)
}
```

```{r}
custom_dimplot <- function(metadata, colorby, dimred_colnames, custom_colors,
                           lab_size = 6, ny = 0, custom_lab_fill = NULL,
                           label_samples = TRUE,
                           color_text_grp = FALSE,
                           add_text = TRUE, 
                           seed = 2023){
  
  # define x and y column names
  x_names <- paste0(dimred_colnames, "_1")
  y_names <- paste0(dimred_colnames, "_2")
  
  # define labels positions
  labs_df <- metadata %>%
    select(all_of(c(colorby, x_names, y_names))) %>%
    group_by(!! as.name(colorby)) %>% 
    summarise(x = mean(!! as.name(x_names)),
              y = mean(!! as.name(y_names)))
  
   # define point sizes based on how many total cells in data
   ncells <- nrow(metadata)
   pt_size <- case_when(
     ncells < 2e4 ~ 0.75,
     ncells >= 2e4 & ncells < 1e5 ~ 0.5,
     ncells >= 1e5 ~ 0.25)
   
   # Make the scatterplot
   plot <- ggplot(metadata, 
         aes_string(x = x_names, y = y_names)) +
    geom_point(aes_string(color = colorby),
               size = pt_size, alpha = 0.4) +
    scale_color_manual(values = custom_colors) +
    guides(color = guide_legend(override.aes = list(alpha = 1, size = 2))) +
    theme_classic() +
    theme(legend.position = "top")
   
   # customize label positions
   if(is.character(ny)){
     y_val <-  ifelse(grepl(ny, labs_df[[colorby]]), 1.5, 0)
   }else{
     y_val <- ny
   }
   
   if(is.null(custom_lab_fill)){
     fill_val <-  "white"
   }else{
     fill_val <- custom_lab_fill
   }
   
   if(color_text_grp){
     mapping <- aes_string(x = "x", y = "y", label = colorby, color = colorby)

   }else{
     mapping <- aes_string(x = "x", y = "y", label = colorby)
   }
  
   if( all(add_text & label_samples) ){
     plot <- plot + 
           ggrepel::geom_text_repel(data = labs_df, 
                             mapping = aes_string(x = "x", y = "y", label = colorby),
                             color = "black",
                             nudge_y = y_val,
                             segment.colour = NA,
                             size = lab_size,
                             seed = seed)
   }else if ( label_samples ) {
      plot <- plot + 
         ggrepel::geom_label_repel(data = labs_df, 
                           mapping = mapping,
                           fill = fill_val,
                           nudge_y = y_val,
                           segment.colour = NA,
                           label.size = 0.5,
                           size = lab_size,
                           show.legend = FALSE,
                           seed = seed)
   }
   
   return(plot)
}
```

# Parallelization 

```{r}
library(future)
# check the current active plan
plan()
```

```{r eval=FALSE}
plan("multisession", workers = 16)
plan()
options(future.globals.maxSize = 60000 * 1024^2)
```

# Genomic References 

```{r}

```

# Celltype Reference 

```{r eval=FALSE}
cell_ref_adata <- anndata::read_h5ad("results/integrated_ref/scanvi/embryonic_adult_spinal_cord_motor_cortex_scanvi_benchmarking_adata.h5ad")

# cell_ref_adata
```

```{r eval=FALSE}
scanvi_dir <- "results/integrated_ref/scanvi/"
if(!exists("scanvi_model")){
  scanvi_model <- scvi$model$SCANVI$load(dir_path = scanvi_dir, 
                                        prefix = "embryonic_adult_spinal_cord_motor_cortex_scanvi_")
}
```

## UMAP

```{r fig.height=10}
# Look at the integrated reference
sc$pp$neighbors(cell_ref_adata, use_rep="X_scANVI")
sc$tl$leiden(cell_ref_adata)
sc$tl$umap(cell_ref_adata)

sc$pl$umap(
    cell_ref_adata,
    color=c("top_level_standardized", "subtype_standardized", "donor"),
    frameon=TRUE,
    ncols=1L,
)
```

# Read in the Seurat Object

```{r}
#https://github.com/satijalab/seurat/issues/3622
options(future.rng.onMisuse="ignore")
```

```{r}
ipsc_obj <- readRDS("results/day0_day50/seurat/iPSC_motor_neuron_day0-day50_time-course_filtered_merged_soupX_normalized_harmonyIntegration_seurat_obj_v5.RDS")

ipsc_obj
# Add metadata and idents
ipsc_obj$id <- factor(ipsc_obj$orig.ident, levels=unique(ipsc_obj$orig.ident))
ipsc_obj$seurat_clusters <- ipsc_obj$SCT_snn_res.1
Idents(ipsc_obj) <- ipsc_obj$orig.ident
```


# SCANVI Transfer Labels 

### Prepare iPSC Anndata Object 

```{r eval=FALSE}
# logNormalize to be consistent with the reference dataset
DefaultAssay(ipsc_obj) <- 'RNA'
ipsc_obj <- NormalizeData(ipsc_obj, normalization.method = "LogNormalize")
# join layers to export the full raw counts matrix for all samples (layers)
ipsc_obj[["RNA"]] <- JoinLayers(ipsc_obj[["RNA"]])

# create an anndata object with transposed counts matrices
ispc_adata <- AnnData(
  X = t(as.matrix(LayerData(ipsc_obj,assay = 'RNA', layer = "data"))), 
  obs = as.data.frame(ipsc_obj@meta.data),
  layers = list(counts = t(as.matrix(LayerData(ipsc_obj,assay = 'RNA', layer = "counts"))))
)
# Add matching columns for the celltype annotation from reference dataset
ispc_adata$obs$dataset <- "iPSC"
ispc_adata$obs$donor <- ispc_adata$obs$orig.ident
# ispc_adata

anndata::write_h5ad(ispc_adata, "results/day0_day50/scanvi/iPSC_motor_neuron_day0-day50_time-course_filtered_merged_soupX_normalized_adata_obj.h5ad")
```

```{r eval=FALSE}
# these are not integer counts after processing with soupX, so a warning is thinking the counts are normalized.
quantile(ispc_adata$layers['counts'])
    #   0%      25%      50%      75%     100% 
    # 0.00     0.00     0.00     0.00 12450.19
quantile(ispc_adata$X)
#       0%      25%      50%      75%     100% 
# 0.000000 0.000000 0.000000 0.000000 8.057314 
```

### Train Query Model 

```{r eval=FALSE}
length(colnames(ispc_adata))
length(colnames(cell_ref_adata))
# all 5000 most variable genes are present in the iPSC query set
table(colnames(ispc_adata) %in% colnames(cell_ref_adata))
```

weight_decay of 0.0
 *  ensures the latent representation of  reference cells will remain exactly the same

```{r eval=FALSE}
# prepare the query dataset
scanvi_model$prepare_query_anndata(adata = ispc_adata,
                                   reference_model =  scanvi_model)
# scanvi_model

# create the query model 
scanvi_query = scanvi_model$load_query_data(adata = ispc_adata, 
                                            reference_model = scanvi_model, 
                                            accelerator = 'cpu',
                                            device = 'auto')

scanvi_query
# All annotation labels are set as unknown by default. 
ispc_adata$obs$subtype_standardized %>% table()

# train the query model
scanvi_query$train(accelerator = 'cpu',
                   devices = 'auto',
                   max_epochs=200L, 
                   plan_kwargs=list("weight_decay" = 0.0))

# scanvi_query

model_dir <- "results/day0_day50/scanvi"
scanvi_query$save(dir_path = model_dir,
                  prefix = 'iPSC_motor_neuron_day0-day50_time-course_scanvi_', 
                  save_anndata = TRUE, overwrite=TRUE)

```

```{r}
## Predictions
model_dir <- "results/day0_day50/scanvi"
if(!exists("scanvi_query")){
  ispc_adata <- anndata::read_h5ad(file.path(model_dir, "/iPSC_motor_neuron_day0-day50_time-course_scanvi_adata.h5ad"))
  scanvi_query <- scvi$model$SCANVI$load(dir_path = model_dir, 
                                         prefix = "iPSC_motor_neuron_day0-day50_time-course_scanvi_")
}
# scanvi_query

# predict the celltypes 
predictions <- py_to_r(scanvi_query$predict())
names(predictions) <- ispc_adata$obs_names
table(predictions)

# Add predictions to the cell metadata
ispc_adata$obs$subtype_standardized <- predictions

# Update an anndata object & Add the latent representation to the adata object
ispc_adata <- AnnData(
  X = ispc_adata$X, 
  obs = ispc_adata$obs,
  uns = ispc_adata$uns,
  obsm = list('X_scANVI' = scanvi_query$get_latent_representation()
              ),
  layers = list(counts = ispc_adata$layers['counts'],
                scanvi_norm = scanvi_query$get_normalized_expression()
                )
)

# Examine the reduced dimension representation
sc$pp$neighbors(ispc_adata, use_rep='X_scANVI')
sc$tl$leiden(ispc_adata)
sc$tl$umap(ispc_adata)

sc$pl$umap(
    ispc_adata,
    color=c("donor", "subtype_standardized"),
    frameon=FALSE,
    ncols=2L,
)

anndata::write_h5ad(ispc_adata, "results/day0_day50/scanvi/iPSC_motor_neuron_day0-day50_time-course_scanvi_predictions_adata.h5ad")


# Update an anndata object & Add the latent representation to the adata object
# ispc_adata2 <- AnnData(
#   X = ispc_adata$X, 
#   obs = ispc_adata$obs,
#   uns = ispc_adata$uns,
#   obsp = ispc_adata$obsp,
#   obsm = list(X_scANVI = ipsc_adata$obsm['X_scANVI'])
#               # X_umap = ispc_adata$obsm['X_umap'])
#   # layers = list(counts = ispc_adata$layers['counts'],
#   #               scanvi_norm = scanvi_query$get_normalized_expression())
# )
```


## Generate Seurat Object

```{r}
if(!exists("ispc_adata")){
  ispc_adata <- anndata::read_h5ad("results/day0_day50/scanvi/iPSC_motor_neuron_day0-day50_time-course_scanvi_predictions_adata.h5ad")
}
ispc_adata
```

```{r eval=FALSE}
# create dim reduction object 
ipsc_obj[['scanvi']] <- CreateDimReducObject(embeddings = ispc_adata$obsm[['X_scANVI']] %>% 
                                               set_rownames(ispc_adata$obs_names),
                                             key = "scanvi_",
                                             assay = 'RNA')
# create assay of the scanvi normalized data
ipsc_obj[["SCANVI"]] <- CreateAssay5Object(data = t(ispc_adata$layers['scanvi_norm']))
```

```{r eval=FALSE}
DefaultAssay(ipsc_obj) <- 'SCT'

# Add the predictions to the seurat object 
ipsc_obj <- AddMetaData(ipsc_obj, predictions, col.name = "subtype_standardized")

# Run UMAP on the latent data
ipsc_obj <-  RunUMAP(ipsc_obj, 
                      dims = 1:30, 
                      reduction.name = "umap.scanvi",
                      reduction = "scanvi", 
                      n.components = 3L,
                      n.neighbors = 30,# default 30
                      metric = "cosine",
                      min.dist = 0.01, # default 0.3
                      n.epochs = 500,
                      return.model = TRUE,
                      verbose = T) %>%
    FindNeighbors(reduction = "scanvi",
                  dims = 1:30, verbose = T) %>%
    FindClusters(resolution = 0.8, verbose = T)

# Add all Integration UMAPs to metadata
ipsc_obj <- AddMetaData(ipsc_obj, as.data.frame(ipsc_obj@reductions$umap.scanvi@cell.embeddings))
# 
subtype_labels <- ipsc_obj@meta.data %>% 
  mutate(subtype_labels = case_when(
    subtype_standardized == "progenitor" ~ "neuroglial\nprogenitor", 
    subtype_standardized == "schwann" ~ "schwann cell",
    subtype_standardized == "dl3"  ~ "dorsal\ninterneuron 3",
    subtype_standardized == "dl4" ~ "dorsal\ninterneuron 4",
    subtype_standardized == "opc" ~ "oligodendrocyte\nprogenitor",
    subtype_standardized == "motorneurons" ~ "motor neuron",
    TRUE ~ subtype_standardized)) %>% 
  pull(subtype_labels)

table(subtype_labels)
ipsc_obj@meta.data$subtype_labels <- subtype_labels

ipsc_obj
# tail(colnames(ipsc_obj@meta.data))

job::job({
  saveRDS(ipsc_obj, "results/day0_day50/seurat/iPSC_motor_neuron_day0-day50_time-course_filtered_merged_soupX_normalized_dimred_anno_seurat_obj_v5.RDS")
}, import = c("ipsc_obj"))

```

```{r}
if(!exists("ipsc_obj")){
  ipsc_obj <- readRDS("results/day0_day50/seurat/iPSC_motor_neuron_day0-day50_time-course_filtered_merged_soupX_normalized_dimred_anno_seurat_obj_v5.RDS")
}

ipsc_obj
```

```{r}
ct_count_table <- ipsc_obj@meta.data %>% 
  group_by(subtype_standardized) %>% 
  dplyr::count()

ct_count_table
# write.csv(ct_count_table, "results/day0_day50/celltype_annotation_batches1234_by_integrated_ref_summary_table.csv", row.names = FALSE)
```


# Update UMAP Params 

min.dist	
This controls how tightly the embedding is allowed compress points together. Larger values ensure embedded points are moreevenly distributed, while smaller values allow the algorithm to optimise more accurately with regard to local structure. Sensible values are in the range 0.001 to 0.5.

n.neighbors	
This determines the number of neighboring points used in local approximations of manifold structure. Larger values will result in more global structure being preserved at the loss of detailed local structure. In general this parameter should often be in the range 5 to 50.

```{r}
current_path <- file.path("results/day0_day50/seurat")
current_obj <- "iPSC_motor_neuron_day0-day50_time-course_filtered_merged_soupX_normalized_dimred_anno_seurat_obj_v5.RDS" 

if(!exists("ipsc_obj")){
  ipsc_obj <- readRDS(file.path(current_path,current_obj))
}
ipsc_obj
```

```{r eval=FALSE}
# ipsc_obj
class(ipsc_obj[["RNA"]]) #v5

# remove old dim reductions
ipsc_obj@meta.data[,paste0("umapharmony_",1:3)] <- NULL
ipsc_obj@reductions$umap.harmony <- NULL

# Update umap params
ipsc_obj <- ipsc_obj %>% 
          RunUMAP(reduction = "harmony",
                dims = 1:30,
                n.components = 3,
                n.neighbors = 30,# default 30
                metric = "cosine",
                min.dist = 0.2, # default 0.3
                n.epochs = 500,
                reduction.name = "umap.harmony",
                return.model = TRUE,
                verbose = T)


embeddings <- as.data.frame(ipsc_obj@reductions$umap.harmony@cell.embeddings)
ipsc_obj <- AddMetaData(ipsc_obj, embeddings)

# saveRDS(ipsc_obj,"results/day0_day50/seurat/iPSC_motor_neuron_day0-day50_time-course_filtered_merged_soupX_normalized_dimred_ipsc_obj_v5.RDS")
```


## UMAP

```{r fig.height=10, fig.width=10}
DimPlot(ipsc_obj, 
        reduction = "umap.harmony",
        label = FALSE,
        label.size = 2,
        repel = FALSE,
        dims = c(1,2)) +
  scale_color_manual(values = colors_vector) +
  theme(legend.position = 'bottom')


DimPlot(ipsc_obj, 
        reduction = "umap.harmony",
        group.by = 'seurat_clusters',
        label = TRUE,
        label.size = 10,
        repel = TRUE,
        dims = c(1,2)) +
  scale_color_manual(values = colors_vector) +
  theme(legend.position = 'bottom')
```

```{r fig.height=10}
filt_d1 <- DimPlot(ipsc_obj, 
        group.by = c("batch","id"),
        reduction = "umap.harmony",
        label = T, 
        repel = T,
        label.size = 7) + 
  scale_color_manual(values = colors_vector)

filt_s1 <- DimPlot(ipsc_obj, 
        group.by = c("id"),
        reduction = "umap.harmony",
        split.by = "batch",
        label = T, 
        repel = T,
        label.size = 7) + 
  scale_color_manual(values = colors_vector)

filt_d1
filt_s1
```


# Visualization 

```{r}
table(ipsc_obj@meta.data$subtype_standardized)
length(unique(ipsc_obj@meta.data$subtype_standardized))

celltypes <- unique(ipsc_obj@meta.data$subtype_labels)
celltypes <- celltypes[order(celltypes)]

 viridis::turbo(8) %>% 
   set_names(celltypes)
```

```{r fig.height=10, fig.width=10}
# pdf("figures/day0_day50/cell_annotations/iPSC_motor_neuron_cell_annotations_scanvi_UMAP.pdf", height = 15, width = 15)
custom_dimplot(metadata = ipsc_obj@meta.data, 
               dimred_colnames = "umapscanvi", 
               colorby = "subtype_standardized",
               custom_colors = colors_vector)
# dev.off()

# pdf("figures/day0_day50/cell_annotations/iPSC_motor_neuron_sampleID_scanvi_UMAP.pdf", height = 15, width = 15)
custom_dimplot(metadata = ipsc_obj@meta.data, 
               dimred_colnames = "umapscanvi", 
               colorby = "id",
               label_samples = FALSE,
               custom_colors = colors_vector)
# dev.off()

# pdf("figures/day0_day50/cell_annotations/iPSC_motor_neuron_batch_scanvi_UMAP.pdf", height = 15, width = 15)
custom_dimplot(metadata = ipsc_obj@meta.data, 
               dimred_colnames = "umapscanvi", 
               colorby = "batch",
               custom_colors = colors_vector)
# dev.off()

# pdf("figures/day0_day50/cell_annotations/iPSC_motor_neuron_batch_split_scanvi_UMAP.pdf", height = 15, width = 15)
custom_dimplot(metadata = ipsc_obj@meta.data %>% 
                 filter(time_point > 30), 
               dimred_colnames = "umapscanvi", 
               colorby = "id",
               label_samples = FALSE,
               custom_colors = colors_vector[10:20]) +
  facet_wrap(~time_point)
# dev.off()
```

```{r fig.height=10, fig.width=10}
# pdf("figures/day0_day50/cell_annotations/iPSC_motor_neuron_cell_harmony_UMAP.pdf", height = 15, width = 15)
custom_dimplot(metadata = ipsc_obj@meta.data, 
               dimred_colnames = "umapharmony", 
               colorby = "subtype_standardized",
               custom_colors = colors_vector)
# dev.off()

custom_dimplot(metadata = ipsc_obj@meta.data, 
               dimred_colnames = "umapharmony", 
               colorby = "subtype_standardized",
               custom_colors = colors_vector) + 
  facet_wrap(~subtype_standardized)

# pdf("figures/day0_day50/cell_annotations/iPSC_motor_neuron_sampleID_harmony_UMAP.pdf", height = 15, width = 15)
custom_dimplot(metadata = ipsc_obj@meta.data, 
               dimred_colnames = "umapharmony", 
               colorby = "id",
               label_samples = FALSE,
               custom_colors = colors_vector)
# dev.off()
```

```{r}
p1 <- make_3D_umap(metadata = ipsc_obj@meta.data,
             idents_column = c(paste0("umap_",1:3)), 
             label_cols = c("subtype_standardized","id","batch"), 
             selected_colors =  viridis::turbo(8))

p2 <- make_3D_umap(metadata = ipsc_obj@meta.data,
             idents_column = c(paste0("umapharmony_",1:3)), 
             label_cols = c("subtype_standardized","id","batch"), 
             selected_colors =  viridis::turbo(8))

p3 <- make_3D_umap(metadata = ipsc_obj@meta.data,
             idents_column = c(paste0("umapscanvi_",1:3)), 
             label_cols = c("subtype_standardized","id","batch"), 
             selected_colors =  viridis::turbo(8))


htmlwidgets::saveWidget(p1, "figures/day0_day50/cell_annotations/iPSC_motor_neuron_cell_annotations_default_UMAP.html")
htmlwidgets::saveWidget(p2, "figures/day0_day50/cell_annotations/iPSC_motor_neuron_cell_annotations_harmony_UMAP.html")
htmlwidgets::saveWidget(p3, "figures/day0_day50/cell_annotations/iPSC_motor_neuron_cell_annotations_scanvi_UMAP.html")
```

```{r}
make_3D_umap(metadata = ipsc_obj@meta.data,
             idents_column = c(paste0("umap_",1:3)), 
             label_cols = c("batch", "subtype_standardized","id"), 
             selected_colors =  viridis::mako(4))

make_3D_umap(metadata = ipsc_obj@meta.data,
             idents_column = c(paste0("umapharmony_",1:3)), 
             label_cols = c("batch", "subtype_standardized","id"), 
             selected_colors =  viridis::mako(4))

make_3D_umap(metadata = ipsc_obj@meta.data,
             idents_column = c(paste0("umapscanvi_",1:3)), 
             label_cols = c("batch","subtype_standardized","id"), 
             selected_colors =  viridis::mako(4))
```


```{r fig.height=10, fig.width=10}
set.seed(2023)

subtype_labels <- ipsc_obj@meta.data %>% 
  mutate(subtype_labels = case_when(
    subtype_standardized == "progenitor" ~ "neuroglial\nprogenitor", 
    subtype_standardized == "schwann" ~ "schwann cell",
    subtype_standardized == "dl3"  ~ "dorsal\ninterneuron 3",
    subtype_standardized == "dl4" ~ "dorsal\ninterneuron 4",
    subtype_standardized == "opc" ~ "oligodendrocyte\nprogenitor",
    subtype_standardized == "motorneurons" ~ "motor neuron",
    TRUE ~ subtype_standardized)) %>% 
  pull(subtype_labels)

# table(subtype_labels)
ipsc_obj@meta.data$subtype_labels <- subtype_labels

umap_scanvi_plot <- custom_dimplot(metadata = ipsc_obj@meta.data, 
               dimred_colnames = "umapharmony", 
               colorby = "subtype_labels",
               add_text = FALSE,
               ny = "oligod",
               color_text_grp = TRUE,
               lab_size = 4,
               custom_lab_fill = c("white", rep("black",5), "white"),
               custom_colors = viridis::turbo(8)) +
  theme(axis.title = element_text(size=14),
        axis.text = element_text(size=14), 
        legend.title = element_blank(),
        legend.text = element_text(size = 16)) +
  guides(color = guide_legend(ncol=4,override.aes = list(size = 4, alpha = 1)))
  
# png("figures/day0_day50/CTMR/iPSC_day0-day50_scanvi_celltype_annots_UMAP.png", height = 10, width = 10, units = "in", res = 150)
# pdf("figures/day0_day50/CTMR/iPSC_day0-day50_scanvi_celltype_annots_UMAP.pdf", height = 10, width = 10)
umap_scanvi_plot
# dev.off()
```

```{r fig.height=10, fig.width=10}
t <- 200
p <- 120

ipsc_obj$grps <- as.numeric(as.factor(ipsc_obj$subtype_standardized))
ipsc_obj$colors <- viridis::turbo(8)[ipsc_obj$grps]
# ipsc_obj@meta.data %>% 
#   group_by(subtype_standardized, grps, colors) %>% 
#   dplyr::count()


# pdf("Figures/TARGET_AML_ETS_Family_Fusions_plot3D_scatter_3D_long.pdf", height = 10, width = 12)
plot3D::scatter3D(x=ipsc_obj$umap_1, y=ipsc_obj$umap_2, z=ipsc_obj$umap_3,
                   bty = "b2",
                  colvar=ipsc_obj$grps,
                  col=unique(ipsc_obj$colors),
                  pch=19,
                  colkey=TRUE,
                  # theta=t,
                  phi=p,
                  cex=0.1,
                  scale = FALSE)
```

# Cell type frequency vs Time

```{r}
subtype_table <- ipsc_obj@meta.data %>% 
  mutate(subtype_standardized = as.factor(subtype_standardized),
         time_point = as.factor(time_point)) %>% 
  group_by(time_point, subtype_standardized, .drop = FALSE) %>%
  reframe(number_of_cells = n()) %>%
  ungroup() %>% 
  group_by(time_point) %>%
  mutate(total_cells = sum(number_of_cells)) %>% 
  ungroup() %>% 
  mutate(percent_of_cells = round(number_of_cells/total_cells *100, digits = 2)) %>%
  group_by(subtype_standardized) %>%
  arrange(desc(number_of_cells), .by_group = T)

# head(subtype_table)
subtype_table
```

```{r fig.height=10, fig.height=10}
celltypes <- unique(ipsc_obj@meta.data$subtype_standardized)
celltypes <- celltypes[order(celltypes)]

 celltype_colors <- viridis::turbo(8) %>% 
   set_names(celltypes)

total_cells_plot <- ggplot(subtype_table, aes(x = time_point, y = number_of_cells, group = subtype_standardized)) +
  # geom_col(aes(fill = subtype_standardized)) +
  geom_point(aes(color = subtype_standardized), size = 3,
             alpha = 0.7) +
  geom_line(aes(color = subtype_standardized), linewidth = 0.5, linetype = "dashed") +
  scale_color_manual(values = celltype_colors) +
  scale_fill_manual(values = celltype_colors) +
  theme_bw()

pct_cells_plot <- ggplot(subtype_table, aes(x = time_point, y = percent_of_cells, group = subtype_standardized)) +
  # geom_col(aes(fill = subtype_standardized)) +
  geom_point(aes(color = subtype_standardized), size = 3, alpha=0.7) +
  geom_line(aes(color = subtype_standardized), linewidth = 0.5, linetype = "dashed") +
  scale_color_manual(values = celltype_colors) +
  scale_fill_manual(values = celltype_colors) +
  theme_bw()

total_cells_plot

# pdf("figures/day0_day50/cell_annotations/iPSC_motor_neuron_celltypes_per_timepoint_lineplot.pdf")
pct_cells_plot
# dev.off()
```

# Subclustering 

```{r}
current_path <- file.path("results/day0_day50/seurat")
current_obj <- "iPSC_motor_neuron_day0-day50_time-course_filtered_merged_soupX_normalized_anno_subclust_seurat_obj_v5.RDS" #v5 Seurat Object

if(!exists("ipsc_obj")){
  ipsc_obj <- readRDS(file.path(current_path,current_obj))
}
ipsc_obj
```

```{r eval=FALSE}
Idents(ipsc_obj) <- ipsc_obj$subtype_standardized

dims <- 1:30
MNs <- subset(ipsc_obj, idents = "motorneurons") %>% 
  FindNeighbors(reduction = "harmony", 
                dims = dims, 
                k.param = 30) %>% 
  FindClusters(cluster.name = "motorneuron_subclusters", 
               resolution = 0.5,
               algorithm = 1, 
               group.singletons = TRUE)
MNs_df <- MNs@meta.data

prog <- subset(ipsc_obj, idents = "progenitor") %>% 
  FindNeighbors(reduction = "harmony", 
                dims = dims,
                k.param = 30) %>% 
  FindClusters(cluster.name = "progenitor_subclusters", 
               resolution = 0.5,
               algorithm = 1, 
               group.singletons = TRUE)
prog_df <- prog@meta.data


# table(prog_df$progenitor_subclusters) %>% length() #8 
# table(MNs_df$motorneuron_subclusters) %>% length() #4

prog_df%>% 
    make_3D_umap(metadata = ., 
              idents_column = c(paste0("umapharmony", "_",1:3)), 
              label_cols = c("progenitor_subclusters","id","batch"), 
              selected_colors = colors_vector)

MNs_df %>%
  make_3D_umap(metadata = .,
              idents_column = c(paste0("umapharmony", "_",1:3)),
              label_cols = c("motorneuron_subclusters","id","batch"),
              selected_colors = colors_vector)

# rm(MNs)
# rm(prog)

# define the subclusters
# create new subtype labels with the unsupervised subclusters
mn_prog_subclusts <- prog_df %>% 
  select(barcode, progenitor_subclusters, subtype_standardized) %>% 
  bind_rows(., select(MNs_df, barcode, motorneuron_subclusters, subtype_standardized)) %>% 
  bind_rows(., select(ipsc_obj@meta.data, subtype_standardized) %>% 
              filter(!grepl("motor|prog", subtype_standardized))) %>% 
  
  mutate_at(vars(progenitor_subclusters,motorneuron_subclusters), ~ifelse(is.na(.), "", .)) %>% 
  unite(col = "subclusters", progenitor_subclusters,motorneuron_subclusters,
        sep = "", remove = F) %>% 
  mutate(subtype_standardized_subclusters = ifelse(subclusters != "", 
                              paste(subtype_standardized, subclusters, sep="_"), 
                              subtype_standardized),
         barcode_merged = rownames(.)) %>% 
  set_rownames(value = NULL) %>% 
  column_to_rownames("barcode_merged") %>%
  select(subtype_standardized_subclusters)

# table(mn_prog_subclusts)[order(table(mn_prog_subclusts))]

# Add the metadata
ipsc_obj <- AddMetaData(ipsc_obj, mn_prog_subclusts)
length(unique(ipsc_obj$subtype_standardized_subclusters)) #31 

job::job({
  saveRDS(ipsc_obj,"iPSC_motor_neuron_day0-day50_time-course_filtered_merged_soupX_normalized_anno_subclust_seurat_obj_v5.RDS")
}, import = c("ipsc_obj"))
```

```{r}
table(ipsc_obj$subtype_standardized_subclusters)[order(table(ipsc_obj$subtype_standardized_subclusters))]
```

```{r fig.height=15, fig.width=10}
DimPlot(ipsc_obj, 
        label = TRUE,
        repel = TRUE,
        label.size = 4,
        group.by = "subtype_standardized_subclusters",
        reduction = "umap.harmony") +
  scale_color_manual(values = colors_vector) +
  theme(legend.position = "top")
```

```{r}
subcluster_3d <-   make_3D_umap(metadata = ipsc_obj@meta.data,
              idents_column = c(paste0("umapharmony", "_",1:3)),
              label_cols = c("subtype_standardized_subclusters","id","batch"),
              selected_colors = colors_vector)

htmlwidgets::saveWidget(subcluster_3d, "figures/day0_day50/cell_annotations/iPSC_motor_neuron_cell_annotations_harmony_UMAP.html")
```

```{r fig.height=12, fig.width=12}
custom_dimplot(metadata = ipsc_obj@meta.data, 
               colorby = "subtype_standardized", 
               add_text = FALSE,
               dimred_colnames = "umapharmony", 
               custom_colors = brewer.pal(7,"Set3"))

custom_dimplot(metadata = ipsc_obj@meta.data, 
               colorby = "subtype_standardized_subclusters", 
               dimred_colnames = "umapharmony", 
               lab_size = 3,
               custom_colors = colors_vector)

ipsc_obj@meta.data %>%
  filter(grepl("motorneurons_[89]$|progenitor_(7|9|11|14)",subtype_standardized_subclusters)) %>%
  custom_dimplot(metadata = .,
               colorby = "subtype_standardized_subclusters",
               dimred_colnames = "umapharmony", 
               label_samples = FALSE,
               custom_colors = colors_vector[-1])
```

```{r eval=FALSE}
# update to re-classify the "outliers" for MNs and progenitors
ipsc_obj$subtype_subclusters <- case_when(
    grepl("progenitor_[9]$|progenitor_1[0-1]$",ipsc_obj$subtype_standardized_subclusters) ~ "progenitor_in_MNs",
    grepl("motorneurons_[3-9]$|motorneurons_1[0-7]$",ipsc_obj$subtype_standardized_subclusters) ~ "MNs_in_progenitors",
    TRUE ~ as.character(ipsc_obj$subtype_standardized_subclusters)
  )

custom_dimplot(metadata = ipsc_obj@meta.data, 
               colorby = "subtype_subclusters", 
               dimred_colnames = "umapharmonysubset", 
               custom_colors = colors_vector)
```


# Marker Genes

```{r}
make_degs_df <- function(df){
  df %>% 
    select(gene, cluster, avg_log2FC, everything()) %>% 
    group_by(cluster) %>% 
    arrange(desc(avg_log2FC), .by_group = TRUE) %>% 
    filter(p_val_adj < 0.01) %>% 
    ungroup()
}
```

```{r}
ipsc_obj <- PrepSCTFindMarkers(ipsc_obj)
```

```{r eval=FALSE}
ipsc_obj <- PrepSCTFindMarkers(ipsc_obj)

Idents(ipsc_obj) <- ipsc_obj$subtype_standardized_subclusters
degs_subclusters <- FindAllMarkers(ipsc_obj,
                                   assay ="SCT",
                                   logfc.threshold = 0.25,
                                   min.pct = 0.2, 
                                   min.diff.pct = 0.1, 
                                   min.cells.feature = 10,
                                   min.cells.group = 10, 
                                   return.thresh = 0.001)

Idents(ipsc_obj) <- ipsc_obj$subtype_standardized
degs_celltypes <- FindAllMarkers(ipsc_obj,
                                   assay ="SCT",
                                   logfc.threshold = 0.25,
                                   min.pct = 0.2, 
                                   min.diff.pct = 0.1, 
                                   min.cells.feature = 10,
                                   min.cells.group = 10, 
                                   return.thresh = 0.001)

subclusters_results <- make_degs_df(degs_subclusters)
# write.csv(subclusters_results,"results/day0_day50/degs/iPSC_celltypes_subclusters_results_wilcox.test_sct_DEGs.csv", row.names = FALSE)

celltypes_results <- make_degs_df(degs_celltypes)
# write.csv(celltypes_results,"results/day0_day50/degs/iPSC_celltypes_wilcox.test_sct_DEGs.csv", row.names = FALSE)
```

## cell types

```{r}
celltypes_results <- read.csv("results/day0_day50/degs/iPSC_celltypes_wilcox.test_sct_DEGs.csv")
celltypes_results
dim(celltypes_results)
```

```{r}
celltypes_results %>% 
  mutate(diff = pct.1 - pct.2) %>% 
  group_by(cluster) %>% 
  dplyr::top_n(n = 5, wt = avg_log2FC) %>% 
  ungroup()
```

## Subclusters 

```{r}
subclusters_results <- read.csv("results/day0_day50/degs/iPSC_celltypes_subclusters_results_wilcox.test_sct_DEGs.csv")

subclusters_results
dim(subclusters_results)
```

```{r}
top_markers_subclust <- subclusters_results %>% 
  mutate(diff = pct.1 - pct.2) %>% 
  group_by(cluster) %>% 
  dplyr::top_n(n = 5, wt = avg_log2FC) %>% 
  ungroup()
```

## Motorneurons

```{r}
top_mn_genes <- top_markers_subclust %>%
  mutate(clust_number  = as.numeric(str_split_fixed(cluster, "_", n=2)[,2])) %>% 
  filter(grepl("motor", cluster)) %>% 
  arrange(clust_number)

top_mn_genes
```

```{r}
MN_obj <- subset(ipsc_obj, idents = c("motorneurons"))
Idents(MN_obj) <- MN_obj$subtype_standardized_subclusters

# MN_obj

missing <- base::setdiff(top_mn_genes$gene,
                         rownames(MN_obj@assays$SCT@scale.data))

MN_obj <- GetResidual(object = MN_obj, 
                         features = top_mn_genes$gene, 
                         assay = "SCT", 
                         na.rm = FALSE)

MN_obj[["SCT"]]
```

```{r fig.height=10, fig.width=15}
DefaultAssay(MN_obj) <- "RNA"
#Warning: The following features were omitted as they were not found in the scale.data slot for the RNA assay: HSP90AA1
DoHeatmap(MN_obj, 
          features = top_mn_genes$gene)
```

GroupCorrelationPlot(
  object,
  assay = NULL,
  feature.group = "feature.grp",
  cor = "nCount_RNA_cor"
)

# Seurat Transfer Labels 

https://github.com/satijalab/seurat/issues/6675
https://github.com/satijalab/seurat/issues/6054

IntegrateLayers was completed on the SCT assay! So what do I do with 13 models??

BuildClusterTree
Constructs a phylogenetic tree relating the 'average' cell from each identity class. Tree is estimated based on a distance matrix constructed in either gene expression space or PCA space.

### Prepare Cell Ref Object 

```{r eval=FALSE}
cell_ref_obj <-  readRDS("results/integrated_ref/embryonic_adult_spinal_cord_motor_cortex_integrated_normalized_dimred_ipsc_obj_v4.RDS")
```

```{r eval=FALSE}
cell_ref_obj <- LogNormalize(cell_ref_obj)

# Add unsupervised nearest neighbors graphs 
cell_ref_obj <- FindNeighbors(cell_ref_obj, 
                              reduction = "scanvi", 
                              dims = 1:30, 
                              # return.neighbor=TRUE,
                              compute.SNN = TRUE,
                              graph.name = c("scanvi_nn","scanvi_snn"))

cell_ref_obj <- FindNeighbors(cell_ref_obj, 
                          return.neighbor = TRUE,
                          reduction = "scanvi", 
                          dims = 1:30)

Neighbors(cell_ref_obj)
Graphs(cell_ref_obj)
```

```{r}
# Add unsupervised clusters and compare to subtypes 
cell_ref_obj <- FindClusters(cell_ref_obj, 
                             resolution = c(0.5,1,2), 
                             graph.name = "scanvi_snn", 
                             group.singletons = FALSE,
                             verbose = TRUE)

plots <- DimPlot(cell_ref_obj, 
                 reduction = "umap.scanvi",
                 group.by = c("donor", "subtype_standardized","scanvi_snn_res.0.5"), 
                 combine = FALSE)

lapply(plots, function(p) p + 
         scale_color_manual(values = colors_vector) + 
         theme(legend.position = "top"))
```

```{r eval=FALSE}
#Found 13 SCT models. Recorrecting SCT counts using minimum median counts: 2408
# PrepSCTFindMarkers does not change the 13 individual models
cell_ref_obj <- PrepSCTFindMarkers(cell_ref_obj)
cell_ref_obj[["SCT"]]
cell_ref_obj[["RNA"]] # has 1 integrated layer in RNA assay only

cell_ref_split <- SplitObject(cell_ref_obj, split.by = "donor")
# cell_ref_split

# https://github.com/satijalab/seurat/issues/6064
features <- SelectIntegrationFeatures(object.list = cell_ref_split, 
                                      nfeatures = 3000)
cell_ref_split <- PrepSCTIntegration(object.list = cell_ref_split, 
                                         anchor.features = features)
ref_anchors <- FindIntegrationAnchors(object.list = cell_ref_split, 
                                         normalization.method = "SCT",
                                         anchor.features = features)
integrated_ref_obj <- IntegrateData(anchorset = ref_anchors, 
                                    normalization.method = "SCT")
```

normalization.method	
Name of normalization method used: LogNormalize or SCT.

reference.assay	--> use scanvi normalized (denoised) counts
Name of the Assay to use from reference
probably only 5k genes though 

query.assay --> SCT	
Name of the Assay to use from query

```{r}
table(rownames(ipsc_obj) %in% rownames(cell_ref_obj))
# rownames(ipsc_obj)[!rownames(ipsc_obj) %in% rownames(cell_ref_obj)]
table(rownames(cell_ref_obj) %in% rownames(ipsc_obj))
```


```{r}
anchors <- FindTransferAnchors(reference = cell_ref_obj, 
                                  query = ipsc_obj,
                                  k.anchor = 20,
                                  reduction = "pcaproject",
                                  normalization.method = "SCT", 
                                  query.assay = "SCT",
                                  reference.assay = "SCT",
                               
                                  reference.neighbors = "RNA.nn",
                                  reference.reduction = "scanvi",
                                  dims = 1:30)
```

```{r}
ipsc_obj <- MapQuery(
  anchorset = anchors_24,
  query = ipsc_obj,
  reference = ref_24hr,
  refdata = list(
    cell_type_sub = "cell_type_sub",
    cell_type_broad = "cell_type_broad",
    ),
  new.reduction.name = "integrated",
  reference.reduction = "pca", 
  reduction.model = "umap"
)
```

```{r fig.height=15, fig.width=15}
mapped_cell_ids_plot <- DimPlot(ipsc_obj_test, 
                           reduction = "ref.umap",
                           group.by = "predicted.cell_type_broad",
                           cols=ggpubr::get_palette("rickandmorty", 69),
                           label = TRUE,
                           label.size = 6,
                           repel = TRUE) + 
  NoLegend() + 
  ggtitle("DMD transferred labels")


# pdf("figures/soupX_corrected/mapped_cell_identitites_UMAP.pdf", height = 15, width = 15)
mapped_cell_ids_plot
# dev.off()
```


# Session Info

```{r}
session_info()
```






