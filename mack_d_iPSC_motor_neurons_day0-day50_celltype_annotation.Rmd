---
title: "iPSC Motor Neurons Time-series Data"
author: "Jenny L Smith"
date: "`R Sys.Date()`"
output: html_document
---

# Set-up 

```{r set-up, echo=FALSE}
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
knitr::opts_chunk$set(tidy.opts=list(width.cutoff=80),
                      tidy=TRUE,
                      fig.align='center',
                      fig.width = 10, fig.height = 10,
                      eval = TRUE)

options(stringsAsFactors = FALSE, max.print = 100)
options(Seurat.object.assay.version = 'v5')
table = function (..., useNA = 'ifany') base::table(..., useNA = useNA)
```

```{bash, eval=FALSE}
/opt/python/3.11.3/bin/python -m venv .venv
source .venv/bin/activate
python3 -m pip install --upgrade pip #Successfully installed pip-24.0
python3 -m pip install -r env/scanvi_scib_cellrank_requirements.txt #Successfully installed
```

```{r message=FALSE,warning=FALSE}
library(dplyr)
library(tidyr)
library(magrittr)
library(stringr)
library(tibble)
library(glue)

library(ggplot2)
library(plotly)
library(RColorBrewer)

library(Seurat)
library(reticulate)
library(anndata)


# reticulate::use_condaenv(condaenv = file.path(Sys.getenv("HOME"), "opt/mambaforge/envs/scanvi_scib"))
reticulate::use_virtualenv(virtualenv = file.path(getwd(),".venv"))
sc <- reticulate::import("scanpy", convert = FALSE)
scvi <- reticulate::import("scvi", convert = FALSE)
scib <- reticulate::import("scib_metrics.benchmark", convert = FALSE)

conflicted::conflict_prefer("select", "dplyr")
conflicted::conflict_prefer("filter","dplyr")
conflicted::conflict_prefer("saveRDS","base")
conflicted::conflicts_prefer(SeuratObject::Layers)
```

# Define Functions

```{r}
colors_vector <- c(RColorBrewer::brewer.pal(12, "Paired"), 
            "blue1", "darkslategray3", "burlywood3", "#984EA3",
            "seagreen1", "yellow2", "orchid", "darkblue", 
            "lightsalmon2","slateblue1","lightskyblue4",
            "azure2", "chartreuse1",  "lemonchiffon2",
            "deeppink", "darkslategray1", "green4", "navajowhite", 
            "brown4", "darkgoldenrod2", "deepskyblue1", "lightpink") %>% 
  c(., ggpubr::get_palette("jco", 5)) %>% 
  c("mediumpurple4","magenta", "peru") %>% 
  c(ggsci::pal_igv()(51))

sample_id_colors <- c("black",colors_vector[1:18])
length(colors_vector) 
```

```{r}
make_3D_umap <- function(metadata, idents_column, label_cols, selected_colors=NULL){
    "
    idents_column is for labeling. ex) 'RNA_snn_res.0.7 as well as the UMAP colnames, eg UMAP_1, UMAP_2'
    "
    # 3D UMAP
    plot.data <- metadata
    plot.data$label <- paste(rownames(plot.data))

    plot.data  <- plot.data %>% 
          unite(col = label, all_of(c("label",label_cols)), sep = "\n", remove = FALSE) %>% 
          select(all_of(c("label",label_cols)), all_of(idents_column))

    
    if(is.null(selected_colors)){
      selected_colors <- c("lightseagreen", "gray50",  "darkgreen", "red4", "red", "turquoise4","black","yellow4","royalblue1","lightcyan3",
                 "peachpuff3","lightskyblue","gray20","orange2","royalblue4","yellow3","gray80","darkorchid1","lawngreen","plum2", 
                 "darkorange4","darkmagenta","mediumorchid1","lightslateblue","midnightblue", "tan2") #26
    }

    cnames <- colnames(plot.data)
    formulas <- sapply(1:3, function(x) as.formula(paste0("~", grep(glue("_{x}$"), cnames, value = TRUE))))
    fig <- plot_ly(data = plot.data, 
        x = formulas[[1]], y = formulas[[2]], z = formulas[[3]], 
        color = as.formula(paste0("~", label_cols[1])), 
        colors = selected_colors, 
        type = "scatter3d", 
        mode = "markers", 
        marker = list(size = 1, width=2), # controls size of points
        text=~label, # This is that extra column we made earlier for which we will use for cell ID
        hoverinfo="text") #When you visualize your plotly object, hovering your mouse pointer over a point shows cell names

    return(fig)
}
```

```{r}
custom_dimplot <- function(metadata, colorby, dimred_colnames, custom_colors,
                           lab_size = 6, ny = 0, custom_lab_fill = NULL,
                           label_samples = TRUE,
                           color_text_grp = FALSE,
                           add_text = TRUE, 
                           seed = 2023){
  
  # define x and y column names
  x_names <- paste0(dimred_colnames, "_1")
  y_names <- paste0(dimred_colnames, "_2")
  
  # define labels positions
  labs_df <- metadata %>%
    select(all_of(c(colorby, x_names, y_names))) %>%
    group_by(!! as.name(colorby)) %>% 
    summarise(x = mean(!! as.name(x_names)),
              y = mean(!! as.name(y_names)))
  
   # define point sizes based on how many total cells in data
   ncells <- nrow(metadata)
   pt_size <- case_when(
     ncells < 2e4 ~ 0.75,
     ncells >= 2e4 & ncells < 1e5 ~ 0.5,
     ncells >= 1e5 ~ 0.25)
   
   # Make the scatterplot
   plot <- ggplot(metadata, 
         aes_string(x = x_names, y = y_names)) +
    geom_point(aes_string(color = colorby),
               size = pt_size, alpha = 0.4) +
    scale_color_manual(values = custom_colors) +
    guides(color = guide_legend(override.aes = list(alpha = 1, size = 2))) +
    theme_classic() +
    theme(legend.position = "top")
   
   # customize label positions
   if(is.character(ny)){
     y_val <-  ifelse(grepl(ny, labs_df[[colorby]]), 1.5, 0)
   }else{
     y_val <- ny
   }
   
   if(is.null(custom_lab_fill)){
     fill_val <-  "white"
   }else{
     fill_val <- custom_lab_fill
   }
   
   if(color_text_grp){
     mapping <- aes_string(x = "x", y = "y", label = colorby, color = colorby)

   }else{
     mapping <- aes_string(x = "x", y = "y", label = colorby)
   }
  
   if( all(add_text & label_samples) ){
     plot <- plot + 
           ggrepel::geom_text_repel(data = labs_df, 
                             mapping = aes_string(x = "x", y = "y", label = colorby),
                             color = "black",
                             nudge_y = y_val,
                             segment.colour = NA,
                             size = lab_size,
                             seed = seed)
   }else if ( label_samples ) {
      plot <- plot + 
         ggrepel::geom_label_repel(data = labs_df, 
                           mapping = mapping,
                           fill = fill_val,
                           nudge_y = y_val,
                           segment.colour = NA,
                           label.size = 0.5,
                           size = lab_size,
                           show.legend = FALSE,
                           seed = seed)
   }
   
   return(plot)
}
```

# Parallelization 

```{r}
library(future)
# check the current active plan
plan()
```

```{r eval=FALSE}
plan("multisession", workers = 16)
plan()
options(future.globals.maxSize = 60000 * 1024^2)
```

# Genomic References 

```{r}
features <- read.csv("results/filtered_feature_bc_features.csv", row.names = 1) %>% 
  filter(!grepl("^MT-", gene_name))

dim(features) # 33525     5
```

# Celltype Reference 

```{r eval=FALSE}
cell_ref_adata <- anndata::read_h5ad("results/integrated_ref/scanvi/embryonic_adult_spinal_cord_motor_cortex_scanvi_benchmarking_adata.h5ad")

# cell_ref_adata
scanvi_dir <- "results/integrated_ref/scanvi/"
if(!exists("scanvi_model")){
  scanvi_model <- scvi$model$SCANVI$load(dir_path = scanvi_dir, 
                                        prefix = "embryonic_adult_spinal_cord_motor_cortex_scanvi_")
}
```

## UMAP

```{r fig.height=10, eval=FALSE}
# Look at the integrated reference
sc$pp$neighbors(cell_ref_adata, use_rep="X_scANVI")
sc$tl$leiden(cell_ref_adata)
sc$tl$umap(cell_ref_adata)

sc$pl$umap(
    cell_ref_adata,
    color=c("top_level_standardized", "subtype_standardized", "donor"),
    frameon=TRUE,
    ncols=1L,
)
```

# Read in the Seurat Object

```{r}
#https://github.com/satijalab/seurat/issues/3622
options(future.rng.onMisuse="ignore")
```

```{r}
# ipsc_obj <- readRDS("results/day0_day50/seurat/iPSC_MN_time-course_filtered_merged_soupX_normalized_RPCAIntegration_seurat_obj_v5.RDS")

ipsc_obj <- readRDS("results/day0_day50/seurat/non_integrated/iPSC_motor_neuron_day0-day50_time-course_filtered_merged_soupX_normalized_seurat_obj_v5.RDS")

ipsc_obj #60470 features across 86,954 samples within 2 assays
# Add metadata and idents
ipsc_obj$id <- factor(ipsc_obj$orig.ident, levels=unique(ipsc_obj$orig.ident))
ipsc_obj$seurat_clusters <- ipsc_obj$SCT_snn_res.1
Idents(ipsc_obj) <- ipsc_obj$orig.ident

# Add gene id metadata
# identical(rownames(ipsc_obj[["RNA"]]), rownames(features)) #TRUE
ipsc_obj[["RNA"]] <- AddMetaData(ipsc_obj[["RNA"]],
                                 metadata =  features)
```
```{r fig.height=10, fig.width=10}
DimPlot(ipsc_obj, 
        group.by = "id",
        cols = sample_id_colors,
        reduction = "umap")
```

# SCANVI Transfer Labels 

### Prepare iPSC Anndata Object 

https://github.com/satijalab/seurat/issues/8146
Correction during integration happens in scale.data and not in data slot.

https://github.com/satijalab/seurat/issues/6680
Sorry about that, they are in "scale.data" slot
Anyhow, "integrated" assay is useful for clustering etc.. Any downstream analysis should be done on "RNA" or "SCT" assays
This issue #283 is related

```{r eval=TRUE}
# logNormalize to be consistent with the reference dataset
# though SCVI tools does not use normalized counts (only raw), there are post processing steps that require it, like PCA (?).
DefaultAssay(ipsc_obj) <- 'RNA'
ipsc_obj <- NormalizeData(ipsc_obj, normalization.method = "LogNormalize")

# join layers to export the full raw counts matrix for all samples (layers)
ipsc_obj[["RNA"]] <- JoinLayers(ipsc_obj[["RNA"]])

# optionally scale Data and regress out cc_difference in RNA assay
# ipsc_obj <- ScaleData(ipsc_obj, features = VariableFeatures(ipsc_obj), 
#                       vars.to.regress = c("cc_difference"))
ipsc_obj
```

```{r eval=FALSE}
# create an anndata object with transposed counts matrices
ipsc_adata <- AnnData(
  X = t(as.matrix(LayerData(ipsc_obj,assay = 'RNA', layer = "data"))), 
  obs = as.data.frame(ipsc_obj@meta.data),
  layers = list(counts = t(as.matrix(LayerData(ipsc_obj,assay = 'RNA', layer = "counts"))))
)
# Add matching columns for the celltype annotation from reference dataset
ipsc_adata$obs$dataset <- "iPSC"
ipsc_adata$obs$donor <- ipsc_adata$obs$orig.ident
# ipsc_adata

# anndata::write_h5ad(ipsc_adata, "results/day0_day50/scanvi/iPSC_motor_neuron_day0-day50_time-course_filtered_merged_soupX_normalized_adata_obj.h5ad")
```

```{r eval=FALSE}
# these are not integer counts after processing with soupX, so a warning is thinking the counts are normalized.
quantile(ipsc_adata$layers['counts'])
#   0%     25%     50%     75%    100% 
# 0.00    0.00    0.00    0.00 3861.38
quantile(ipsc_adata$X)
#  0%      25%      50%      75%     100% 
# 0.000000 0.000000 0.000000 0.000000 8.057582 
```

### Train Query Model 

```{r eval=FALSE}
length(colnames(ipsc_adata))
length(colnames(cell_ref_adata))
# all 5000 most variable genes are present in the iPSC query set
table(colnames(ipsc_adata) %in% colnames(cell_ref_adata))
```

weight_decay of 0.0
 *  ensures the latent representation of  reference cells will remain exactly the same

```{r eval=FALSE}
# set seed for randomization 
scvi$settings$seed <- as.integer(20231030)

# Additional training settings
scvi$settings$verbosity <- as.integer(1) # verbosity < 20 is INFO and verbosity < 10 is DEBUG
scvi$settings$num_threads <- as.integer(40)

# prepare the query dataset
scanvi_model$prepare_query_anndata(adata = ipsc_adata,
                                   reference_model =  scanvi_model)
# scanvi_model

# create the query model 
scanvi_query = scanvi_model$load_query_data(adata = ipsc_adata, 
                                            reference_model = scanvi_model, 
                                            accelerator = 'cpu',
                                            device = 'auto')

scanvi_query
```
```{r eval=FALSE}
# All annotation labels are set as unknown by default. 
ipsc_adata$obs$subtype_standardized %>% table()

# train the query model
scanvi_query$train(accelerator = 'cpu',
                   devices = 'auto',
                   max_epochs = 200L, 
                   batch_size = as.integer(1024*4),
                   plan_kwargs = list("weight_decay" = 0.0))

# scanvi_query

model_dir <- "results/day0_day50/scanvi"
scanvi_query$save(dir_path = model_dir,
                  prefix = 'iPSC_motor_neuron_day0-day50_time-course_scanvi_', 
                  save_anndata = TRUE, overwrite=TRUE)

```

```{r}
# Examine the set-up of the model
scanvi_query$view_anndata_setup()
```

```{r}
## Predictions
model_dir <- "results/day0_day50/scanvi"
if(!exists("scanvi_query")){
  # ipsc_adata <- anndata::read_h5ad(file.path(model_dir, "/iPSC_motor_neuron_day0-day50_time-course_scanvi_adata.h5ad"))
  scanvi_query <- scvi$model$SCANVI$load(dir_path = model_dir, 
                                         prefix = "iPSC_motor_neuron_day0-day50_time-course_scanvi_")
}
```

```{r eval=FALSE}
# collect error metrics
scanvi_query$get_reconstruction_error(batch_size = as.integer(1024*4))
# {'reconstruction_loss': -3823.433240563976}

#https://discourse.scverse.org/t/how-to-compare-different-parameter-sets-using-the-validation-loss/2017
elbo_tr <- scanvi_query$get_elbo(indices = scanvi_query$train_indices,
                                 batch_size = as.integer(1024*4))
#tensor(-3879.4275)
```

```{r}
# retrieve batch corrected normalized counts
#See: https://discourse.scverse.org/t/what-is-the-best-way-to-extract-a-full-batch-effect-corrected-count-matrix-from-scvi-model/825
# https://www.nxn.se/valent/2023/10/4/interpreting-scvi-adjusted-expression-levels

# use the mid-point in the time-course as the batch to condition on
scanvi_norm_mat <- scanvi_query$get_normalized_expression(n_samples = 10L,
                                                          transform_batch = "iPSC_day24",
                                                          library_size = 1e4)
scanvi_norm_mat <- py_to_r(scanvi_norm_mat)

# predict the celltypes 
predictions <- py_to_r(scanvi_query$predict())
names(predictions) <- ipsc_adata$obs_names

# Add predictions to the cell metadata
ipsc_adata$obs$subtype_standardized <- predictions

# Update an anndata object & Add the latent representation to the adata object
ipsc_adata <- AnnData(
    X = ipsc_adata$X, 
    obs = ipsc_adata$obs,
    uns = ipsc_adata$uns,
    obsm = list('X_scANVI' = scanvi_query$get_latent_representation()),
    layers = list(counts = ipsc_adata$layers['counts'],
                  scanvi_norm = scanvi_norm_mat)
)

# Examine the reduced dimension representation
sc$pp$neighbors(ipsc_adata, use_rep='X_scANVI')
sc$tl$leiden(ipsc_adata)
sc$tl$umap(ipsc_adata)
# anndata::write_h5ad(ipsc_adata, "results/day0_day50/scanvi/iPSC_motor_neuron_day0-day50_time-course_scanvi_predictions_adata.h5ad")
```

```{r fig.height=10, fig.width=10}
umap_coords <- ipsc_adata$obsm[['X_umap']] %>%
  set_rownames(ipsc_adata$obs_names) %>% 
  set_colnames(c("umap_1","umap_2")) %>% 
  as.data.frame() %>% 
  rownames_to_column("barcode") %>% 
  left_join(., select(ipsc_adata$obs,
                      donor, 
                      subtype_standardized, 
                      barcode), 
            by = "barcode") %>% 
  mutate(donor = factor(donor, levels = unique(ipsc_adata$obs$orig.ident)))
# head(umap_coords)

sample_id_colors <- sample_id_colors %>% 
  set_names(unique(ipsc_adata$obs$orig.ident))

ggplot(umap_coords, aes(x = umap_1, y= umap_2)) +
  geom_point(aes(color = donor), size = 0.2, alpha = 0.25) +
  scale_color_manual(values = sample_id_colors) +
  guides(color = guide_legend(override.aes = list(size =2, alpha =1 ))) +
  theme_classic() 

ggplot(umap_coords, aes(x = umap_1, y= umap_2)) +
  geom_point(aes(color = subtype_standardized), size = 0.2, alpha = 0.25) +
  scale_color_manual(values = colors_vector) +
  guides(color = guide_legend(override.aes = list(size =2, alpha =1 ))) +
  theme_classic() 
```

## Generate Seurat Object

```{r}
if(!exists("ipsc_adata")){
  ipsc_adata <- anndata::read_h5ad("results/day0_day50/scanvi/iPSC_motor_neuron_day0-day50_time-course_scanvi_predictions_adata.h5ad")
}
ipsc_adata
```

```{r eval=FALSE}
# create dim reduction object 
ipsc_obj[['scanvi']] <- CreateDimReducObject(embeddings = ipsc_adata$obsm[['X_scANVI']] %>% 
                                               set_rownames(ipsc_adata$obs_names),
                                             key = "scanvi_",
                                             assay = 'RNA')
# create assay of the scanvi normalized data
ipsc_obj[["SCANVI"]] <- CreateAssay5Object(data = t(ipsc_adata$layers['scanvi_norm']))
```

```{r eval=FALSE}
DefaultAssay(ipsc_obj) <- 'SCT'

# Add the predictions to the seurat object 
ipsc_obj <- AddMetaData(ipsc_obj, predictions, col.name = "subtype_standardized")

# Run UMAP on the latent data
ipsc_obj <-  RunUMAP(ipsc_obj, 
                      dims = 1:30, 
                      reduction.name = "umap.scanvi",
                      reduction = "scanvi", 
                      n.components = 3L,
                      n.neighbors = 15,# default 30
                      metric = "cosine",
                      min.dist = 0.1, # default 0.3
                      n.epochs = 500,
                      return.model = TRUE,
                      verbose = T) %>%
    FindNeighbors(reduction = "scanvi",
                  dims = 1:30, verbose = T) %>%
    FindClusters(resolution = 0.8, verbose = T)

# Add all Integration UMAPs to metadata
ipsc_obj <- AddMetaData(ipsc_obj, as.data.frame(ipsc_obj@reductions$umap.scanvi@cell.embeddings))

subtype_labels <- ipsc_obj@meta.data %>% 
  mutate(subtype_labels = case_when(
    subtype_standardized == "progenitor" ~ "neuroglial\nprogenitor", 
    subtype_standardized == "schwann" ~ "schwann cell",
    subtype_standardized == "dl3"  ~ "dorsal\ninterneuron 3",
    subtype_standardized == "dl4" ~ "dorsal\ninterneuron 4",
    subtype_standardized == "opc" ~ "oligodendrocyte\nprogenitor",
    subtype_standardized == "motorneurons" ~ "motor neuron",
    TRUE ~ subtype_standardized)) %>% 
  pull(subtype_labels)

table(subtype_labels)
ipsc_obj@meta.data$subtype_labels <- subtype_labels

ipsc_obj
# tail(colnames(ipsc_obj@meta.data))

job::job({
  saveRDS(ipsc_obj, "results/day0_day50/seurat/iPSC_motor_neuron_day0-day50_time-course_filtered_merged_soupX_normalized_dimred_anno_seurat_obj_v5.RDS")
}, import = c("ipsc_obj"))
```

```{r}
# head(ipsc_obj@assays$RNA@layers$data[,1:200])
# head(ipsc_obj@assays$RNA@layers$counts[,1:200])
```

## Celltype Frequency 

```{r}
if(!exists("ipsc_obj")){
  ipsc_obj <- readRDS("results/day0_day50/seurat/iPSC_motor_neuron_day0-day50_time-course_filtered_merged_soupX_normalized_dimred_anno_seurat_obj_v5.RDS")
}

ipsc_obj
table(ipsc_obj@meta.data$subtype_standardized)
```

```{r}
celltype_annots <- ipsc_obj@meta.data %>% 
  select(time_point, subtype_standardized, subtype_labels) %>% 
  rownames_to_column("barcode")

head(celltype_annots)
dim(celltype_annots) # 86954     3
# write.csv(celltype_annots, "results/day0_day50/scanvi/iPSC_motor_neuron_day0-day50_time-course_scanvi_predictions_v2.csv", row.names = FALSE)
```

```{r fig.width=10}
ct_count_table <- ipsc_obj@meta.data %>% 
  group_by(subtype_standardized) %>% 
  dplyr::count() %>% 
  ungroup()  %>% 
  mutate(total = nrow(ipsc_obj@meta.data), 
         percent = round(n / total *100, digits = 2)) %>% 
  arrange(percent) %>% 
  mutate(subtype_standardized = factor(subtype_standardized, levels = unique(subtype_standardized)))

ggplot(ct_count_table, 
       aes(x = subtype_standardized, y = percent)) +
  geom_col(aes(fill = subtype_standardized)) +
  scale_fill_brewer() +
  scale_y_continuous(breaks = seq(0,65, by = 5)) +
  theme_bw()
# write.csv(ct_count_table, "results/day0_day50/celltype_annotation_batches1234_by_integrated_ref_summary_table_v2.csv", row.names = FALSE)
```

```{r}
# Oof, so about 16% of cells have changed classification between the three tweaks
all_predictions <- celltype_annots %>% 
  full_join(., read.csv("results/day0_day50/scanvi/iPSC_motor_neuron_day0-day50_time-course_scanvi_predictions_v1.csv") %>% 
              select(barcode, subtype_standardized_v1 = subtype_standardized), 
            by = "barcode") %>%
  full_join(., read.csv("results/day0_day50/scanvi/iPSC_motor_neuron_day0-day50_time-course_batches123_scanvi_predictions.csv") %>% 
              select(barcode, subtype_standardized_b123 = subtype_standardized), 
            by = "barcode")  %>% 
  mutate(subtype_standardized = ifelse(is.na(subtype_standardized), "removed_upper_limits", subtype_standardized), 
         subtype_changed = subtype_standardized != subtype_standardized_v1) %>% 
  
  group_by(subtype_standardized, subtype_changed) %>% 
  mutate(subtype_standard_detail = case_when(
    !subtype_changed ~ subtype_standardized,
    subtype_changed & n() >= 100 ~ glue("new: {subtype_standardized}; old: {subtype_standardized_v1}"), 
    subtype_changed ~ glue("new: {subtype_standardized}; old: others")))
  

head(all_predictions)

# Add metadata to the object 
# ipsc_obj <- AddMetaData(ipsc_obj, metadata = data.frame(subtype_standard_detail = all_predictions$subtype_standard_detail) %>% 
#   set_rownames(all_predictions$barcode))
```

```{r}
all_predictions %>% 
  filter(subtype_standardized_b123 == "schwann") %>% 
  group_by(subtype_standardized_b123, subtype_standardized) %>% 
  dplyr::count()

# all_predictions %>% 
#   filter(subtype_standardized_b123 == "schwann") %>% 
#   group_by(subtype_standardized_b123, subtype_standardized_v1) %>% 
#   dplyr::count()

all_predictions  %>% 
  filter(time_point == 0, subtype_changed) %>% 
  arrange(desc(subtype_standardized), subtype_standardized_v1) %>% 
  # group_by(subtype_standardized, subtype_standardized_v1) %>% 
  # dplyr::count()
  View()

```

```{r fig.height=10}
cats <- unique(filter(ipsc_obj@meta.data,time_point == 0)$subtype_standard_detail)
length(cats) #8 

cat_colors <- colors_vector[1:8] %>% 
  set_names(cats)
cat_colors["progenitor"] <- "grey80"

custom_dimplot(metadata = filter(ipsc_obj@meta.data,time_point == 0),
               colorby = c("subtype_standard_detail"), 
               dimred_colnames = "umap", 
               custom_colors = cat_colors )
```

```{r}
all_predictions %>% 
  filter(subtype_standardized != subtype_standardized_v1) %>% 
  select(-subtype_labels) %>% 
  arrange(subtype_standardized) %>% 
  group_by(subtype_standardized, subtype_standardized_v1) %>% 
  dplyr::count() %>% 
  View()
```

# Visualization 

```{r}
table(ipsc_obj@meta.data$subtype_standardized)
length(unique(ipsc_obj@meta.data$subtype_standardized))

celltypes <- unique(ipsc_obj@meta.data$subtype_labels)
celltypes <- celltypes[order(celltypes)]
length(celltypes)

 viridis::turbo(7) %>% 
   set_names(celltypes)
```

```{r fig.height=10, fig.width=10}
# pdf("figures/day0_day50/cell_annotations/iPSC_motor_neuron_cell_annotations_scanvi_UMAP.pdf", height = 15, width = 15)
custom_dimplot(metadata = ipsc_obj@meta.data, 
               dimred_colnames = "umapscanvi", 
               colorby = "subtype_standardized",
               custom_colors = colors_vector)
# dev.off()

# pdf("figures/day0_day50/cell_annotations/iPSC_motor_neuron_sampleID_scanvi_UMAP.pdf", height = 15, width = 15)
custom_dimplot(metadata = ipsc_obj@meta.data, 
               dimred_colnames = "umapscanvi", 
               colorby = "id",
               label_samples = FALSE,
               custom_colors = sample_id_colors)
# dev.off()

# pdf("figures/day0_day50/cell_annotations/iPSC_motor_neuron_batch_scanvi_UMAP.pdf", height = 15, width = 15)
custom_dimplot(metadata = ipsc_obj@meta.data, 
               dimred_colnames = "umapscanvi", 
               colorby = "batch",
               custom_colors = colors_vector)
# dev.off()

# pdf("figures/day0_day50/cell_annotations/iPSC_motor_neuron_batch_split_scanvi_UMAP.pdf", height = 15, width = 15)
custom_dimplot(metadata = ipsc_obj@meta.data %>% 
                 filter(time_point > 30), 
               dimred_colnames = "umapscanvi", 
               colorby = "id",
               label_samples = FALSE,
               custom_colors = colors_vector[10:20]) +
  facet_wrap(~time_point)
# dev.off()
```

```{r fig.height=10, fig.width=10}
# pdf("figures/day0_day50/cell_annotations/iPSC_motor_neuron_cell_harmony_UMAP.pdf", height = 15, width = 15)
custom_dimplot(metadata = ipsc_obj@meta.data, 
               dimred_colnames = "umaprpca", 
               colorby = "subtype_standardized",
               custom_colors = colors_vector)
# dev.off()

custom_dimplot(metadata = ipsc_obj@meta.data, 
               dimred_colnames = "umaprpca", 
               colorby = "subtype_standardized",
               custom_colors = colors_vector) + 
  facet_wrap(~subtype_standardized)

# pdf("figures/day0_day50/cell_annotations/iPSC_motor_neuron_sampleID_harmony_UMAP.pdf", height = 15, width = 15)
custom_dimplot(metadata = ipsc_obj@meta.data, 
               dimred_colnames = "umaprpca", 
               colorby = "id",
               label_samples = FALSE,
               custom_colors = colors_vector)
# dev.off()
```

```{r}
p1 <- make_3D_umap(metadata = ipsc_obj@meta.data,
             idents_column = c(paste0("umap_",1:3)), 
             label_cols = c("subtype_standardized","id","batch"), 
             selected_colors =  viridis::turbo(8))

# p2 <- make_3D_umap(metadata = ipsc_obj@meta.data,
#              idents_column = c(paste0("umaprpca_",1:3)), 
#              label_cols = c("subtype_standardized","id","batch"), 
#              selected_colors =  viridis::turbo(8))

p3 <- make_3D_umap(metadata = ipsc_obj@meta.data,
             idents_column = c(paste0("umapscanvi_",1:3)), 
             label_cols = c("subtype_standardized","id","batch"), 
             selected_colors =  viridis::turbo(8))


p3
# htmlwidgets::saveWidget(p1, "figures/day0_day50/cell_annotations/iPSC_motor_neuron_cell_annotations_default_UMAP.html")
# htmlwidgets::saveWidget(p2, "figures/day0_day50/cell_annotations/iPSC_motor_neuron_cell_annotations_harmony_UMAP.html")
# htmlwidgets::saveWidget(p3, "figures/day0_day50/cell_annotations/iPSC_motor_neuron_cell_annotations_scanvi_UMAP.html")
```

```{r}
# make_3D_umap(metadata = ipsc_obj@meta.data,
#              idents_column = c(paste0("umap_",1:3)), 
#              label_cols = c("batch", "subtype_standardized","id"), 
#              selected_colors =  viridis::mako(4))

# make_3D_umap(metadata = ipsc_obj@meta.data,
#              idents_column = c(paste0("umaprpca_",1:3)), 
#              label_cols = c("batch", "subtype_standardized","id"), 
#              selected_colors =  viridis::mako(4))

make_3D_umap(metadata = ipsc_obj@meta.data,
             idents_column = c(paste0("umapscanvi_",1:3)), 
             label_cols = c("id", "batch","subtype_standardized"), 
             selected_colors =  sample_id_colors)
```

```{r fig.height=10, fig.width=10}
set.seed(2023)

subtype_labels <- ipsc_obj@meta.data %>% 
  mutate(subtype_labels = case_when(
    subtype_standardized == "progenitor" ~ "neuroglial\nprogenitor", 
    subtype_standardized == "schwann" ~ "schwann cell",
    subtype_standardized == "dl3"  ~ "dorsal\ninterneuron 3",
    subtype_standardized == "dl4" ~ "dorsal\ninterneuron 4",
    subtype_standardized == "opc" ~ "oligodendrocyte\nprogenitor",
    subtype_standardized == "motorneurons" ~ "motor neuron",
    TRUE ~ subtype_standardized)) %>% 
  pull(subtype_labels)

# table(subtype_labels)
ipsc_obj@meta.data$subtype_labels <- subtype_labels

umap_scanvi_plot <- custom_dimplot(metadata = ipsc_obj@meta.data, 
               dimred_colnames = "umaprpca", 
               colorby = "subtype_labels",
               add_text = FALSE,
               ny = c(0,0.5,0.5,rep(0,3),1),
               color_text_grp = TRUE,
               lab_size = 4,
               custom_lab_fill = c("white", rep("black",5), "white"),
               custom_colors = viridis::turbo(8)) +
  theme(axis.title = element_text(size=14),
        axis.text = element_text(size=14), 
        legend.title = element_blank(),
        legend.text = element_text(size = 16)) +
  guides(color = guide_legend(ncol=4,override.aes = list(size = 4, alpha = 1)))
  
# png("figures/day0_day50/CTMR/iPSC_day0-day50_scanvi_celltype_annots_UMAP.png", height = 10, width = 10, units = "in", res = 150)
# pdf("figures/day0_day50/CTMR/iPSC_day0-day50_scanvi_celltype_annots_UMAP.pdf", height = 10, width = 10)
umap_scanvi_plot
# dev.off()
```

```{r fig.height=10, fig.width=10}
t <- 200
p <- 120

ipsc_obj$grps <- as.numeric(as.factor(ipsc_obj$subtype_standardized))
ipsc_obj$colors <- viridis::turbo(8)[ipsc_obj$grps]
# ipsc_obj@meta.data %>% 
#   group_by(subtype_standardized, grps, colors) %>% 
#   dplyr::count()


# pdf("Figures/TARGET_AML_ETS_Family_Fusions_plot3D_scatter_3D_long.pdf", height = 10, width = 12)
plot3D::scatter3D(x=ipsc_obj$umap_1, y=ipsc_obj$umap_2, z=ipsc_obj$umap_3,
                   bty = "b2",
                  colvar=ipsc_obj$grps,
                  col=unique(ipsc_obj$colors),
                  pch=19,
                  colkey=TRUE,
                  # theta=t,
                  phi=p,
                  cex=0.1,
                  scale = FALSE)
```

# Cell type frequency vs Time

```{r}
subtype_table <- ipsc_obj@meta.data %>% 
  mutate(subtype_standardized = as.factor(subtype_standardized),
         time_point = as.factor(time_point)) %>% 
  group_by(time_point, subtype_standardized, .drop = FALSE) %>%
  reframe(number_of_cells = n()) %>%
  ungroup() %>% 
  group_by(time_point) %>%
  mutate(total_cells = sum(number_of_cells)) %>% 
  ungroup() %>% 
  mutate(percent_of_cells = round(number_of_cells/total_cells *100, digits = 2)) %>%
  group_by(subtype_standardized) %>%
  arrange(desc(number_of_cells), .by_group = T)

# head(subtype_table)
subtype_table
```

```{r fig.height=10, fig.height=10}
celltypes <- unique(ipsc_obj@meta.data$subtype_standardized)
celltypes <- celltypes[order(celltypes)]

 celltype_colors <- viridis::turbo(8) %>% 
   set_names(celltypes)

total_cells_plot <- ggplot(subtype_table, aes(x = time_point, y = number_of_cells, group = subtype_standardized)) +
  # geom_col(aes(fill = subtype_standardized)) +
  geom_point(aes(color = subtype_standardized), size = 3,
             alpha = 0.7) +
  geom_line(aes(color = subtype_standardized), linewidth = 0.5, linetype = "dashed") +
  scale_color_manual(values = celltype_colors) +
  scale_fill_manual(values = celltype_colors) +
  theme_bw()

pct_cells_plot <- ggplot(subtype_table, aes(x = time_point, y = percent_of_cells, group = subtype_standardized)) +
  # geom_col(aes(fill = subtype_standardized)) +
  geom_point(aes(color = subtype_standardized), size = 3, alpha=0.7) +
  geom_line(aes(color = subtype_standardized), linewidth = 0.5, linetype = "dashed") +
  scale_color_manual(values = celltype_colors) +
  scale_fill_manual(values = celltype_colors) +
  theme_bw()

total_cells_plot

# pdf("figures/day0_day50/cell_annotations/iPSC_motor_neuron_celltypes_per_timepoint_lineplot.pdf")
pct_cells_plot
# dev.off()
```

# Subclustering 

```{r}
current_path <- file.path("results/day0_day50/seurat")
current_obj <- "iPSC_motor_neuron_day0-day50_time-course_filtered_merged_soupX_normalized_anno_subclust_seurat_obj_v5.RDS" #v5 Seurat Object

if(!exists("ipsc_obj")){
  ipsc_obj <- readRDS(file.path(current_path,current_obj))
}
ipsc_obj
```

```{r eval=FALSE}
Idents(ipsc_obj) <- ipsc_obj$subtype_standardized

dims <- 1:30
MNs <- subset(ipsc_obj, idents = "motorneurons") %>% 
  FindNeighbors(reduction = "rpca", 
                dims = dims, 
                k.param = 30) %>% 
  FindClusters(cluster.name = "motorneuron_subclusters", 
               resolution = 0.25,
               algorithm = 1, 
               group.singletons = TRUE)
MNs_df <- MNs@meta.data

prog <- subset(ipsc_obj, idents = "progenitor") %>% 
  FindNeighbors(reduction = "rpca", 
                dims = dims,
                k.param = 30) %>% 
  FindClusters(cluster.name = "progenitor_subclusters", 
               resolution = 0.25,
               algorithm = 1, 
               group.singletons = TRUE)
prog_df <- prog@meta.data


table(prog_df$progenitor_subclusters) %>% length() #8
table(MNs_df$motorneuron_subclusters) %>% length() #9
# use an ensembl based algorith to tune the res jaccard index/siloutte values 

prog_df%>% 
    make_3D_umap(metadata = ., 
              idents_column = c(paste0("umaprpca", "_",1:3)), 
              label_cols = c("progenitor_subclusters","id","batch"), 
              selected_colors = colors_vector)

MNs_df %>%
  make_3D_umap(metadata = .,
              idents_column = c(paste0("umaprpca", "_",1:3)),
              label_cols = c("motorneuron_subclusters","id","batch"),
              selected_colors = colors_vector)

# define the subclusters
# create new subtype labels with the unsupervised subclusters
mn_prog_subclusts <- prog_df %>% 
  select(barcode, progenitor_subclusters, subtype_standardized) %>% 
  bind_rows(., select(MNs_df, barcode, motorneuron_subclusters, subtype_standardized)) %>% 
  bind_rows(., select(ipsc_obj@meta.data, subtype_standardized) %>% 
              filter(!grepl("motor|prog", subtype_standardized))) %>% 
  
  mutate_at(vars(progenitor_subclusters,motorneuron_subclusters), ~ifelse(is.na(.), "", .)) %>% 
  unite(col = "subclusters", progenitor_subclusters,motorneuron_subclusters,
        sep = "", remove = F) %>% 
  mutate(subtype_standardized_subclusters = ifelse(subclusters != "", 
                              paste(subtype_standardized, subclusters, sep="_"), 
                              subtype_standardized),
         barcode_merged = rownames(.)) %>% 
  set_rownames(value = NULL) %>% 
  column_to_rownames("barcode_merged") %>%
  select(subtype_standardized_subclusters)

# table(mn_prog_subclusts)[order(table(mn_prog_subclusts))]

# Add the metadata
ipsc_obj <- AddMetaData(ipsc_obj, mn_prog_subclusts)
length(unique(ipsc_obj$subtype_standardized_subclusters)) #22

job::job({
  saveRDS(ipsc_obj,"results/day0_day50/seurat/iPSC_MN_day0-day50_time-course_filtered_merged_soupX_normalized_RPCA_anno_subclust_seurat_obj_v5.RDS")
}, import = c("ipsc_obj"))

rm(MNs, prog)
```


```{r fig.height=15, fig.width=10}
DimPlot(ipsc_obj, 
        label = TRUE,
        repel = TRUE,
        label.size = 4,
        group.by = "subtype_standardized_subclusters",
        reduction = "umap.rpca") +
  scale_color_manual(values = colors_vector) +
  theme(legend.position = "top")
```

```{r fig.height=10}
subcluster_3d <-   make_3D_umap(metadata = ipsc_obj@meta.data,
              idents_column = c(paste0("umaprpca", "_",1:3)),
              label_cols = c("subtype_standardized_subclusters","id","batch"),
              selected_colors = colors_vector)

subcluster_3d
# htmlwidgets::saveWidget(subcluster_3d, "figures/day0_day50/cell_annotations/iPSC_motor_neuron_cell_annotations_rpca_UMAP.html")
```

```{r fig.height=12, fig.width=12, eval=FALSE}
custom_dimplot(metadata = ipsc_obj@meta.data, 
               colorby = "subtype_standardized", 
               add_text = FALSE,
               dimred_colnames = "", 
               custom_colors = brewer.pal(7,"Set3"))

custom_dimplot(metadata = ipsc_obj@meta.data, 
               colorby = "subtype_standardized_subclusters", 
               dimred_colnames = "", 
               lab_size = 3,
               custom_colors = colors_vector)

custom_dimplot(metadata = ipsc_obj@meta.data, 
               dimred_colnames = "umapscanvi", 
               colorby = "subtype_standardized_subclusters",
               custom_colors = colors_vector)
```


# Marker Genes

```{r}
make_degs_df <- function(df){
  df %>% 
    select(gene, cluster, avg_log2FC, everything()) %>% 
    group_by(cluster) %>% 
    arrange(desc(avg_log2FC), .by_group = TRUE) %>% 
    filter(p_val_adj < 0.01) %>% 
    ungroup()
}
```

```{r eval=FALSE}
ipsc_obj <- PrepSCTFindMarkers(ipsc_obj)

Idents(ipsc_obj) <- ipsc_obj$subtype_standardized_subclusters
degs_subclusters <- FindAllMarkers(ipsc_obj,
                                   assay ="SCT",
                                   logfc.threshold = 0.25,
                                   min.pct = 0.2, 
                                   min.diff.pct = 0.1, 
                                   min.cells.feature = 10,
                                   min.cells.group = 10, 
                                   return.thresh = 0.001)

Idents(ipsc_obj) <- ipsc_obj$subtype_standardized
degs_celltypes <- FindAllMarkers(ipsc_obj,
                                   assay ="SCT",
                                   logfc.threshold = 0.25,
                                   min.pct = 0.2, 
                                   min.diff.pct = 0.1, 
                                   min.cells.feature = 10,
                                   min.cells.group = 10, 
                                   return.thresh = 0.001)

subclusters_results <- make_degs_df(degs_subclusters)
# write.csv(subclusters_results,"results/day0_day50/degs/iPSC_celltypes_subclusters_results_wilcox.test_sct_DEGs.csv", row.names = FALSE)

celltypes_results <- make_degs_df(degs_celltypes)
# write.csv(celltypes_results,"results/day0_day50/degs/iPSC_celltypes_wilcox.test_sct_DEGs.csv", row.names = FALSE)
```

## cell types

```{r}
celltypes_results <- read.csv("results/day0_day50/degs/iPSC_celltypes_wilcox.test_sct_DEGs.csv")
celltypes_results
dim(celltypes_results)
```

```{r}
celltypes_results %>% 
  mutate(diff = pct.1 - pct.2) %>% 
  group_by(cluster) %>% 
  dplyr::top_n(n = 5, wt = avg_log2FC) %>% 
  ungroup()
```

## Subclusters 

```{r}
subclusters_results <- read.csv("results/day0_day50/degs/iPSC_celltypes_subclusters_results_wilcox.test_sct_DEGs.csv")

subclusters_results
dim(subclusters_results)
```

```{r}
top_markers_subclust <- subclusters_results %>% 
  mutate(diff = pct.1 - pct.2) %>% 
  group_by(cluster) %>% 
  dplyr::top_n(n = 5, wt = avg_log2FC) %>% 
  ungroup()
```

## Motorneurons

```{r}
top_mn_genes <- top_markers_subclust %>%
  mutate(clust_number  = as.numeric(str_split_fixed(cluster, "_", n=2)[,2])) %>% 
  filter(grepl("motor", cluster)) %>% 
  arrange(clust_number)

top_mn_genes
```

```{r}
MN_obj <- subset(ipsc_obj, idents = c("motorneurons"))
Idents(MN_obj) <- MN_obj$subtype_standardized_subclusters

# MN_obj

missing <- base::setdiff(top_mn_genes$gene,
                         rownames(MN_obj@assays$SCT@scale.data))

MN_obj <- GetResidual(object = MN_obj, 
                         features = top_mn_genes$gene, 
                         assay = "SCT", 
                         na.rm = FALSE)

MN_obj[["SCT"]]
```

```{r fig.height=10, fig.width=15}
DefaultAssay(MN_obj) <- "RNA"
#Warning: The following features were omitted as they were not found in the scale.data slot for the RNA assay: HSP90AA1
DoHeatmap(MN_obj, 
          features = top_mn_genes$gene)
```

GroupCorrelationPlot(
  object,
  assay = NULL,
  feature.group = "feature.grp",
  cor = "nCount_RNA_cor"
)



# Seurat Transfer Labels 

NOTE: not used! 

https://github.com/satijalab/seurat/issues/6675
https://github.com/satijalab/seurat/issues/6054

IntegrateLayers was completed on the SCT assay! So what do I do with 13 models??

BuildClusterTree
Constructs a phylogenetic tree relating the 'average' cell from each identity class. Tree is estimated based on a distance matrix constructed in either gene expression space or PCA space.

### Prepare Cell Ref Object 

```{r eval=FALSE}
cell_ref_obj <-  readRDS("results/integrated_ref/embryonic_adult_spinal_cord_motor_cortex_integrated_normalized_dimred_ipsc_obj_v4.RDS")
```

```{r eval=FALSE}
cell_ref_obj <- LogNormalize(cell_ref_obj)

# Add unsupervised nearest neighbors graphs 
cell_ref_obj <- FindNeighbors(cell_ref_obj, 
                              reduction = "scanvi", 
                              dims = 1:30, 
                              # return.neighbor=TRUE,
                              compute.SNN = TRUE,
                              graph.name = c("scanvi_nn","scanvi_snn"))

cell_ref_obj <- FindNeighbors(cell_ref_obj, 
                          return.neighbor = TRUE,
                          reduction = "scanvi", 
                          dims = 1:30)

Neighbors(cell_ref_obj)
Graphs(cell_ref_obj)
```

```{r}
# Add unsupervised clusters and compare to subtypes 
cell_ref_obj <- FindClusters(cell_ref_obj, 
                             resolution = c(0.5,1,2), 
                             graph.name = "scanvi_snn", 
                             group.singletons = FALSE,
                             verbose = TRUE)

plots <- DimPlot(cell_ref_obj, 
                 reduction = "umap.scanvi",
                 group.by = c("donor", "subtype_standardized","scanvi_snn_res.0.5"), 
                 combine = FALSE)

lapply(plots, function(p) p + 
         scale_color_manual(values = colors_vector) + 
         theme(legend.position = "top"))
```

```{r eval=FALSE}
#Found 13 SCT models. Recorrecting SCT counts using minimum median counts: 2408
# PrepSCTFindMarkers does not change the 13 individual models
cell_ref_obj <- PrepSCTFindMarkers(cell_ref_obj)
cell_ref_obj[["SCT"]]
cell_ref_obj[["RNA"]] # has 1 integrated layer in RNA assay only

cell_ref_split <- SplitObject(cell_ref_obj, split.by = "donor")
# cell_ref_split

# https://github.com/satijalab/seurat/issues/6064
features <- SelectIntegrationFeatures(object.list = cell_ref_split, 
                                      nfeatures = 3000)
cell_ref_split <- PrepSCTIntegration(object.list = cell_ref_split, 
                                         anchor.features = features)
ref_anchors <- FindIntegrationAnchors(object.list = cell_ref_split, 
                                         normalization.method = "SCT",
                                         anchor.features = features)
integrated_ref_obj <- IntegrateData(anchorset = ref_anchors, 
                                    normalization.method = "SCT")
```

normalization.method	
Name of normalization method used: LogNormalize or SCT.

reference.assay	--> use scanvi normalized (denoised) counts
Name of the Assay to use from reference
probably only 5k genes though 

query.assay --> SCT	
Name of the Assay to use from query

```{r}
table(rownames(ipsc_obj) %in% rownames(cell_ref_obj))
# rownames(ipsc_obj)[!rownames(ipsc_obj) %in% rownames(cell_ref_obj)]
table(rownames(cell_ref_obj) %in% rownames(ipsc_obj))
```


```{r}
anchors <- FindTransferAnchors(reference = cell_ref_obj, 
                                  query = ipsc_obj,
                                  k.anchor = 20,
                                  reduction = "pcaproject",
                                  normalization.method = "SCT", 
                                  query.assay = "SCT",
                                  reference.assay = "SCT",
                               
                                  reference.neighbors = "RNA.nn",
                                  reference.reduction = "scanvi",
                                  dims = 1:30)
```

```{r}
ipsc_obj <- MapQuery(
  anchorset = anchors_24,
  query = ipsc_obj,
  reference = ref_24hr,
  refdata = list(
    cell_type_sub = "cell_type_sub",
    cell_type_broad = "cell_type_broad",
    ),
  new.reduction.name = "integrated",
  reference.reduction = "pca", 
  reduction.model = "umap"
)
```

```{r fig.height=15, fig.width=15}
mapped_cell_ids_plot <- DimPlot(ipsc_obj_test, 
                           reduction = "ref.umap",
                           group.by = "predicted.cell_type_broad",
                           cols=ggpubr::get_palette("rickandmorty", 69),
                           label = TRUE,
                           label.size = 6,
                           repel = TRUE) + 
  NoLegend() + 
  ggtitle("DMD transferred labels")


# pdf("figures/soupX_corrected/mapped_cell_identitites_UMAP.pdf", height = 15, width = 15)
mapped_cell_ids_plot
# dev.off()
```


# Session Info

```{r}
session_info()
```






