---
title: "iPSC Motor Neurons Time-series Data: Trajectory Analysis"
author: "Jenny L Smith"
date: "`R Sys.Date()`"
output: html_document
---

# Set-up 

```{r set-up, echo=FALSE}
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
knitr::opts_chunk$set(tidy.opts=list(width.cutoff=80),
                      tidy=TRUE,
                      fig.align='center',
                      fig.width = 10, fig.height = 10,
                      eval = TRUE)

options(stringsAsFactors = FALSE, max.print = 100)
options(Seurat.object.assay.version = 'v5')
table = function (..., useNA = 'ifany') base::table(..., useNA = useNA)
getwd()
```

```{bash eval=FALSE}
# This chunk describes how to install petsc for faster implementation of cellrank 
cd /home/jsmi26/local_repos/RSC/

# PETSC
git clone https://gitlab.com/petsc/petsc.git petsc
./configure --prefix=/home/jsmi26/opt --with-fortran-bindings=0
#xxx=======================================================================================xxx
# Configure stage complete. Now build PETSc libraries with:
#   make PETSC_DIR=/home/jsmi26/local_repos/RSC/petsc PETSC_ARCH=arch-linux-c-debug all
#xxx=======================================================================================xxx
make PETSC_DIR=/home/jsmi26/local_repos/RSC/petsc PETSC_ARCH=arch-linux-c-debug install
make PETSC_DIR=/home/jsmi26/opt PETSC_ARCH="" check
#C/C++ example src/snes/tutorials/ex19 run successfully with 1 MPI process
#C/C++ example src/snes/tutorials/ex19 run successfully with 2 MPI processes

# SLEPC 
git clone https://gitlab.com/slepc/slepc
SLEPC_DIR=/home/jsmi26/local_repos/RSC/slepc PETSC_DIR=/home/jsmi26/local_repos/RSC/petsc PETSC_ARCH=arch-linux-c-debug ./configure --prefix=/home/jsmi26/opt --with-slepc4py=1 --have-petsc4py=1  --with-fortran-bindings-inplace=0
make SLEPC_DIR=/home/jsmi26/local_repos/RSC/slepc PETSC_DIR=/home/jsmi26/local_repos/RSC/petsc PETSC_ARCH=arch-linux-c-debug
make SLEPC_DIR=/home/jsmi26/local_repos/RSC/slepc PETSC_DIR=/home/jsmi26/local_repos/RSC/petsc install
writing manifest file 'src/slepc4py.egg-info/SOURCES.txt'

# Install in the virtual env that was created earlier 
cd mack_d_2023.04.13_ipsc_neuromuscular_scrnaseq
source .venv/bin/activate
PETSC_DIR=/home/jsmi26/opt python3 -m pip install --verbose /home/jsmi26/local_repos/RSC/petsc/src/binding/petsc4py
#Successfully built petsc4py
#Installing collected packages: petsc4py
#Successfully installed petsc4py-3.21.0.dev0
PETSC_DIR=/home/jsmi26/opt SLEPC_DIR=/home/jsmi26/opt python3 -m pip install --verbose /home/jsmi26/local_repos/RSC/slepc/src/binding/slepc4py
#Successfully built slepc4py
#Installing collected packages: slepc4py
#Successfully installed slepc4py-3.21.0.dev0
```

```{r message=FALSE,warning=FALSE}
library(dplyr)
library(tidyr)
library(magrittr)
library(stringr)
library(tibble)
library(glue)

library(ggplot2)
library(plotly)
library(RColorBrewer)

library(Seurat)
library(reticulate)
library(anndata)

reticulate::use_virtualenv(virtualenv = file.path(getwd(),".venv"))
sc <- reticulate::import("scanpy", convert = FALSE)
cr <- import("cellrank", convert = FALSE)
mt <- import("moscot", convert = FALSE)

conflicted::conflict_prefer("select", "dplyr")
conflicted::conflict_prefer("filter","dplyr")
conflicted::conflict_prefer("saveRDS","base")
```


# Define Functions

```{r}
colors_vector <- c(RColorBrewer::brewer.pal(12, "Paired"), 
            "blue1", "darkslategray3", "burlywood3", "#984EA3",
            "seagreen1", "yellow2", "orchid", "darkblue", 
            "lightsalmon2","slateblue1","lightskyblue4",
            "azure2", "chartreuse1",  "lemonchiffon2",
            "deeppink", "darkslategray1", "green4", "navajowhite", 
            "brown4", "darkgoldenrod2", "deepskyblue1", "lightpink") %>% 
  # c(., ggpubr::get_palette("jco", 5)) %>% 
  c("mediumpurple4","magenta", "peru") %>% 
  c(ggsci::pal_igv()(51))

length(colors_vector) 

sample_id_colors <- c("black",colors_vector[1:18])
```

```{r}
make_3D_umap <- function(metadata, idents_column, label_cols, selected_colors=NULL){
    "
    idents_column is for labeling. ex) 'RNA_snn_res.0.7 as well as the UMAP colnames, eg UMAP_1, UMAP_2'
    "
    # 3D UMAP
    plot.data <- metadata
    plot.data$label <- paste(rownames(plot.data))

    plot.data  <- plot.data %>% 
          unite(col = label, all_of(c("label",label_cols)), sep = "\n", remove = FALSE) %>% 
          select(all_of(c("label",label_cols)), all_of(idents_column))

    
    if(is.null(selected_colors)){
      selected_colors <- c("lightseagreen", "gray50",  "darkgreen", "red4", "red", "turquoise4","black","yellow4","royalblue1","lightcyan3",
                 "peachpuff3","lightskyblue","gray20","orange2","royalblue4","yellow3","gray80","darkorchid1","lawngreen","plum2", 
                 "darkorange4","darkmagenta","mediumorchid1","lightslateblue","midnightblue", "tan2") #26
    }

    cnames <- colnames(plot.data)
    formulas <- sapply(1:3, function(x) as.formula(paste0("~", grep(glue("_{x}$"), cnames, value = TRUE))))
    fig <- plot_ly(data = plot.data, 
        x = formulas[[1]], y = formulas[[2]], z = formulas[[3]], 
        color = as.formula(paste0("~", label_cols[1])), 
        colors = selected_colors, 
        type = "scatter3d", 
        mode = "markers", 
        marker = list(size = 1, width=2), # controls size of points
        text=~label, # This is that extra column we made earlier for which we will use for cell ID
        hoverinfo="text") #When you visualize your plotly object, hovering your mouse pointer over a point shows cell names

    return(fig)
}
```

```{r}
custom_dimplot <- function(metadata, colorby, dimred_colnames, custom_colors,
                           lab_size = 6, ny = 0, custom_lab_fill = NULL,
                           label_samples = TRUE,
                           color_text_grp = FALSE,
                           add_text = TRUE, 
                           seed = 2023){
  
  # define x and y column names
  x_names <- paste0(dimred_colnames, "_1")
  y_names <- paste0(dimred_colnames, "_2")
  
  # define labels positions
  labs_df <- metadata %>%
    select(all_of(c(colorby, x_names, y_names))) %>%
    group_by(!! as.name(colorby)) %>% 
    summarise(x = mean(!! as.name(x_names)),
              y = mean(!! as.name(y_names)))
  
   # define point sizes based on how many total cells in data
   ncells <- nrow(metadata)
   pt_size <- case_when(
     ncells < 5e4 ~ 1,
     ncells >= 5e4 & ncells < 1e5 ~ 0.5,
     ncells >= 1e5 ~ 0.25)
   
   # Make the scatterplot
   plot <- ggplot(metadata, 
         aes_string(x = x_names, y = y_names)) +
    geom_point(aes_string(color = colorby),
               size = pt_size, alpha = 0.4) +
    scale_color_manual(values = custom_colors) +
    guides(color = guide_legend(override.aes = list(alpha = 1, size = 2))) +
    theme_classic() +
    theme(legend.position = "top")
   
   # customize label positions
   if(is.character(ny)){
     y_val <-  ifelse(grepl(ny, labs_df[[colorby]]), 1.5, 0)
   }else{
     y_val <- ny
   }
   
   if(is.null(custom_lab_fill)){
     fill_val <-  "white"
   }else{
     fill_val <- custom_lab_fill
   }
   
   if(color_text_grp){
     mapping <- aes_string(x = "x", y = "y", label = colorby, color = colorby)

   }else{
     mapping <- aes_string(x = "x", y = "y", label = colorby)
   }
  
   if( all(add_text & label_samples) ){
     plot <- plot + 
           ggrepel::geom_text_repel(data = labs_df, 
                             mapping = aes_string(x = "x", y = "y", label = colorby),
                             color = "black",
                             nudge_y = y_val,
                             segment.colour = NA,
                             size = lab_size,
                             seed = seed)
   }else if ( label_samples ) {
      plot <- plot + 
         ggrepel::geom_label_repel(data = labs_df, 
                           mapping = mapping,
                           fill = fill_val,
                           nudge_y = y_val,
                           segment.colour = NA,
                           label.size = 0.5,
                           size = lab_size,
                           show.legend = FALSE,
                           seed = seed)
   }
   
   return(plot)
}
```

```{r}
custom_heatmaps <- function(seurat_obj, genes,columns = NULL, annot_colors = NULL, celltype="ALL"){
  
  if(celltype == "ALL"){
    cell_ids <- colnames(seurat_obj)
  }else{
    cell_ids <- CellsByIdentities(seurat_obj, idents = celltype) %>%  unlist()
  }
  
  print(c("The assay is", DefaultAssay(seurat_obj)))
  genes <- intersect(genes,rownames(seurat_obj))
  seurat_obj <- ScaleData(seurat_obj, features = genes)
  
  print("Extracting expression data")
  norm_counts <- LayerData(seurat_obj[[DefaultAssay(seurat_obj)]], 
                           layer = 'scale.data', 
                           features = genes, 
                           cells = cell_ids)
  
  col_annots <- seurat_obj@meta.data %>% 
    select(-all_of("barcode")) %>% 
    rownames_to_column("barcode") %>% 
    filter(barcode %in% colnames(norm_counts)) %>% 
    as.data.frame() %>%
    set_rownames(.$barcode) %>%
    select(all_of(columns))
  
  # row_annots <- temp %>% 
  #   set_rownames(.$coords) %>% 
  #   select(gene_name, p_val, p_val_adj) 
  
  x <- nrow(norm_counts)
  fontsize_rows <- case_when(
    x < 50 ~ 10,
    x >= 50 & x < 100 ~ 8, 
    x >= 100 & x < 200 ~ 6, 
    x >= 200 ~ 4)


  len <- 299
  colors <- colorRampPalette(viridis::viridis(10))(len)
  colors_list <- lapply(columns, function(x){
          grps <- unique(pull(col_annots, all_of(x)))
          n <- length(grps)
          colors <- annot_colors[1:n] %>% 
            set_names(grps)
          return(colors)
    })
  names(colors_list) <- columns
  

  pheatmap::pheatmap(mat=as.matrix(norm_counts), 
                     scale = "none", 
                     color = colors,
                     fontsize_row = fontsize_rows,
                     # main = glue::glue("{celltype}: DA Peaks p<0.05 & FC >= {th}"),
                     annotation_col = col_annots,
                     annotation_colors = colors_list,
                     # annotation_row = row_annots[,-1],
                     labels_row = rownames(norm_counts),
                     clustering_method = 'ward.D2',
                     show_colnames = FALSE)
}
```



# Parallelization 

```{r eval=FALSE}
library(future)
# check the current active plan
plan()
plan("multisession", workers = 16)
plan()
options(future.globals.maxSize = 60000 * 1024^2)
```

# Genome Refs

```{r eval=FALSE}
suppressPackageStartupMessages(library(ensembldb))

# db <- ensDbFromGtf("resources/genome/Homo_sapiens.GRCh38.109.chr.gtf.gz")

#Warning: Could not determine length for all seqnames
db <- ensDbFromGtf(gtf = "/gpfs/shared_data/10X/cellranger-7.0.0/refdata-gex-GRCh38-2020-A/genes/genes.gtf", 
                   genomeVersion = "GRCh38",
                   organism = "Homo_sapiens",
                   version = 98)
```

```{r, eval=FALSE}
edb <- ensembldb::EnsDb("resources/genome/Homo_sapiens.GRCh38.98.sqlite")

# edb

gids <- ensembldb::keys(edb, keytype = "GENEID")
idmap <- AnnotationDbi::select(edb, keytype="GENEID", 
                      keys = gids, 
                      columns = c("GENEID","GENEBIOTYPE","GENENAME","SYMBOL")) %>% 
  janitor::clean_names()

# head(idmap)
# dim(idmap) #36601
```

```{r}
changho_refs_file <- "references/changho_updated_marker_genes_MN_IN_annotation.xlsx"
marker_genes_chun <- purrr::map_dfr(openxlsx::getSheetNames(changho_refs_file)[2:4], function(x){
  openxlsx::read.xlsx(changho_refs_file, sheet = x)
}) %>% 
  janitor::clean_names() %>% 
  distinct() %>% 
  mutate(group=paste(author, tolower(neural_pop)) %>% 
           gsub("\\s","_",.)) %>% 
  mutate(specific_markers_for_each_type_of_neuron=gsub("\\s","", specific_markers_for_each_type_of_neuron))

# marker_genes_chun
marker_genes_chun_list <- purrr::map(unique(marker_genes_chun$group), function(x){
  marker_genes_chun %>%
    filter(group == x) %>%
    pull(specific_markers_for_each_type_of_neuron)
}) %>% 
  set_names(unique(marker_genes_chun$group))
marker_genes_chun_list[["pan_neuronal_markers"]] <- str_split(marker_genes_chun[1,"pan_neuronal_markers"], pattern = ", ", n=3)[[1]]

# marker_genes_chun_list
```

```{r}
marker_genes_endoderm <- c("CXCR4", "HDE1", "HDE2", "SOX17", "KLF8", "MYCT1", "DKK4",
                           "CLDN6","KRT19","EOMES", "FABP1", "FABP2","GATA4","GSC",
                           "KRT12","FOXA1","FOXA2","TGFB1","SOX7","SOX17", "HNF1B")

length(marker_genes_endoderm)
```

```{r}
# https://github.com/regan-hamel/h-iPSCs-MNI/blob/master/R%20workflow_iMNs_LThiry_2020.Rmd
marker_genes_iPSC <- list(MNPCs = c("CHAT", "ISL1", "ISL2", "MNX1", "OLIG2", "NEUROG2"),
                INs = c("PAX3", "VSX2", "GATA3", "SOX14", "SIM1", "LBX1", "TLX3"),
                NPCs = c("SOX1", "SOX2", "MKI67"),
                Glial = c("SOX9", "S100B", "GFAP"),
                Oligodendrocytes = c("PDGFRA", "GALC"),
                iPSCs = c("NANOG", "POU5F1"))
```

```{r warning=FALSE}
rayon_marker_genes <- openxlsx::read.xlsx(xlsxFile = "resources/cell_refs/Rayon_2021/TableS2.xlsx") %>% 
  janitor::clean_names() %>% 
  mutate(id = paste("rayon", type, neural_pop, sep="_") %>% 
           gsub("\\s", "_", .)) %>% 
  mutate(description = case_when(
    grepl("FP", id) ~ gsub("FP","floor plate", id),
    grepl("RP", id) ~ gsub("RP","roof plate", id),
    grepl("dp", id) ~ gsub("dp[0-9]", "dorsal interneuron progenitors", id),
    grepl("p[0-2]", id) ~ gsub("p[0-2]", "intermediate interneuron progenitors", id),
    grepl("p3", id) ~ gsub("p3","ventral interneuron progenitors p3", id), 
    grepl("V[0-3]", id) ~ gsub("V[0-9].?", "ventral neurons", id),
    grepl("MN", id) ~ gsub(".?MN","motor neuron", id),
    grepl("dl[0-6]", id) ~ gsub("dl[0-9]", "dorsal Interneuron", id),
    grepl("LTMR|LMTR", id) ~ gsub("C?-{0,1}(LTMR|LMTR).{0,}", "mechanoreceptor", id),
    grepl("Proprioceptor|nociceptor", id) ~ gsub("Peripheral","PNS Peripheral",id),
    grepl("Mesoderm|Eryt|Blood|Hema|Myoblast|Oligo", id) ~ paste("rayon",str_split_fixed(id, "_", n=3)[,2]),
    TRUE ~ id
  ) %>% gsub("_"," ", .) %>% gsub("rayon ","", .))


# View(rayon_marker_genes)
# head(rayon_marker_genes)

rayon_marker_genes_long <- rayon_marker_genes %>% 
  separate(genes_map_step1, into = paste0("gene",1:5), sep=", ") %>% 
  separate(genes_map_step2, into = paste0("gene",5:20), sep = ", ") %>% 
  pivot_longer(cols = matches("^gene"),
               names_to = "colname",
               values_to = "genes") %>% 
  filter(!is.na(genes)) 

# rayon_marker_genes_long

rayon_marker_gene_list <-  purrr::map(unique(rayon_marker_genes_long$id), function(x){
  rayon_marker_genes_long %>% 
    filter(id == x) %>% 
    pull(genes) %>% 
    unique()
})
names(rayon_marker_gene_list) <- unique(rayon_marker_genes_long$id)
# rayon_marker_gene_list
```

```{r}
rayon_degs <- openxlsx::read.xlsx("resources/cell_refs/Yadav_2023/1-s2.0-S0896627323000314-mmc5.xlsx", sheet = 1, check.names = FALSE, sep.names = " ") %>% 
  pivot_longer(cols = everything(),
               names_to = "subtype_annotation", 
               values_to = "degs") %>% 
  mutate(names = gsub("-[0-9]{1,2}$","", subtype_annotation) %>% 
           gsub(".+\\s(.+)$", "\\1", .) %>% 
           gsub("\\/|-","_", .))

esc_celltypes <- unique(rayon_degs$names)
rayon_deg_gene_list <-  purrr::map(esc_celltypes, function(x){
  rayon_degs %>%
    filter(names == x) %>%
    pull(degs) %>%
    unique()
})
names(rayon_deg_gene_list) <- esc_celltypes
```

```{r}
mn_subtype_markers <- openxlsx::read.xlsx("references/11122023_Alpha_Gamma_MNs_consolidated marker list.xlsx", sheet = 2)
head(mn_subtype_markers)
# table(mn_subtype_markers$celltype)
```

# Read in iPSC Object

```{r}
current_path <- file.path("results/day0_day50/seurat")
current_obj <- "iPSC_motor_neuron_day0-day50_time-course_filtered_merged_soupX_normalized_dimred_anno_seurat_obj_v5.RDS" 
  # "iPSC_MN_time-course_filtered_merged_soupX_normalized_RPCAIntegration_seurat_obj_v5.RDS"
  # "iPSC_motor_neuron_day0-day50_time-course_filtered_merged_soupX_normalized_dimred_anno_seurat_obj_v5.RDS" #v5 Seurat Object

ipsc_obj <- readRDS(file.path(current_path, current_obj))

ipsc_obj
```

```{r}
gene_annots <- ipsc_obj@assays$RNA@meta.data

sct_gene_annots <- ipsc_obj[["SCT"]]@meta.features %>% 
  rownames_to_column("gene_name_fix") %>% 
  left_join(., gene_annots, 
            by = "gene_name_fix") %>% 
  mutate(variable_gene = gene_name_fix %in% VariableFeatures(ipsc_obj)) %>% 
  group_by(gene_name) %>% 
  mutate(gene_name_clean = case_when(
    n() == 1 ~ gene_name,
    TRUE ~ gene_name_fix
  )) %>% 
  ungroup() %>% 
  as.data.frame() %>% 
  set_rownames(.$gene_name_fix)

# sct_gene_annots
# table(duplicated(sct_gene_annots$gene_name_fix)) # FALSE
# identical(rownames(ipsc_obj[["SCT"]]), rownames(sct_gene_annots)) #TRUE

# Add the gene ID metadata to SCT assay
ipsc_obj[["SCT"]] <- AddMetaData(ipsc_obj[["SCT"]], metadata = sct_gene_annots)

# Create a new assay just with the cleaned/de-duped gene names
sct_data <- LayerData(ipsc_obj, assay = "SCT", layer = "data")
rownames(sct_data) <- sct_gene_annots$gene_name_clean
ipsc_obj[["SCT_renamed"]] <- CreateAssay5Object(data = sct_data)
hvgs <- sct_gene_annots %>% 
  filter(variable_gene) %>% 
  pull(gene_name_clean)

VariableFeatures(ipsc_obj, assay = "SCT_renamed") <- hvgs
```


## Visualization 

```{r}
table(ipsc_obj$subtype_standardized)
```

```{r fig.height=10, fig.width=10}
custom_dimplot(metadata = ipsc_obj@meta.data, 
               colorby = "batch", 
               dimred_colnames = "umaprpca", 
               custom_colors = ggpubr::get_palette("jco", 4))

custom_dimplot(metadata = ipsc_obj@meta.data, 
               colorby = "subtype_standardized", 
               dimred_colnames = "umaprpca", 
               custom_colors = ggpubr::get_palette("npg", 7))

# custom_dimplot(metadata = ipsc_obj@meta.data, 
#                colorby = "rpca_snn_res0.6", 
#                dimred_colnames = "umaprpca", 
#                custom_colors = ggpubr::get_palette("simpsons", length(unique( ipsc_obj@meta.data$rpca_snn_res0.6))))

```

```{r fig.height=10, fig.width=10}
# ipsc_obj$time_point %>% head()
# ipsc_obj$time_point_factor %>% head()

ggplot(ipsc_obj@meta.data, aes(x = umaprpca_1, y = umaprpca_2)) +
  geom_point(aes(color = time_point), alpha = 0.5, size = 0.1) +
  scale_color_viridis_c() +
  theme_bw()
```

# Trajectories

Review article:
https://www.nature.com/articles/s41576-021-00444-7

Selecting which time-points to include:
However, there are cases where the dynamics of the process being studied is unknown or when assumptions are based on the phenotypic behaviour, which may not reflect the underlying molecular dynamics that are being profiled by scRNA-seq71. To address this, Kleyman et al. developed the time point selection (TPS) method71 (Fig. 2). TPS was originally developed and applied to bulk RNA-seq but can also be used for scRNA-seq. It works by initially oversampling bulk-level RNA-seq using cheap array methods. Next, spline curves are used to fit the profiled data, which enables the method to predict values for unobserved time points. A heuristic optimization function is then used to select the most informative time points, those points that if sampled provide enough information to reconstruct the entire expression trajectory for all genes


OK - slingshot
   - Monocle3
   - CellRank / Moscot
No
- PRESCIENT (8 citations, not maintained in 3 yrs)
- psupertime (not maintained in 4yrs, only 11 citations)
- dyno (not maintained in 4yrs)
- CSHMM (not maintained in 7 years, 151 citations)
https://github.com/gifford-lab/prescient
https://github.com/dynverse/dyno

## Monocle3

```{r}
suppressPackageStartupMessages(library(monocle3))
suppressPackageStartupMessages(library(SeuratWrappers))
```

```{r}
# Warning: gene_metadata must contain a column verbatim named 'gene_short_name' for certain functions.
cds <- new_cell_data_set(expression_data = ipsc_obj@assays$SCT$counts,
                         cell_metadata = ipsc_obj@meta.data)
logcounts(cds) <- ipsc_obj@assays$SCT$data

reducedDims(cds) <- list(PCA=ipsc_obj@reductions$pca@cell.embeddings,
                         Harmony=ipsc_obj@reductions$rpca@cell.embeddings,
                         UMAP=ipsc_obj@reductions$umap.rpca@cell.embeddings)

cds
```

```{r}
# use the harmony UMAP (renamed to simply UMAP for compatibility) to identify unsupervised clusters
# defines the 'partitions' found in the cell clustering 
cds <- cluster_cells(cds, 
                     reduction_method = "UMAP",
                     cluster_method = "leiden",
                     k = 20)

cds
```

```{r fig.height=10}
p1 <- plot_cells(cds, 
                 show_trajectory_graph = FALSE)

p2 <- plot_cells(cds, 
                 color_cells_by = "partition", 
                 show_trajectory_graph = FALSE)

p3 <- plot_cells(cds, 
                 color_cells_by = "orig.ident", 
                 show_trajectory_graph = FALSE)

p1
p2
p3
```

```{r}
# Identifying the program of gene expression changes is equivalent to learning a trajectory that the cells follow through this space.
cds <- learn_graph(cds, 
                   use_partition = FALSE,
                   verbose = TRUE)
```

```{r eval=FALSE}
DimPlot(subset(ipsc_obj, subset = orig.ident == "iPSC_ipsc"),
        reduction = "umap.rpca",
        group.by = "rpca_clusters")
```

```{r fig.height=10, fig.width=10}
plot_cells(cds, label_principal_points = TRUE)
```

If `root_cells` is set as NULL, then its based on manual selection of the root cells.
However, there are methods available like time point selection (TPS) that might be able to refine the root cells, rather than use all time0 cells.

```{r}
#Assigns cells a pseudotime value based on their projection on the principal graph
time0 <- WhichCells(ipsc_obj, expression = orig.ident == "iPSC_ipsc")
cds <- order_cells(cds, 
                   reduction_method = "UMAP", 
                   root_cells = time0, 
                   verbose = TRUE)

# cds
```

```{r fig.height=10, fig.width=10}
plot_cells(cds, 
           label_groups_by_cluster = FALSE,
           label_leaves = FALSE, 
           label_branch_points = FALSE)
```

```{r fig.height=10, fig.width=10}
plot_cells(cds, 
           color_cells_by = "pseudotime",
           label_groups_by_cluster = FALSE,
           label_leaves = FALSE, 
           label_branch_points = FALSE)
```


## Slingshot

https://bioconductor.org/packages/release/bioc/html/slingshot.html

Provides functions for inferring continuous, branching lineage structures in low-dimensional data. Slingshot was designed to model developmental trajectories in single-cell RNA sequencing data and serve as a component in an analysis pipeline after dimensionality reduction and clustering. It is flexible enough to handle arbitrarily many branching events and allows for the incorporation of prior knowledge through supervised graph construction.

```{r}
library(slingshot)
```

cds <- new_cell_data_set(expression_data = ipsc_obj@assays$SCT$counts,
                         cell_metadata = ipsc_obj@meta.data)
logcounts(cds) <- ipsc_obj@assays$SCT$data

reducedDims(cds) <- list(PCA=ipsc_obj@reductions$pca@cell.embeddings,
                         Harmony=ipsc_obj@reductions$harmony@cell.embeddings,
                         UMAP=ipsc_obj@reductions$umap_harmony_subset@cell.embeddings)

two-step process composed of identifying the global lineage structure with a cluster-based minimum spanning tree (MST) and fitting simultaneous principal curves to describe each lineage.

```{r}
sce <- Seurat::as.SingleCellExperiment(ipsc_obj, assay = "SCT")

sce
```

potential labels
1) subtype (N=7)
2) unsupervised clusters (N=22)
3) subtype + unsupervised clusters

```{r}
sce$subtype_standardized_subclusters %>% table()
reducedDims(sce)
head(reducedDim(sce, "UMAP.RPCA"))
```

All of the results are stored in a PseudotimeOrdering object, which is added to the colData of the original object and can be accessed via colData(sce)$slingshot

to extact all slingshot objects/results 
  * as.SlingshotDataSet (class SlingshotDataSet) 
  * as.PseudotimeOrdering (classSummarizedExperiment)


omega
This value is provided as a potentially useful rule of thumb for datasets with outlying clusters or multiple, distinct trajectories. 
-  In practice, this makes omega the maximum allowable distance between two connected clusters.
- omega_scale, default = 3

approx_points
 - sets the number of points to be used for each curve, can have a large effect on computation time.
 - set the default value to 150 whenever the input dataset contains more than that many cells. 

lineages without defined start cluster
- If we do not specify a starting point, slingshot selects one based on parsimony, maximizing the number of clusters shared between lineages before a split.

 recommend the **specification of an initial cluster based on prior knowledge**
  - either time of sample collection or established gene markers
  - This specification will have no effect on how the MST is constructed, but it will impact how branching curves are constructed.
  - clusters as **terminal** states will be constrained to have only one connection when the MST 
  

The fundamental assumption of slingshot is that cells which are transcriptionally similar will be close to each other in some reduced-dimensional space. Since we use Euclidean distances in constructing lineages and measuring pseudotime, it is important to have a low-dimensional representation of the data.

```{r}
sce$subtype_standardized_subclusters %>% 
  unique() %>% 
  grep("progenitor", ., value=TRUE)
```


```{r}
# or use the full RPCA dimensions - the authors show using just 1 or 2 dims? 
sce <- slingshot(sce, 
                 clusterLabels = 'subtype_standardized_subclusters',
                 reducedDim = 'UMAP.RPCA', 
                 time = sce$time_point,
                 start.clus = NULL,
                 end.clus = NULL,
                 dist.method = "slingshot",
                 use.median = FALSE, # FALSE is default
                 omega = FALSE,
                 omega_scale = 1.5,
                 reassign = TRUE, 
                 allow.breaks = TRUE, # TRUE is default
                 reweight = TRUE # TRUE is default
                 ) 
```



```{r}
# checkout the coldata pseudotime (?) values
colData(sce)$slingshot

# convert to Slingshot Dataset
slingshot_data <- SlingshotDataSet(sce)
# slingshot_data@lineages %>% head()
slingshot_data
```
```{r}
summary(colData(sce)$slingPseudotime_1) # lots of NAs...

colnames(colData(sce)) %>% grep("slingPseudotime_", ., value=TRUE)
```

```{r}
n_clusts <- length(unique(sce$subtype_standardized_subclusters))
colData(sce)$barcode <- rownames(colData(sce))

cc <-  colData(sce)[,c("barcode","subtype_standardized_subclusters")] %>% 
  as.data.frame() %>% 
  left_join(.,  data.frame(colors = colors_vector[1:n_clusts], 
                           subtype_standardized_subclusters = unique(sce$subtype_standardized_subclusters)), 
            by="subtype_standardized_subclusters") %>% 
  pull(colors, name = "subtype_standardized_subclusters")

head(cc)
```

```{r fig.height=10, fig.width=10}
plot(reducedDim(sce, "UMAP.RPCA"), 
     col = alpha(cc,alpha = 0.5),
     cex = 0.25,
     asp = 1, pch = 16)
lines(SlingshotDataSet(sce),
      type = 'lineages',
      lwd = 2, 
      col = 'black')
```

## TSCAN

```{r}
library(TSCAN)
```


## CellRank 

CellRank is a software toolkit to study dynamical biological processes, like development, regeneration, cancer or reprogramming, based on multi-view single-cell genomics data
 - Oftentimes, the type of downstream analysis does not depend on the modality that was used to estimate cellular transitions

https://cellrank.readthedocs.io/en/latest/notebooks/tutorials/kernels/500_real_time.html

a scRNA-seq dataset with experimental time points. Additional spatial or lineage information improves the accuracy of fate mapping, but is not required.

* a scRNA-seq dataset for which you can compute a cell-cell transition matrix using any CellRank kernel.

### Create AnnData Object 

```{r eval=FALSE}
assay_norm <- "SCT_renamed"
# variable features to be added to a anndata
var_df <- data.frame(gene_name = rownames(ipsc_obj[[assay_norm]])) %>% 
  mutate(highly_variable = gene_name %in% VariableFeatures(ipsc_obj,
                                                           assay = assay_norm), 
         var.features = gene_name %in% VariableFeatures(ipsc_obj,
                                                        assay = assay_norm)) %>%
        set_rownames(.$gene_name)

# convert to pandas dataframe class again to access the astype() function
pd <- import("pandas", convert = FALSE)
obs <- pd$DataFrame(ipsc_obj@meta.data)

# convert to sparse matrices (transpose base densifys the data)
# SeuratDisk::Transpose does not work, probably b/c its not an H5Seurat Class obj. 
scipy_sparse <- import("scipy.sparse", convert = FALSE)
norm_counts <- scipy_sparse$csr_matrix(t(as.matrix(LayerData(ipsc_obj, assay = assay_norm, layer = "data"))))
counts_mat <- t(as.matrix(LayerData(ipsc_obj, assay = 'RNA', layer = "counts")))
counts_mat <- scipy_sparse$csr_matrix(counts_mat[, rownames(ipsc_obj[[assay_norm]])])

# create an anndata object with transposed counts matrices
# dataset should be normalized by total counts and log2-transformed. - using analytic pearson residuals OK?
# Further, highly variable genes have already been annotated
ipsc_adata <- AnnData(
  X = norm_counts, 
  obs = obs,
  var = var_df,
  obsm = list("X_scANVI" = ipsc_obj@reductions$scanvi@cell.embeddings, 
               "X_rpca" = ipsc_obj@reductions$rpca@cell.embeddings,
               "X_pca" = ipsc_obj@reductions$pca@cell.embeddings,
               "X_umap" = ipsc_obj@reductions$umap.rpca@cell.embeddings
              ),
  layers = list(counts = counts_mat)
)

## anndata::AnnData() function enforces the conversion to 'dtype='object' from the original  dtype='int64' in `obs` pandas dataframe. ugh.
ipsc_adata
# uses n.neighbors = 15 by default. 
seed_val <- as.integer(20240301)

# use batch corrected embedding 
# k-NN graph, which we’ll need later on.
sc$pp$neighbors(ipsc_adata,
                use_rep = "X_rpca",
                random_state = seed_val, 
                metric = 'cosine')
ipsc_adata
rm(counts_mat)
rm(norm_counts)

anndata::write_h5ad(ipsc_adata,"results/day0_day50/cellrank/iPSC_MN_day0-day50_time-course_sct_adata.h5ad")
ipsc_adata$write_h5ad(filename = "results/day0_day50/cellrank/iPSC_MN_day0-day50_time-course_sct_adata_scanpy.h5ad")
rm(ipsc_adata)
```


### Temporal Problem 

couple cells across time points using [optimal transport](https://en.wikipedia.org/wiki/Transportation_theory_(mathematics)) (OT), as pioneered by [Waddington-OT](https://broadinstitute.github.io/wot/)
  * From the manuscript:
  * Analyzing >315,000 cells sampled densely across 18 days of reprogramming mouse embryonic fibroblasts (MEFs) into iPSCs
  * Using Waddington-OT to reconstruct the landscape of differentiation trajectories and intermediate states that give rise to these diverse fates, we describe a gradual 
  transition to either stroma-like cells or a mesenchymal-to-epithelial transition (MET) state.

https://moscot.readthedocs.io/en/latest/notebooks/examples/problems/800_score_genes_for_marginals.html
* core_genes_for_marginals() computes the marginals such that cells expressing proliferation marker genes get a higher weight as they are assumed to have multiple descendants or that certain cells are outliers in space, so they should not influence the mapping too much

NOTE:

`tp$adata$obs['day']$cat$categories` this should **not** be dtype='object'
Index(['0', '3', '5', '8', '11', '15', '18', '21', '24', '27', '30', '35',
       '40', '45', '50'],
      dtype='object')
      
```{r}
ad <- import("anndata", convert = FALSE)

# set-up the object 
ipsc_adata <- ad$read_h5ad(filename = "results/day0_day50/cellrank/iPSC_MN_day0-day50_time-course_sct_adata_scanpy.h5ad")
#"anndata._core.anndata.AnnData" "python.builtin.object"  

ipsc_adata$obs['day'] <- ipsc_adata$obs['time_point']$astype('int64')$astype('category')
# Name: day, Length: 86954, dtype: category
# Categories (15, int64): [0, 3, 5, 8, ..., 35, 40, 45, 50]

ipsc_adata$obs['day']$cat$categories
# Index([0, 3, 5, 8, 11, 15, 18, 21, 24, 27, 30, 35, 40, 45, 50], dtype='int64')
```

```{r}
# initial the temporal problem from adata 
tp <- mt$problems$TemporalProblem(ipsc_adata)

# check the object class
tp$adata$obs['day']$cat$categories
# Index([0, 3, 5, 8, 11, 15, 18, 21, 24, 27, 30, 35, 40, 45, 50], dtype='int64') # OK

# calculate marginals
tp <- tp$score_genes_for_marginals(
    gene_set_proliferation="human",
    gene_set_apoptosis="human"
)

tp$apoptosis_key
tp$proliferation_key
# WARNING: genes are not in var_names and ignored: ['FAM64A', 'HN1', 'MLF1IP']
# WARNING: genes are not in var_names and ignored: ['FASLG', 'GPX1', 'GSTM1', 'H1-0', 'IFNB1', 'IL1B', 'PRF1', 'TNF']
```

```{r fig.height=5, fig.width=25}
sc$pl$embedding(ipsc_adata, 
                basis="X_umap", 
                color=c("subtype_standardized_subclusters","proliferation", "apoptosis"))
```

```{r}
# conflicted::conflict_prefer("%>%", "dplyr")
# 
# time_cats_explicit <- list()
# vals <- unique(ipsc_obj$time_point)
# for(i in 1:14){
#   s <- as.integer(vals[i])
#   e <- as.integer(vals[i+1])
#   grp <- reticulate::tuple(s,e)
#   time_cats_explicit[[i]] <- grp
#   i <- i+1
# }

# https://moscot.readthedocs.io/en/latest/genapi/moscot.problems.time.TemporalProblem.prepare.html#moscot.problems.time.TemporalProblem.prepare
# if joint_attr not provided: PCA on X is computed.Each pairwise (for each time-point) PCA is compared to one another to build the graphs
# use local PCAs, computed separately for each pair of time points, to calulate distances among cells [Schiebinger et al., 2019]. 
tp <- tp$prepare(time_key="day",
                 # joint_attr = "X_rpca", 
                 policy='sequential') 
                 # kwargs = list("subset" = r_to_py(time_cats_explicit)))
tp
```


entropic regularization: `epsilon` 
amount of unbalancedness on the source marginal: `tau_a` c
 
Higher entropic regularization speeds up the optimization and improves statistical properties of the solution
unbalancedness makes the solution more robust with respect to uncertain cellular growth rates and biased cell sampling

```{r}
# solve one OT problem per time point pair, probabilistically matching early to late cells
# allow for adjustments of prior estimates by setting tau_a<1 and tau_b<1 as we don’t expect many cells to die in a developmental setting.
tp <- tp$solve(epsilon=1e-3, tau_a=0.95, tau_b = 0.99, scale_cost="mean")
tp

# Add the growth rates
ipsc_adata$obs["prior_growth_rates"] =  py_to_r(tp$prior_growth_rates)[["prior_growth_rates"]]

# save the temporal problem
# tp$save(path = "results/day0_day50/cellrank/temporal_problem/iPSC_MNs_day0-day50_moscot_cellrank_OT.pickle", overwrite = TRUE)
```

```{r}
sc$pl$embedding(ipsc_adata, 
                basis="X_umap",
                color="prior_growth_rates")
```


```{r eval=FALSE}
ipsc_adata$obs %>% 
  group_by(day, subtype_standardized_subclusters) %>% 
  dplyr::count() %>% 
  filter(day == 0 | day == 3) %>% 
  arrange(subtype_standardized_subclusters)

tp$sankey(source = 0L,
          target = 3L,
          source_groups = "subtype_standardized_subclusters", 
          target_groups = "subtype_standardized_subclusters", 
          forward = FALSE)
```

```{r}
# adata <- mt$datasets$hspc()
# adata
# adata$obs$day$dtype
# # CategoricalDtype(categories=[2, 3, 4, 7], ordered=False, categories_dtype=int64)
# # Name: day, Length: 4000, dtype: category
# # Categories (4, int64): [2, 3, 4, 7]
# 
# hscp_tp <- mt$problems$ (adata)$prepare(time_key="day")$solve(epsilon=1e-2, threshold=1e-2)
# 
# tp.sankey(
#     source=2,
#     target=7,
#     source_groups="cell_type",
#     target_groups="cell_type",
#     forward=True,
# )
```


### Real Time Kernal

https://cellrank.readthedocs.io/en/latest/api/_autosummary/kernels/cellrank.kernels.RealTimeKernel.html#cellrank.kernels.RealTimeKernel.from_moscot

1. sparsify OT transport maps by removing entries below a certain threshold
* entropic regularization yields dense matrices which would make CellRank analysis very slow. 
2. use OT transport maps and molecular similarity to **model transitions across and within time points**
3. row-normalize the resulting cell-cell transition matrix (including all time points) and construct the Markov chain.  

```{r eval=TRUE}
# Set up the RealTimeKernel
tmk <- cr$kernels$RealTimeKernel$from_moscot(problem =  tp,
                                             kwargs = list("time_key" = "day",
                                                           "policy"="sequential"))
# tmk
```

```{r}
# compute the transition matrix
# how to determine connection weight cutoffs?
# https://github.com/theislab/cellrank/issues/946
tmk$compute_transition_matrix(self_transitions="all", 
                              conn_weight=0.2, 
                              threshold="auto")

# tmk$compute_projection(basis="umap")

tmk
# WARNING: Coupling at `(27, 30)` contains `1` empty row(s), e.g., due to unbalancedness or 0s in the source marginals. Using uniform distribution
# WARNING: Coupling at `(30, 35)` contains `3` empty row(s), e.g., due to unbalancedness or 0s in the source marginals. Using uniform distribution
# WARNING: Coupling at `(3, 5)` contains `2` empty row(s), e.g., due to unbalancedness or 0s in the source marginals. Using uniform distribution
```

```{r eval=FALSE}
#https://cellrank.readthedocs.io/en/latest/notebooks/tutorials/general/100_getting_started.html#writing-and-reading-a-kernel
tmk$write_to_adata()
anndata::write_h5ad(anndata = ipsc_adata, filename = "results/day0_day50/cellrank/iPSC_MNs_day0-day50_moscot_cellrank_RealTimeKernel.h5ad")
```


'macrostates_fwd'
    var: 'n_cells', 'highly_variable', 'means', 'dispersions', 'dispersions_norm'
    uns: 'cell_type_colors', 'hvg', 'neighbors', 'neighbors_atac', 'pca', 'umap', 'schur_matrix_fwd', 'eigendecomposition_fwd', 'macrostates_fwd_colors', 'coarse_fwd'
    obsm: 'X_lsi', 'X_pca', 'X_umap_ATAC', 'X_umap_GEX', 'peaks_tfidf', 'schur_vectors_fwd', 'macrostates_fwd_memberships'
    varm: 'PCs'
    obsp: 'connectivities', 'distances', 'neighbors_atac_connectivities', 'neighbors_atac_distances'


 'macrostates_fwd', 'term_states_fwd', 'term_states_fwd_probs'
    var: 'gene_name', 'highly_variable', 'var.features'
    uns: 'neighbors', 'T_fwd_params', 'schur_matrix_fwd', 'eigendecomposition_fwd', 'macrostates_fwd_colors', 'coarse_fwd', 'term_states_fwd_colors'
    obsm: 'X_pca', 'X_rpca', 'X_scANVI', 'X_umap', 'schur_vectors_fwd', 'macrostates_fwd_memberships', 'term_states_fwd_memberships'
    layers: 'counts'
    obsp: 'connectivities', 'distances', 'T_fwd'
    
```{r}
# tmk$plot_projection(basis = "X_umap")
# tmk$transition_matrix
tmk$shape
tmk$time
tmk$params
tmk$kernels
cpl <- tmk$couplings
# class(cpl) #"python.builtin.dict"   "python.builtin.object"
```

```{r fig.height=15, fig.width=15}
tmk$plot_single_flow(
    cluster = "progenitor",
    cluster_key="subtype_standardized", #subtype_standardized_subclusters
    time_key="day",
    clusters=ipsc_adata$obs$subtype_standardized$values$unique(),
    figsize = c(10.0 ,10.0),
    dpi = 150,
    save = "figures/day0_day50/trajectories/iPSC_MNs_day0-day50_moscot_cellrank_single_flow_plot.pdf"
)
```

```{r fig.height=15, fig.width=15}
tmk$plot_random_walks(
    n_sims = 200L,
    max_iter = 500L,
    # successive_hits = 3L,
    start_ixs=list("day" = c(0.0)),
    basis="X_umap",
    seed = seed_val,
    linewidth=0.5, 
    linealpha=0.2,
    figsize = c(10.0 ,10.0),
    dpi = 150,
    # save = "figures/day0_day50/trajectories/iPSC_MNs_day0-day50_moscot_cellrank_random_walks.pdf"
)
```


### Identify Initial and Terminal States

CellRank decomposes cellular dynamics into macrostates: Based on Generalized Perron Cluster Cluster analysis (GPCCA), 

https://cellrank.readthedocs.io/en/latest/notebooks/tutorials/estimators/600_initial_terminal.html

```{r}
if(!exists("tmk")){
  ipsc_adata <- anndata::read_h5ad("results/day0_day50/cellrank/iPSC_MNs_day0-day50_moscot_cellrank_RealTimeKernel.h5ad")
  tmk <- cr$kernels$RealTimeKernel$from_adata(adata = ipsc_adata, key="T_fwd")
}
```

uses the GPCCA algorithm as implemented in pyGPCCA to compute macrostates by maximizing for metastability
Using the GPCCA algorithm, CellRank generates as coarse-grains a cell-cell transition matrix onto the macro-state level

This transition matrix aggregates the single-cell Markov chain to a macrostate-level Markov chain. 
Entries in this matrix tell us how likely macrostates are to transition into one-another. 

```{r}
# set-up the estimators
gpcca <- cr$estimators$GPCCA(tmk)

# fit the clusters 
# two key outputs: the soft assignment of cells to macrostates, and a matrix of transition probabilities among these macrostates
#  the algorithm to scan this interval for the optimal number of macrostates (4, 12)
# Make sure to have the scientific computing libraries PETSc and SLEPc installed (see set-up chunks above)
gpcca$fit(cluster_key="subtype_standardized",
          n_states=c(4L, 12L))

# gpcca$compute_schur(n_components=20, 
#                     verbose = TRUE)
# g2.compute_macrostates(n_states=11,
#                        cluster_key="clusters")

gpcca
```

```{r fig.height=5, fig.width=10}
# gpcca$plot_spectrum(real_only=TRUE)
```

To pull out the data from the object 
https://github.com/theislab/moscot/issues/676

```{r fig.height=5, fig.width=10}
gpcca$plot_macrostates(which="all",
                       discrete=TRUE, 
                       legend_loc="center left")
```

```{r fig.height=10, fig.width=10}
# Predict the terminal states of cells/clusters
# values reflect our confidence in assigning a cell to a terminal state
gpcca$predict_terminal_states(allow_overlap = FALSE)

gpcca$plot_macrostates(which="terminal", 
                       legend_loc="center left")
```

```{r fig.height=10, fig.width=10}
gpcca$plot_macrostates(which="terminal", discrete=FALSE)
```

```{r}
# predict the initial states of cells/clusters
gpcca$predict_initial_states(allow_overlap = TRUE) # 30 cells overlap in terminal and initial status
gpcca$plot_macrostates(which="initial",
                       legend_loc="center left")
```

Macrostates, and their classification as initial or terminal, are written to the GPCCA estimator and can be inspected conveniently via initial_states and terminal_states.
GPCCA[kernel=RealTimeKernel[n=86954], initial_states=['progenitor_2'], terminal_states=['motorneurons_2', 'motorneurons_6', 'progenitor_1', 'progenitor_2']]

```{r}
# plot muscle cell marker genes here
# ipsc_adata$obs 
# VlnPlot()
```

```{r}
gpcca$coarse_stationary_distribution
```

```{r fig.height=10, fig.width=10}
# why is this blank?
gpcca$plot_coarse_T(show_stationary_dist = TRUE, 
                    order='stability',
                    figsize=c(8L, 8L), 
                    annotate = TRUE)
```

```{r}
gpcca$plot_macrostate_composition(key="subtype_standardized_subclusters",
                                  figsize=c(7L, 4L))
```


### Cell Fate Probabilities 

```{r}
# compute fate_probabilities by aggregating over all random walks that start in a given cell and end in some terminal population
gpcca$compute_fate_probabilities()
```

```{r fig.height=10, fig.width=10}
gpcca$plot_fate_probabilities(same_plot=FALSE)
```

```{r fig.height=10, fig.width=10}
cr$pl$circular_projection(ipsc_adata, 
                          keys=c("subtype_standardized_subclusters"),
                          legend_loc="right")
```

```{r eval=FALSE}
drivers_df = gpcca$compute_lineage_drivers(
    lineages=["Delta"], 
    cluster_key="clusters",
    clusters=driver_clusters
)

head(delta_df)
```

```{r fig.height=10, fig.width=10}
mn_states <- grep("motor",ipsc_adata$obs$subtype_standardized_subclusters, value=TRUE)

sc$pl$embedding(
    ipsc_adata, 
    basis="umap",
    color="subtype_standardized_subclusters", 
    groups=mn_states, 
    legend_loc="right"
)
```

# Example Data 

```{r fig.height=10,fig.width=10}
hspc_adata = mt$datasets$hspc()
hspc_adata$obs["day"] = hspc_adata$obs["day"]$astype("category")

problem = mt$problems$TemporalProblem(hspc_adata)
problem
# problem$adata$obs['day']$cat$categories
# Index([2, 3, 4, 7], dtype='int64')

problem = problem$prepare(time_key="day", 
                          joint_attr = 'X_umap_GEX')

problem = problem$solve(epsilon=1e-3, tau_a=0.95, tau_b = 0.99, scale_cost="mean")

rtk = cr$kernels$RealTimeKernel$from_moscot(problem = problem, 
                                            kwargs = list("time_key" = "day",
                                                        "policy"="sequential"))
rtk = rtk$compute_transition_matrix(self_transitions="all", 
                              conn_weight=0.2, 
                              threshold="auto")

problem$temporal_key
rtk$couplings
rtk

# set-up the estimators
gp <- cr$estimators$GPCCA(rtk)

# fit the clusters 
gp$fit(cluster_key="cell_type",
       n_states=c(4L, 12L))

gp

gp$plot_macrostates(which="all", discrete=TRUE, legend_loc="center left")
gp$predict_initial_states() #   ValueError: Found `30` overlapping cells between initial and terminal states
gp$predict_terminal_states(allow_overlap=TRUE)

# not showing plot either 
gp$plot_coarse_T(show_stationary_dist = TRUE, order='stability', figsize=c(8L, 8L), annotate = TRUE)
```


# Session Info

```{r}
cr$logging$print_versions()
# cellrank==2.0.2 scanpy==1.9.5 anndata==0.10.5.post1 numpy==1.26.4 numba==0.59.0 scipy==1.11.4 pandas==2.1.0 pygpcca==1.0.4 scikit-learn==1.1.3 statsmodels==0.14.0 python-igraph==0.10.8 scvelo==0.3.1 pygam==0.9.1 matplotlib==3.7.1 seaborn==0.13.2
```

```{r}
sessionInfo()
```

