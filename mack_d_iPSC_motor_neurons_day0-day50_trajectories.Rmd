---
title: "iPSC Motor Neurons Time-series Data: Trajectory Analysis"
author: "Jenny L Smith"
date: "`R Sys.Date()`"
output: html_document
---

# Set-up 

```{r set-up, echo=FALSE}
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
knitr::opts_chunk$set(tidy.opts=list(width.cutoff=80),
                      tidy=TRUE,
                      fig.align='center',
                      fig.width = 10, fig.height = 10,
                      eval = TRUE)

options(stringsAsFactors = FALSE, max.print = 100)
options(Seurat.object.assay.version = 'v5')
table = function (..., useNA = 'ifany') base::table(..., useNA = useNA)
getwd()
```

```{bash eval=FALSE}
# This chunk describes how to install petsc for faster implementation of cellrank 
cd /home/jsmi26/local_repos/RSC/

# PETSC
git clone https://gitlab.com/petsc/petsc.git petsc
./configure --prefix=/home/jsmi26/opt --with-fortran-bindings=0
#xxx=======================================================================================xxx
# Configure stage complete. Now build PETSc libraries with:
#   make PETSC_DIR=/home/jsmi26/local_repos/RSC/petsc PETSC_ARCH=arch-linux-c-debug all
#xxx=======================================================================================xxx
make PETSC_DIR=/home/jsmi26/local_repos/RSC/petsc PETSC_ARCH=arch-linux-c-debug install
make PETSC_DIR=/home/jsmi26/opt PETSC_ARCH="" check
#C/C++ example src/snes/tutorials/ex19 run successfully with 1 MPI process
#C/C++ example src/snes/tutorials/ex19 run successfully with 2 MPI processes

# SLEPC 
git clone https://gitlab.com/slepc/slepc
SLEPC_DIR=/home/jsmi26/local_repos/RSC/slepc PETSC_DIR=/home/jsmi26/local_repos/RSC/petsc PETSC_ARCH=arch-linux-c-debug ./configure --prefix=/home/jsmi26/opt --with-slepc4py=1 --have-petsc4py=1  --with-fortran-bindings-inplace=0
make SLEPC_DIR=/home/jsmi26/local_repos/RSC/slepc PETSC_DIR=/home/jsmi26/local_repos/RSC/petsc PETSC_ARCH=arch-linux-c-debug
make SLEPC_DIR=/home/jsmi26/local_repos/RSC/slepc PETSC_DIR=/home/jsmi26/local_repos/RSC/petsc install
writing manifest file 'src/slepc4py.egg-info/SOURCES.txt'

# Install in the virtual env that was created earlier 
cd mack_d_2023.04.13_ipsc_neuromuscular_scrnaseq
source .venv/bin/activate
PETSC_DIR=/home/jsmi26/opt python3 -m pip install --verbose /home/jsmi26/local_repos/RSC/petsc/src/binding/petsc4py
#Successfully built petsc4py
#Installing collected packages: petsc4py
#Successfully installed petsc4py-3.21.0.dev0
PETSC_DIR=/home/jsmi26/opt SLEPC_DIR=/home/jsmi26/opt python3 -m pip install --verbose /home/jsmi26/local_repos/RSC/slepc/src/binding/slepc4py
#Successfully built slepc4py
#Installing collected packages: slepc4py
#Successfully installed slepc4py-3.21.0.dev0
```

```{r message=FALSE,warning=FALSE}
library(dplyr)
library(tidyr)
library(magrittr)
library(stringr)
library(tibble)
library(glue)

library(ggplot2)
library(plotly)
library(RColorBrewer)

library(Seurat)
library(reticulate)
library(anndata)

reticulate::use_virtualenv(virtualenv = file.path(getwd(),".venv"))
sc <- reticulate::import("scanpy", convert = FALSE)
cr <- import("cellrank", convert = FALSE)
mt <- import("moscot", convert = FALSE)
plt <- import("matplotlib", convert = FALSE)
conflicted::conflict_prefer("select", "dplyr")
conflicted::conflict_prefer("filter","dplyr")
conflicted::conflict_prefer("saveRDS","base")
```


# Define Functions

```{r}
colors_vector <- c(RColorBrewer::brewer.pal(12, "Paired"), 
            "blue1", "darkslategray3", "burlywood3", "#984EA3",
            "seagreen1", "yellow2", "orchid", "darkblue", 
            "lightsalmon2","slateblue1","lightskyblue4",
            "azure2", "chartreuse1",  "lemonchiffon2",
            "deeppink", "darkslategray1", "green4", "navajowhite", 
            "brown4", "darkgoldenrod2", "deepskyblue1", "lightpink") %>% 
  # c(., ggpubr::get_palette("jco", 5)) %>% 
  c("mediumpurple4","magenta", "peru") %>% 
  c(ggsci::pal_igv()(51))

length(colors_vector) 

sample_id_colors <- c("black",colors_vector[1:18])
```

```{r}
make_3D_umap <- function(metadata, idents_column, label_cols, selected_colors=NULL){
    "
    idents_column is for labeling. ex) 'RNA_snn_res.0.7 as well as the UMAP colnames, eg UMAP_1, UMAP_2'
    "
    # 3D UMAP
    plot.data <- metadata
    plot.data$label <- paste(rownames(plot.data))

    plot.data  <- plot.data %>% 
          unite(col = label, all_of(c("label",label_cols)), sep = "\n", remove = FALSE) %>% 
          select(all_of(c("label",label_cols)), all_of(idents_column))

    
    if(is.null(selected_colors)){
      selected_colors <- c("lightseagreen", "gray50",  "darkgreen", "red4", "red", "turquoise4","black","yellow4","royalblue1","lightcyan3",
                 "peachpuff3","lightskyblue","gray20","orange2","royalblue4","yellow3","gray80","darkorchid1","lawngreen","plum2", 
                 "darkorange4","darkmagenta","mediumorchid1","lightslateblue","midnightblue", "tan2") #26
    }

    cnames <- colnames(plot.data)
    formulas <- sapply(1:3, function(x) as.formula(paste0("~", grep(glue("_{x}$"), cnames, value = TRUE))))
    fig <- plot_ly(data = plot.data, 
        x = formulas[[1]], y = formulas[[2]], z = formulas[[3]], 
        color = as.formula(paste0("~", label_cols[1])), 
        colors = selected_colors, 
        type = "scatter3d", 
        mode = "markers", 
        marker = list(size = 1, width=2), # controls size of points
        text=~label, # This is that extra column we made earlier for which we will use for cell ID
        hoverinfo="text") #When you visualize your plotly object, hovering your mouse pointer over a point shows cell names

    return(fig)
}
```

```{r}
custom_dimplot <- function(metadata, colorby, dimred_colnames, custom_colors,
                           lab_size = 6, ny = 0, custom_lab_fill = NULL,
                           label_samples = TRUE,
                           color_text_grp = FALSE,
                           add_text = TRUE, color_bar_lims = NULL,
                           seed = 2023){
  
  # define x and y column names
  x_names <- paste0(dimred_colnames, "_1")
  y_names <- paste0(dimred_colnames, "_2")
  
  # define labels positions
  labs_df <- metadata %>%
    select(all_of(c(colorby, x_names, y_names))) %>%
    group_by(!! as.name(colorby)) %>% 
    summarise(x = mean(!! as.name(x_names)),
              y = mean(!! as.name(y_names)))
  
   # define point sizes based on how many total cells in data
   ncells <- nrow(metadata)
   pt_size <- case_when(
     ncells < 5e4 ~ 1,
     ncells >= 5e4 & ncells < 1e5 ~ 0.5,
     ncells >= 1e5 ~ 0.25)
   
   # Make the scatterplot
   plot <- ggplot(metadata, 
         aes_string(x = x_names, y = y_names)) +
    geom_point(aes_string(color = colorby),
               size = pt_size, alpha = 0.4) +
    theme_classic() +
    theme(legend.position = "top")
   
   # Color points
   cl <- class(metadata[[colorby]])
   if(cl != "numeric"){
     plot <- plot +
       scale_color_manual(values = custom_colors)
   }else{
     plot <- plot +
       scale_color_viridis_c(option = "A", 
                             limits = color_bar_lims, 
                             oob = scales::squish)
   }
   
   # customize label positions
   if(is.character(ny)){
     y_val <-  ifelse(grepl(ny, labs_df[[colorby]]), 1.5, 0)
   }else{
     y_val <- ny
   }
   
   if(is.null(custom_lab_fill)){
     fill_val <-  "white"
   }else{
     fill_val <- custom_lab_fill
   }
   
   if(color_text_grp){
     mapping <- aes_string(x = "x", y = "y", label = colorby, color = colorby)

   }else{
     mapping <- aes_string(x = "x", y = "y", label = colorby)
   }
  
   if( all(add_text & label_samples) ){
     plot <- plot + 
           ggrepel::geom_text_repel(data = labs_df, 
                             mapping = aes_string(x = "x", y = "y", label = colorby),
                             color = "black",
                             nudge_y = y_val,
                             segment.colour = NA,
                             size = lab_size,
                             seed = seed)
   }else if ( label_samples ) {
      plot <- plot + 
         ggrepel::geom_label_repel(data = labs_df, 
                           mapping = mapping,
                           fill = fill_val,
                           nudge_y = y_val,
                           segment.colour = NA,
                           label.size = 0.5,
                           size = lab_size,
                           show.legend = FALSE,
                           seed = seed)
   }
   
   # make legend points larger
   plot <- plot +
       guides(color = guide_legend(override.aes = list(alpha = 1, size = 2))) +

   
   return(plot)
}
```

```{r}
custom_heatmaps <- function(seurat_obj, genes,columns = NULL, annot_colors = NULL, celltype="ALL"){
  
  if(celltype == "ALL"){
    cell_ids <- colnames(seurat_obj)
  }else{
    cell_ids <- CellsByIdentities(seurat_obj, idents = celltype) %>%  unlist()
  }
  
  print(c("The assay is", DefaultAssay(seurat_obj)))
  genes <- intersect(genes,rownames(seurat_obj))
  seurat_obj <- ScaleData(seurat_obj, features = genes)
  
  print("Extracting expression data")
  norm_counts <- LayerData(seurat_obj[[DefaultAssay(seurat_obj)]], 
                           layer = 'scale.data', 
                           features = genes, 
                           cells = cell_ids)
  
  col_annots <- seurat_obj@meta.data %>% 
    select(-all_of("barcode")) %>% 
    rownames_to_column("barcode") %>% 
    filter(barcode %in% colnames(norm_counts)) %>% 
    as.data.frame() %>%
    set_rownames(.$barcode) %>%
    select(all_of(columns))
  
  # row_annots <- temp %>% 
  #   set_rownames(.$coords) %>% 
  #   select(gene_name, p_val, p_val_adj) 
  
  x <- nrow(norm_counts)
  fontsize_rows <- case_when(
    x < 50 ~ 10,
    x >= 50 & x < 100 ~ 8, 
    x >= 100 & x < 200 ~ 6, 
    x >= 200 ~ 4)


  len <- 299
  colors <- colorRampPalette(viridis::viridis(10))(len)
  colors_list <- lapply(columns, function(x){
          grps <- unique(pull(col_annots, all_of(x)))
          n <- length(grps)
          colors <- annot_colors[1:n] %>% 
            set_names(grps)
          return(colors)
    })
  names(colors_list) <- columns
  

  pheatmap::pheatmap(mat=as.matrix(norm_counts), 
                     scale = "none", 
                     color = colors,
                     fontsize_row = fontsize_rows,
                     # main = glue::glue("{celltype}: DA Peaks p<0.05 & FC >= {th}"),
                     annotation_col = col_annots,
                     annotation_colors = colors_list,
                     # annotation_row = row_annots[,-1],
                     labels_row = rownames(norm_counts),
                     clustering_method = 'ward.D2',
                     show_colnames = FALSE)
}
```

```{r}
transition_heatmap <- function(temporal_problem, transition_mat_name){
  

  moscot_res <- py_to_r(temporal_problem$adata$uns$moscot_results$cell_transition[[transition_mat_name]])
  ct_descendants <- moscot_res$transition_matrix
  
  source_col <- glue("source_Day{moscot_res$source}")
  target_col <- glue("target_Day{moscot_res$target}")
  ct_descendants_df <- ct_descendants %>% 
    rownames_to_column(source_col) %>% 
    pivot_longer(cols = -all_of(source_col), 
                 names_to = target_col,
                 values_to = "cell_transition") %>% 
    mutate(cell_transition_label = round(cell_transition, digits = 3))
  
  transition_plot <- ggplot(ct_descendants_df, 
         aes(x = !!as.name(source_col), y = !!as.name(target_col), fill = cell_transition_label)) +
    geom_tile(color = "white", linewidth = 2) +
    geom_text(aes(label = cell_transition_label), color = "white")  +
    scale_fill_viridis_c() +
    theme_classic()
  
  return(transition_plot)
}
```


# Parallelization 

```{r eval=FALSE}
library(future)
# check the current active plan
plan()
plan("multisession", workers = 16)
plan()
options(future.globals.maxSize = 60000 * 1024^2)
```

# Genome Refs

```{r eval=FALSE}
suppressPackageStartupMessages(library(ensembldb))

# db <- ensDbFromGtf("resources/genome/Homo_sapiens.GRCh38.109.chr.gtf.gz")

#Warning: Could not determine length for all seqnames
db <- ensDbFromGtf(gtf = "/gpfs/shared_data/10X/cellranger-7.0.0/refdata-gex-GRCh38-2020-A/genes/genes.gtf", 
                   genomeVersion = "GRCh38",
                   organism = "Homo_sapiens",
                   version = 98)
```

```{r, eval=FALSE}
edb <- ensembldb::EnsDb("resources/genome/Homo_sapiens.GRCh38.98.sqlite")

# edb

gids <- ensembldb::keys(edb, keytype = "GENEID")
idmap <- AnnotationDbi::select(edb, keytype="GENEID", 
                      keys = gids, 
                      columns = c("GENEID","GENEBIOTYPE","GENENAME","SYMBOL")) %>% 
  janitor::clean_names()

# head(idmap)
# dim(idmap) #36601
```

```{r}
changho_refs_file <- "references/changho_updated_marker_genes_MN_IN_annotation.xlsx"
marker_genes_chun <- purrr::map_dfr(openxlsx::getSheetNames(changho_refs_file)[2:4], function(x){
  openxlsx::read.xlsx(changho_refs_file, sheet = x)
}) %>% 
  janitor::clean_names() %>% 
  distinct() %>% 
  mutate(group=paste(author, tolower(neural_pop)) %>% 
           gsub("\\s","_",.)) %>% 
  mutate(specific_markers_for_each_type_of_neuron=gsub("\\s","", specific_markers_for_each_type_of_neuron))

# marker_genes_chun
marker_genes_chun_list <- purrr::map(unique(marker_genes_chun$group), function(x){
  marker_genes_chun %>%
    filter(group == x) %>%
    pull(specific_markers_for_each_type_of_neuron)
}) %>% 
  set_names(unique(marker_genes_chun$group))
marker_genes_chun_list[["pan_neuronal_markers"]] <- str_split(marker_genes_chun[1,"pan_neuronal_markers"], pattern = ", ", n=3)[[1]]

# marker_genes_chun_list
names(marker_genes_chun_list)
```

```{r}
marker_genes_endoderm <- c("CXCR4", "HDE1", "HDE2", "SOX17", "KLF8", "MYCT1", "DKK4",
                           "CLDN6","KRT19","EOMES", "FABP1", "FABP2","GATA4","GSC",
                           "KRT12","FOXA1","FOXA2","TGFB1","SOX7","SOX17", "HNF1B")

length(marker_genes_endoderm)
```

```{r}
# https://github.com/regan-hamel/h-iPSCs-MNI/blob/master/R%20workflow_iMNs_LThiry_2020.Rmd
marker_genes_iPSC <- list(MNPCs = c("CHAT", "ISL1", "ISL2", "MNX1", "OLIG2", "NEUROG2"),
                INs = c("PAX3", "VSX2", "GATA3", "SOX14", "SIM1", "LBX1", "TLX3"),
                NPCs = c("SOX1", "SOX2", "MKI67"),
                Glial = c("SOX9", "S100B", "GFAP"),
                Oligodendrocytes = c("PDGFRA", "GALC"),
                iPSCs = c("NANOG", "POU5F1"))
```

```{r warning=FALSE}
rayon_marker_genes <- openxlsx::read.xlsx(xlsxFile = "resources/cell_refs/Rayon_2021/TableS2.xlsx") %>% 
  janitor::clean_names() %>% 
  mutate(id = paste("rayon", type, neural_pop, sep="_") %>% 
           gsub("\\s", "_", .)) %>% 
  mutate(description = case_when(
    grepl("FP", id) ~ gsub("FP","floor plate", id),
    grepl("RP", id) ~ gsub("RP","roof plate", id),
    grepl("dp", id) ~ gsub("dp[0-9]", "dorsal interneuron progenitors", id),
    grepl("p[0-2]", id) ~ gsub("p[0-2]", "intermediate interneuron progenitors", id),
    grepl("p3", id) ~ gsub("p3","ventral interneuron progenitors p3", id), 
    grepl("V[0-3]", id) ~ gsub("V[0-9].?", "ventral neurons", id),
    grepl("MN", id) ~ gsub(".?MN","motor neuron", id),
    grepl("dl[0-6]", id) ~ gsub("dl[0-9]", "dorsal Interneuron", id),
    grepl("LTMR|LMTR", id) ~ gsub("C?-{0,1}(LTMR|LMTR).{0,}", "mechanoreceptor", id),
    grepl("Proprioceptor|nociceptor", id) ~ gsub("Peripheral","PNS Peripheral",id),
    grepl("Mesoderm|Eryt|Blood|Hema|Myoblast|Oligo", id) ~ paste("rayon",str_split_fixed(id, "_", n=3)[,2]),
    TRUE ~ id
  ) %>% gsub("_"," ", .) %>% gsub("rayon ","", .))


# View(rayon_marker_genes)
# head(rayon_marker_genes)

rayon_marker_genes_long <- rayon_marker_genes %>% 
  separate(genes_map_step1, into = paste0("gene",1:5), sep=", ") %>% 
  separate(genes_map_step2, into = paste0("gene",5:20), sep = ", ") %>% 
  pivot_longer(cols = matches("^gene"),
               names_to = "colname",
               values_to = "genes") %>% 
  filter(!is.na(genes)) 

# rayon_marker_genes_long

rayon_marker_gene_list <-  purrr::map(unique(rayon_marker_genes_long$id), function(x){
  rayon_marker_genes_long %>% 
    filter(id == x) %>% 
    pull(genes) %>% 
    unique()
})
names(rayon_marker_gene_list) <- unique(rayon_marker_genes_long$id)
# rayon_marker_gene_list
```

```{r}
rayon_degs <- openxlsx::read.xlsx("resources/cell_refs/Yadav_2023/1-s2.0-S0896627323000314-mmc5.xlsx", sheet = 1, check.names = FALSE, sep.names = " ") %>% 
  pivot_longer(cols = everything(),
               names_to = "subtype_annotation", 
               values_to = "degs") %>% 
  mutate(names = gsub("-[0-9]{1,2}$","", subtype_annotation) %>% 
           gsub(".+\\s(.+)$", "\\1", .) %>% 
           gsub("\\/|-","_", .))

esc_celltypes <- unique(rayon_degs$names)
rayon_deg_gene_list <-  purrr::map(esc_celltypes, function(x){
  rayon_degs %>%
    filter(names == x) %>%
    pull(degs) %>%
    unique()
})
names(rayon_deg_gene_list) <- esc_celltypes
```

```{r}
mn_subtype_markers <- openxlsx::read.xlsx("references/11122023_Alpha_Gamma_MNs_consolidated marker list.xlsx", sheet = 2)
head(mn_subtype_markers)
# table(mn_subtype_markers$celltype)
```

# Read in iPSC Object

```{r}
current_path <- file.path("results/day0_day50/seurat")
current_obj <- "iPSC_motor_neuron_day0-day50_time-course_filtered_merged_soupX_normalized_anno_seurat_obj_v5.RDS" 

ipsc_obj <- readRDS(file.path(current_path, current_obj))
ipsc_obj
```

```{r}
gene_annots <- ipsc_obj@assays$RNA@meta.data

sct_gene_annots <- ipsc_obj[["SCT"]]@meta.features %>% 
  rownames_to_column("gene_name_fix") %>% 
  left_join(., gene_annots, 
            by = "gene_name_fix") %>% 
  mutate(variable_gene = gene_name_fix %in% VariableFeatures(ipsc_obj)) %>% 
  group_by(gene_name) %>% 
  mutate(gene_name_clean = case_when(
    n() == 1 ~ gene_name,
    TRUE ~ gene_name_fix
  )) %>% 
  ungroup() %>% 
  as.data.frame() %>% 
  set_rownames(.$gene_name_fix)

# sct_gene_annots
# table(duplicated(sct_gene_annots$gene_name_fix)) # FALSE
# identical(rownames(ipsc_obj[["SCT"]]), rownames(sct_gene_annots)) #TRUE

# Add the gene ID metadata to SCT assay
ipsc_obj[["SCT"]] <- AddMetaData(ipsc_obj[["SCT"]], metadata = sct_gene_annots)

# Create a new assay just with the cleaned/de-duped gene names
sct_data <- LayerData(ipsc_obj, assay = "SCT", layer = "data")
rownames(sct_data) <- sct_gene_annots$gene_name_clean
ipsc_obj[["SCT_renamed"]] <- CreateAssay5Object(data = sct_data)
hvgs <- sct_gene_annots %>% 
  filter(variable_gene) %>% 
  pull(gene_name_clean)

VariableFeatures(ipsc_obj, assay = "SCT_renamed") <- hvgs

rm(sct_data)
rm(sct_gene_annots)
```


## Visualization 

```{r}
table(ipsc_obj$subtype_standardized)
```

```{r}
ct_colors <- viridis::turbo(8) %>% 
  set_names(names(table(ipsc_obj$subtype_standardized)))
```

```{r fig.height=10, fig.width=10}
custom_dimplot(metadata = ipsc_obj@meta.data, 
               colorby = "batch", 
               dimred_colnames = "umapscanvi", 
               custom_colors = ggpubr::get_palette("jco", 4))

custom_dimplot(metadata = ipsc_obj@meta.data, 
               colorby = "subtype_standardized", 
               dimred_colnames = "umapscanvi", 
               custom_colors = ct_colors)

custom_dimplot(metadata = ipsc_obj@meta.data, 
               colorby = "subtype_standardized_subclusters", 
               dimred_colnames = "umapscanvi", 
               custom_colors = colors_vector)
```

```{r fig.height=10, fig.width=10}
# ipsc_obj$time_point %>% head()
# ipsc_obj$time_point_factor %>% head()

# png("figures/day0_day50/trajectories/iPSC_motor_neuron_time_point_scanvi_UMAP.png", height = 10, width = 12, res = 125, units = "in")
ggplot(ipsc_obj@meta.data,
       aes(x = umapscanvi_1, y = umapscanvi_2)) +
  geom_point(aes(color = time_point), alpha = 0.5, size = 0.1) +
  scale_color_viridis_c() +
  theme_bw() +
  theme(axis.text = element_text(size = 12)) 
# dev.off()
```

# Trajectories

Review article:
https://www.nature.com/articles/s41576-021-00444-7

Selecting which time-points to include:
However, there are cases where the dynamics of the process being studied is unknown or when assumptions are based on the phenotypic behaviour, which may not reflect the underlying molecular dynamics that are being profiled by scRNA-seq71. To address this, Kleyman et al. developed the time point selection (TPS) method71 (Fig. 2). TPS was originally developed and applied to bulk RNA-seq but can also be used for scRNA-seq. It works by initially oversampling bulk-level RNA-seq using cheap array methods. Next, spline curves are used to fit the profiled data, which enables the method to predict values for unobserved time points. A heuristic optimization function is then used to select the most informative time points, those points that if sampled provide enough information to reconstruct the entire expression trajectory for all genes


OK - slingshot
   - Monocle3
   - CellRank / Moscot
No
- PRESCIENT (8 citations, not maintained in 3 yrs)
- psupertime (not maintained in 4yrs, only 11 citations)
- dyno (not maintained in 4yrs)
- CSHMM (not maintained in 7 years, 151 citations)
https://github.com/gifford-lab/prescient
https://github.com/dynverse/dyno

## Monocle3

```{r}
suppressPackageStartupMessages(library(monocle3))
suppressPackageStartupMessages(library(SeuratWrappers))
```

```{r}
# Warning: gene_metadata must contain a column verbatim named 'gene_short_name' for certain functions.
cds <- new_cell_data_set(expression_data = ipsc_obj@assays$SCT$counts,
                         cell_metadata = ipsc_obj@meta.data)
logcounts(cds) <- ipsc_obj@assays$SCT$data

reducedDims(cds) <- list(PCA=ipsc_obj@reductions$pca@cell.embeddings,
                         Harmony=ipsc_obj@reductions$rpca@cell.embeddings,
                         UMAP=ipsc_obj@reductions$umap.rpca@cell.embeddings)

cds
```

```{r}
# use the harmony UMAP (renamed to simply UMAP for compatibility) to identify unsupervised clusters
# defines the 'partitions' found in the cell clustering 
cds <- cluster_cells(cds, 
                     reduction_method = "UMAP",
                     cluster_method = "leiden",
                     k = 20)

cds
```

```{r fig.height=10}
p1 <- plot_cells(cds, 
                 show_trajectory_graph = FALSE)

p2 <- plot_cells(cds, 
                 color_cells_by = "partition", 
                 show_trajectory_graph = FALSE)

p3 <- plot_cells(cds, 
                 color_cells_by = "orig.ident", 
                 show_trajectory_graph = FALSE)

p1
p2
p3
```

```{r}
# Identifying the program of gene expression changes is equivalent to learning a trajectory that the cells follow through this space.
cds <- learn_graph(cds, 
                   use_partition = FALSE,
                   verbose = TRUE)
```

```{r eval=FALSE}
DimPlot(subset(ipsc_obj, subset = orig.ident == "iPSC_ipsc"),
        reduction = "umap.rpca",
        group.by = "rpca_clusters")
```

```{r fig.height=10, fig.width=10}
plot_cells(cds, label_principal_points = TRUE)
```

If `root_cells` is set as NULL, then its based on manual selection of the root cells.
However, there are methods available like time point selection (TPS) that might be able to refine the root cells, rather than use all time0 cells.

```{r}
#Assigns cells a pseudotime value based on their projection on the principal graph
time0 <- WhichCells(ipsc_obj, expression = orig.ident == "iPSC_ipsc")
cds <- order_cells(cds, 
                   reduction_method = "UMAP", 
                   root_cells = time0, 
                   verbose = TRUE)

# cds
```

```{r fig.height=10, fig.width=10}
plot_cells(cds, 
           label_groups_by_cluster = FALSE,
           label_leaves = FALSE, 
           label_branch_points = FALSE)
```

```{r fig.height=10, fig.width=10}
plot_cells(cds, 
           color_cells_by = "pseudotime",
           label_groups_by_cluster = FALSE,
           label_leaves = FALSE, 
           label_branch_points = FALSE)
```


## Slingshot

https://bioconductor.org/packages/release/bioc/html/slingshot.html

Provides functions for inferring continuous, branching lineage structures in low-dimensional data. Slingshot was designed to model developmental trajectories in single-cell RNA sequencing data and serve as a component in an analysis pipeline after dimensionality reduction and clustering. It is flexible enough to handle arbitrarily many branching events and allows for the incorporation of prior knowledge through supervised graph construction.

```{r}
library(slingshot)
```

cds <- new_cell_data_set(expression_data = ipsc_obj@assays$SCT$counts,
                         cell_metadata = ipsc_obj@meta.data)
logcounts(cds) <- ipsc_obj@assays$SCT$data

reducedDims(cds) <- list(PCA=ipsc_obj@reductions$pca@cell.embeddings,
                         Harmony=ipsc_obj@reductions$harmony@cell.embeddings,
                         UMAP=ipsc_obj@reductions$umap_harmony_subset@cell.embeddings)

two-step process composed of identifying the global lineage structure with a cluster-based minimum spanning tree (MST) and fitting simultaneous principal curves to describe each lineage.

```{r}
sce <- Seurat::as.SingleCellExperiment(ipsc_obj, assay = "SCT")

sce
```

potential labels
1) subtype (N=7)
2) unsupervised clusters (N=22)
3) subtype + unsupervised clusters

```{r}
sce$subtype_standardized_subclusters %>% table()
reducedDims(sce)
head(reducedDim(sce, "UMAP.RPCA"))
```

All of the results are stored in a PseudotimeOrdering object, which is added to the colData of the original object and can be accessed via colData(sce)$slingshot

to extact all slingshot objects/results 
  * as.SlingshotDataSet (class SlingshotDataSet) 
  * as.PseudotimeOrdering (classSummarizedExperiment)


omega
This value is provided as a potentially useful rule of thumb for datasets with outlying clusters or multiple, distinct trajectories. 
-  In practice, this makes omega the maximum allowable distance between two connected clusters.
- omega_scale, default = 3

approx_points
 - sets the number of points to be used for each curve, can have a large effect on computation time.
 - set the default value to 150 whenever the input dataset contains more than that many cells. 

lineages without defined start cluster
- If we do not specify a starting point, slingshot selects one based on parsimony, maximizing the number of clusters shared between lineages before a split.

 recommend the **specification of an initial cluster based on prior knowledge**
  - either time of sample collection or established gene markers
  - This specification will have no effect on how the MST is constructed, but it will impact how branching curves are constructed.
  - clusters as **terminal** states will be constrained to have only one connection when the MST 
  

The fundamental assumption of slingshot is that cells which are transcriptionally similar will be close to each other in some reduced-dimensional space. Since we use Euclidean distances in constructing lineages and measuring pseudotime, it is important to have a low-dimensional representation of the data.

```{r}
sce$subtype_standardized_subclusters %>% 
  unique() %>% 
  grep("progenitor", ., value=TRUE)
```


```{r}
# or use the full RPCA dimensions - the authors show using just 1 or 2 dims? 
sce <- slingshot(sce, 
                 clusterLabels = 'subtype_standardized_subclusters',
                 reducedDim = 'UMAP.RPCA', 
                 time = sce$time_point,
                 start.clus = NULL,
                 end.clus = NULL,
                 dist.method = "slingshot",
                 use.median = FALSE, # FALSE is default
                 omega = FALSE,
                 omega_scale = 1.5,
                 reassign = TRUE, 
                 allow.breaks = TRUE, # TRUE is default
                 reweight = TRUE # TRUE is default
                 ) 
```



```{r}
# checkout the coldata pseudotime (?) values
colData(sce)$slingshot

# convert to Slingshot Dataset
slingshot_data <- SlingshotDataSet(sce)
# slingshot_data@lineages %>% head()
slingshot_data
```
```{r}
summary(colData(sce)$slingPseudotime_1) # lots of NAs...

colnames(colData(sce)) %>% grep("slingPseudotime_", ., value=TRUE)
```

```{r}
n_clusts <- length(unique(sce$subtype_standardized_subclusters))
colData(sce)$barcode <- rownames(colData(sce))

cc <-  colData(sce)[,c("barcode","subtype_standardized_subclusters")] %>% 
  as.data.frame() %>% 
  left_join(.,  data.frame(colors = colors_vector[1:n_clusts], 
                           subtype_standardized_subclusters = unique(sce$subtype_standardized_subclusters)), 
            by="subtype_standardized_subclusters") %>% 
  pull(colors, name = "subtype_standardized_subclusters")

head(cc)
```

```{r fig.height=10, fig.width=10}
plot(reducedDim(sce, "UMAP.RPCA"), 
     col = alpha(cc,alpha = 0.5),
     cex = 0.25,
     asp = 1, pch = 16)
lines(SlingshotDataSet(sce),
      type = 'lineages',
      lwd = 2, 
      col = 'black')
```

## TSCAN

```{r}
library(TSCAN)
```


## CellRank 

CellRank is a software toolkit to study dynamical biological processes, like development, regeneration, cancer or reprogramming, based on multi-view single-cell genomics data
 - Oftentimes, the type of downstream analysis does not depend on the modality that was used to estimate cellular transitions

https://cellrank.readthedocs.io/en/latest/notebooks/tutorials/kernels/500_real_time.html

a scRNA-seq dataset with experimental time points. Additional spatial or lineage information improves the accuracy of fate mapping, but is not required.

* a scRNA-seq dataset for which you can compute a cell-cell transition matrix using any CellRank kernel.

### Create AnnData Object 


```{r eval=FALSE}
# assay_norm <- "SCT_renamed"
assay_norm <- "RNA"
# variable features to be added to a anndata
var_df <- data.frame(gene_name = rownames(ipsc_obj[[assay_norm]])) %>% 
  mutate(highly_variable = gene_name %in% VariableFeatures(ipsc_obj,
                                                           assay = assay_norm), 
         var.features = gene_name %in% VariableFeatures(ipsc_obj,
                                                        assay = assay_norm)) %>%
        set_rownames(.$gene_name)

# convert to pandas dataframe class again to access the astype() function
pd <- import("pandas", convert = FALSE)
obs <- pd$DataFrame(ipsc_obj@meta.data)

# convert to sparse matrices (transpose base densifys the data)
# SeuratDisk::Transpose does not work, probably b/c its not an H5Seurat Class obj. 
scipy_sparse <- import("scipy.sparse", convert = FALSE)
norm_counts <- scipy_sparse$csr_matrix(t(as.matrix(LayerData(ipsc_obj, assay = assay_norm, layer = "data"))))
conflicted::conflicts_prefer(SeuratObject::Layers)

if(length(Layers(ipsc_obj[["RNA"]])) > 1){
  ipsc_obj[["RNA"]] <- JoinLayers(ipsc_obj[["RNA"]])
}
counts_mat <- t(as.matrix(LayerData(ipsc_obj, assay = 'RNA', layer = "counts")))
counts_mat <- scipy_sparse$csr_matrix(counts_mat[, rownames(ipsc_obj[[assay_norm]])])

# create an anndata object with transposed counts matrices
# dataset should be normalized by total counts and log2-transformed. - using analytic pearson residuals OK?
# Further, highly variable genes have already been annotated
ipsc_adata <- AnnData(
  X = norm_counts, 
  obs = obs,
  var = var_df,
  obsm = list("X_scANVI" = ipsc_obj@reductions$scanvi@cell.embeddings, 
               # "X_rpca" = ipsc_obj@reductions$rpca@cell.embeddings,
               "X_pca" = ipsc_obj@reductions$pca@cell.embeddings,
               "X_umap" = ipsc_obj@reductions$umap.scanvi@cell.embeddings
              ),
  layers = list(counts = counts_mat)
)

## anndata::AnnData() function enforces the conversion to 'dtype='object' from the original  dtype='int64' in `obs` pandas dataframe. ugh.
ipsc_adata
# uses n.neighbors = 15 by default. 
seed_val <- as.integer(20240301)

# use batch corrected embedding 
# k-NN graph, which we’ll need later on.
sc$pp$neighbors(ipsc_adata,
                use_rep = "X_scANVI",
                random_state = seed_val, 
                metric = 'cosine')
ipsc_adata
rm(counts_mat)
rm(norm_counts)

anndata::write_h5ad(ipsc_adata,glue("results/day0_day50/cellrank/iPSC_MN_day0-day50_time-course_{assay_norm}_adata.h5ad"))
ipsc_adata$write_h5ad(filename = glue("results/day0_day50/cellrank/iPSC_MN_day0-day50_time-course_{assay_norm}_adata_scanpy.h5ad"))
rm(ipsc_adata)
```


### Temporal Problem 

https://moscot.readthedocs.io/en/latest/notebooks/tutorials/200_temporal_problem.html

couple cells across time points using [optimal transport](https://en.wikipedia.org/wiki/Transportation_theory_(mathematics)) (OT), as pioneered by [Waddington-OT](https://broadinstitute.github.io/wot/)
  * From the manuscript:
  * Analyzing >315,000 cells sampled densely across 18 days of reprogramming mouse embryonic fibroblasts (MEFs) into iPSCs
  * Using Waddington-OT to reconstruct the landscape of differentiation trajectories and intermediate states that give rise to these diverse fates, we describe a gradual 
  transition to either stroma-like cells or a mesenchymal-to-epithelial transition (MET) state.

https://moscot.readthedocs.io/en/latest/notebooks/examples/problems/800_score_genes_for_marginals.html
* core_genes_for_marginals() computes the marginals such that cells expressing proliferation marker genes get a higher weight as they are assumed to have multiple descendants or that certain cells are outliers in space, so they should not influence the mapping too much

NOTE:

`tp$adata$obs['day']$cat$categories` this should **not** be dtype='object'
Index(['0', '3', '5', '8', '11', '15', '18', '21', '24', '27', '30', '35',
       '40', '45', '50'],
      dtype='object')

```{r}
seed_val <- as.integer(20240301)
```

```{r}
tp <- mt$problems$time$TemporalProblem$load("results/day0_day50/cellrank/temporal_problem/iPSC_MNs_day0-day50_moscot_cellrank_OT.pickle")
tp
tp$stage #'solved'
tp$adata$uns$moscot_results$cell_transition %>% names()
```

```{r eval=FALSE}
ad <- import("anndata", convert = FALSE)

# set-up the object 
ipsc_adata <- ad$read_h5ad(filename = "results/day0_day50/cellrank/iPSC_MN_day0-day50_time-course_RNA_adata_scanpy.h5ad")
#"anndata._core.anndata.AnnData" "python.builtin.object"  

ipsc_adata$obs['day'] <- ipsc_adata$obs['time_point']$astype('int64')$astype('category')
# Name: day, Length: 86954, dtype: category
# Categories (15, int64): [0, 3, 5, 8, ..., 35, 40, 45, 50]

ipsc_adata$obs['day']$cat$categories
# Index([0, 3, 5, 8, 11, 15, 18, 21, 24, 27, 30, 35, 40, 45, 50], dtype='int64')
```

Marginals define the weight of each single cell within a distribution of cells

score_genes_for_marginals() computes the marginals such that cells expressing proliferation marker genes get a higher weight as they are assumed to have multiple descendants or that certain cells are outliers in space, so they should not influence the mapping too much.

```{r eval=FALSE}
# initial the temporal problem from adata 
tp <- mt$problems$TemporalProblem(ipsc_adata)

# check the object class
tp$adata$obs['day']$cat$categories
# Index([0, 3, 5, 8, 11, 15, 18, 21, 24, 27, 30, 35, 40, 45, 50], dtype='int64') # OK

# calculate marginals
tp <- tp$score_genes_for_marginals(
    gene_set_proliferation="human",
    gene_set_apoptosis="human"
)

tp$apoptosis_key
tp$proliferation_key
# WARNING: genes are not in var_names and ignored: ['FAM64A', 'HN1', 'MLF1IP']
# WARNING: genes are not in var_names and ignored: ['FASLG', 'GPX1', 'GSTM1', 'H1-0', 'IFNB1', 'IL1B', 'PRF1', 'TNF']
```

```{r fig.height=5, fig.width=25}
sc$pl$embedding(tp$adata, 
                basis="X_umap", 
                color=c("subtype_standardized","proliferation", "apoptosis"))
```

```{r eval=FALSE}
# https://moscot.readthedocs.io/en/latest/genapi/moscot.problems.time.TemporalProblem.prepare.html#moscot.problems.time.TemporalProblem.prepare
# if joint_attr not provided: PCA on X is computed.Each pairwise (for each time-point) PCA is compared to one another to build the graphs
# use local PCAs, computed separately for each pair of time points, to calulate distances among cells [Schiebinger et al., 2019]. 
tp <- tp$prepare(time_key="day",
                 policy='sequential', 
                 joint_attr = "X_scANVI")
                 # kwargs = list("subset" = r_to_py(time_cats_explicit)))
tp

# Add the growth rates
ipsc_adata$obs["prior_growth_rates"] =  py_to_r(tp$prior_growth_rates)[["prior_growth_rates"]]
```

entropic regularization: `epsilon` 
amount of unbalancedness on the source marginal: `tau_a` c
 
Higher entropic regularization speeds up the optimization and improves statistical properties of the solution
unbalancedness makes the solution more robust with respect to uncertain cellular growth rates and biased cell sampling

```{r eval=FALSE}
# solve one OT problem per time point pair, probabilistically matching early to late cells
# allow for adjustments of prior estimates by setting tau_a<1 and tau_b<1 as we don’t expect many cells to die in a developmental setting.
tp <- tp$solve(epsilon=1e-3, tau_a=0.95, tau_b = 0.99, scale_cost="mean")
tp

# INFO     Solving `14` problems                                                  
# INFO     Solving problem BirthDeathProblem[stage='prepared', shape=(3860,3054)]. 

ipsc_adata$obs["posterior_growth_rates"] = py_to_r(tp$posterior_growth_rates)[["posterior_growth_rates"]]
ipsc_adata$obs["cell_costs_source"] = py_to_r(tp$cell_costs_source)[["cell_cost_source"]]
ipsc_adata$obs["cell_costs_target"] = py_to_r(tp$cell_costs_target)[["cell_cost_target"]]

# save the temporal problem
# tp$save(path = "results/day0_day50/cellrank/temporal_problem/iPSC_MNs_day0-day50_moscot_cellrank_OT.pickle", overwrite = TRUE)
```

```{r eval=FALSE}
# compute transition matrices per time-point pair sequentially
time_cats_paired <- list()
vals <- unique(ipsc_obj$time_point)
for(i in 1:14){
  s <- as.integer(vals[i])
  e <- as.integer(vals[i+1])
  grp <- c(s,e)
  # grp <- reticulate::tuple(s,e)
  time_cats_paired[[i]] <- grp
  i <- i+1
}

# time_cats_paired

for(set in time_cats_paired){
  key <- glue("transitions_{set[1]}_{set[2]}")
  print(key)
  #interested in descendants as opposed to ancestors, choose forward = True.
  tp$cell_transition(source = as.integer(set[1]),
                     target = as.integer(set[2]),
                     source_groups = "subtype_standardized", 
                     target_groups = "subtype_standardized",
                     forward=TRUE,
                     key_added=key)
}
```

```{r}
# compute a transition matrix from day0 to day50
tp$cell_transition(source = as.integer(0),
                   target = as.integer(50),
                   source_groups = "subtype_standardized", 
                   target_groups = "subtype_standardized",
                   forward=TRUE,
                   key_added="transitions_0_50")
```


#### Visualization

High values in prior_growth_rates or posterior_growth_rates

- indicate that a certain cell is unlikely to have a descendant or ancestor, respectively. One should consider removing them and rerunning the algorithm.

```{r fig.height=10, fig.width=12}
p1 <- sc$pl$embedding(ipsc_adata, 
                basis="X_umap",
                color=c("prior_growth_rates","posterior_growth_rates"),
                vmax="p99")

p2 <- sc$pl$embedding(ipsc_adata, 
                basis="X_umap",
                color=c("cell_costs_source","cell_costs_target"))

# p1
```

```{r fig.height=7, fig.width=15}
meta <- py_to_r(ipsc_adata$obs)
# range(c(meta$cell_costs_source, meta$cell_costs_target), na.rm = TRUE)

source_plot <- custom_dimplot(metadata = meta, 
               dimred_colnames = "umapscanvi", 
               colorby = "cell_costs_source", 
               label_samples = FALSE, 
               color_bar_lims = c(-0.1,1.7))

target_plot <- custom_dimplot(metadata = meta, 
               dimred_colnames = "umapscanvi", 
               colorby = "cell_costs_target", 
               label_samples = FALSE, 
                color_bar_lims = c(-0.1,1.7))

source_plot + target_plot + patchwork::plot_layout(guides = "collect")
```

```{r fig.height=7, fig.width=15, warning=FALSE}
bplot1 <- ggplot(meta, aes(x= id, y = cell_costs_source)) +
  geom_point(aes(color = cell_costs_source),
             position = position_jitter(), alpha = 0.5) +
  geom_violin(alpha = 0.2, color = "grey80") +
  scale_y_continuous(limits = c(-0.1,1.7)) +
  scale_color_viridis_c(limits = c(-0.1,1.7)) +
  theme_bw()  +
  theme(axis.text.x = element_text(angle = 35, vjust =1, hjust = 1))

bplot2 <- ggplot(meta, aes(x= id, y = cell_costs_target)) +
  geom_point(aes(color = cell_costs_target), 
             position = position_jitter(), alpha = 0.5) +
  geom_violin(alpha = 0.2, color = "grey80") +
  scale_y_continuous(limits = c(-0.1,1.7)) +
  scale_color_viridis_c(limits =  c(-0.1,1.7)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 35, vjust =1, hjust = 1))

bplot1 + bplot2 + patchwork::plot_layout(guides = "collect")
```

```{r}
class(tp$adata$uns$moscot_results$cell_transition) #"python.builtin.dict" 
class(tp$adata$uns$moscot_results$cell_transition$transitions_0_3) #"python.builtin.dict" 
# py_to_r(tp$adata$uns$moscot_results$cell_transition$transitions_0_50) # convert to list
# tp$cell_transition()
# names(tp$adata$uns$moscot_results$cell_transition)
```

```{r}
transition_heatmap <- mt$plotting$cell_transition(obj = tp,
                                                  key = "transitions_0_50",
                                                  dpi = 125L,
                                                  # return_fig = TRUE,
                                                  save = here::here("iPSC_motor_neuron_time_point_0_to_50_transition_matrix.png"))

transition_heatmap
```

```{r fig.height=5, fig.width=7}
transition_heatmap(temporal_problem = tp, 
                   transition_mat_name = "transitions_0_3")

transition_heatmap(temporal_problem = tp, 
                   transition_mat_name = "transitions_0_50")
```

Next steps, FOCUS ON TIME0 microglia and dl3 marker genes. 
- look at gene-module-scores for the ipsc and cell-cycle marker scores shared by Changho.  
- Experimentally, thaw vial of iPSC --> expand for 2-3 day in iPSC culture/pluripotent stem-cell media and then harvested for the time-course iPSC-MN culture. 
- should not be spontaineous differentiating into any lineage. 
- DEGs from DL3 (~499 cells), microglia (~18 cells), progenitor (~3043 cells) vs all others to Changho. 
  - within time-point 0 
  - across time-points

```{r}
meta %>% 
  filter(time_point == 0) %>% 
  group_by(subtype_standardized) %>% 
  dplyr::count()
```


ValueError: 'pyqt5' is not a valid value for backend; supported values are ['GTK3Agg', 'GTK3Cairo', 'GTK4Agg', 'GTK4Cairo', 'MacOSX', 'nbAgg', 'QtAgg', 'QtCairo', 'Qt5Agg', 'Qt5Cairo', 'TkAgg', 'TkCairo', 'WebAgg', 'WX', 'WXAgg', 'WXCairo', 'agg', 'cairo', 'pdf', 'pgf', 'ps', 'svg', 'template']
  
  
```{r eval=FALSE}
tp$sankey(source = 0L,
          target = 3L,
          source_groups = "subtype_standardized",
          target_groups = "subtype_standardized",
          forward = TRUE, 
          key_added = "sankey_0_3")

names(tp$adata$uns$moscot_results$sankey)

# dont have the correct system libraries installed. 
plt$use('TkAgg')

sanky_p1 <- mt$plotting$sankey(obj = tp,
                  key = "sankey_0_3", 
                  return_fig = TRUE)

# class(sanky_p1)
sanky_p1$show()
```


### Real Time Kernal

https://cellrank.readthedocs.io/en/latest/api/_autosummary/kernels/cellrank.kernels.RealTimeKernel.html#cellrank.kernels.RealTimeKernel.from_moscot

1. sparsify OT transport maps by removing entries below a certain threshold
* entropic regularization yields dense matrices which would make CellRank analysis very slow. 
2. use OT transport maps and molecular similarity to **model transitions across and within time points**
3. row-normalize the resulting cell-cell transition matrix (including all time points) and construct the Markov chain.  

```{r}
#  Key in obsp where the transition matrix is stored. The parameters should be stored in adata.uns['{key}_params'].
tmk <- cr$kernels$RealTimeKernel$from_adata(adata = "results/day0_day50/cellrank/iPSC_MNs_day0-day50_moscot_cellrank_RealTimeKernel.h5ad",
                                            key = "T_fwd")
```

compute_transition_matrix:
--> already completed in the MOSCOT temporal problem steps. Possibly use a PrecomputedKernel?
Compute transition matrix based on transcriptomic similarity.

Uses symmetric, weighted kNN graph to compute symmetric transition matrix. 
The connectivities are computed using neighbors(). 
- Selected to use: UMAP connectivities 
- Could try - Gaussian-kernel-based connectivities with adaptive kernel width (is there a benefit?)

compute_transition_matrix
- possible also use RNA-velocity based analysis to define the trajectories
- do we see the same or similar trends?

```{r eval=FALSE}
cr$settings$verbosity = 2L

# Set up the RealTimeKernel
tmk <-
cr$kernels$RealTimeKernel$from_moscot(problem =  tp,
                                           kwargs = list("time_key" = "day",
                                                         "policy"="sequential"))

# potentially use:
# cr$kernels$PrecomputedKernel(object = tp$adata$uns$moscot_results$cell_transition$transitions_0_50)
# tmk$backward

# compute the transition matrix
# how to determine connection weight cutoffs? - perhaps no worth re-computing if already done in Moscot TemporalProblem
# https://github.com/theislab/cellrank/issues/946
tmk$compute_transition_matrix(self_transitions="all", 
                              threshold="auto_local", 
                              conn_weight = 0.2,
                              conn_kwargs = list(use_rep = "X_scANVI",
                                                  metric = "cosine",
                                                  random_state = seed_val,
                                                  n_neighbors = 15L))

tmk # Using automatic `threshold` for each coupling separately

#https://cellrank.readthedocs.io/en/latest/notebooks/tutorials/general/100_getting_started.html#writing-and-reading-a-kernel
tmk$write_to_adata()
tmk$adata$write_h5ad("results/day0_day50/cellrank/iPSC_MNs_day0-day50_moscot_cellrank_RealTimeKernel.h5ad")
```
    
```{r eval=FALSE}
transition_mat <- tmk$transition_matrix %>% 
  py_to_r() %>% 
  as.matrix()

# outputs python class
# "dgRMatrix"
# attr(,"package")
# [1] "Matrix"

# unnamed - so will visualize and see if this makes sense
# added cell-barcodes as the rownames and colnames
rownames(transition_mat) <- rownames(py_to_r(tmk$adata$obs))
colnames(transition_mat) <- rownames(py_to_r(tmk$adata$obs))
dim(transition_mat) # 86,954 86,954


job::job({
  saveRDS(transition_mat, file = "results/day0_day50/cellrank/iPSC_MNs_day0-day50_moscot_cellrank_RealTimeKernel_transition_mat.RDS")
}, import = c("transition_mat"))
rm(transition_mat)
```

```{r}
# tmk$plot_projection(basis = "X_umap")
# tmk$transition_matrix
tmk$shape
tmk$time
tmk$params
tmk$kernels
cpl <- py_to_r(tmk$couplings)

cpl$`(0, 3)`
# class(cpl) #"python.builtin.dict"   "python.builtin.object"
```

The early progenitors pops do go through self-renewal into more progenitors, so that their population numbers will remain high even at later time points
- so its not unexpected that progenitor class labels do not go to zero at time 50.

```{r fig.height=15, fig.width=15}
tmk$plot_single_flow(
    cluster = "progenitor",
    cluster_key="subtype_standardized", #subtype_standardized_subclusters
    time_key="day",
    clusters=unique(meta$subtype_standardized),
    figsize = c(15L ,10L),
    dpi = 150L,
    save =  here::here("figures/iPSC_MNs_day0-day50_moscot_cellrank_progenitor_single_flow_plot.pdf") 
)

tmk$plot_single_flow(
    cluster = "motorneurons",
    cluster_key="subtype_standardized", #subtype_standardized_subclusters
    time_key="day",
    clusters=unique(meta$subtype_standardized),
    figsize = c(15L ,10L),
    dpi = 150L,
    save =  here::here("figures/iPSC_MNs_day0-day50_moscot_cellrank_motorneuron_single_flow_plot.pdf") 
)
```

```{r fig.height=15, fig.width=15, eval=FALSE}
# Finish (0:01:48)
tmk$plot_random_walks(
    n_sims = 200L,
    max_iter = 500L,
    # successive_hits = 3L,
    start_ixs=list("day" = c(0.0)),
    basis="X_umap",
    seed = seed_val,
    linewidth=0.5, 
    linealpha=0.2,
    figsize = c(10L ,10L),
    dpi = 150L,
    save = here::here("figures/iPSC_MNs_day0-day50_moscot_cellrank_random_walks.pdf")
)
```


### Identify Initial and Terminal States

CellRank decomposes cellular dynamics into macrostates: Based on Generalized Perron Cluster Cluster analysis (GPCCA), 

https://cellrank.readthedocs.io/en/latest/notebooks/tutorials/estimators/600_initial_terminal.html

--> Double check the algorithm
---> use the algorithm with known terminal and initial states! 
---> Changho has some experimental data with 2-3 time-points



uses the GPCCA algorithm as implemented in pyGPCCA to compute macrostates by maximizing for metastability
Using the GPCCA algorithm, CellRank generates as coarse-grains a cell-cell transition matrix onto the macro-state level

This transition matrix aggregates the single-cell Markov chain to a macrostate-level Markov chain. 
Entries in this matrix tell us how likely macrostates are to transition into one-another. 

How is the goodness of fit for the number of macrostates selected using minChi criterion? 
- the macrostates are selected from the temporal problem which is generating the cell-cell transition matrix (essentially probs that cellA --> cellB)
- but what is the loss is the metric?

```{r}
gpcca <- cr$estimators$GPCCA$read(fname = here::here("results/day0_day50/cellrank/gpcca/iPSC_MNs_day0-day50_moscot_cellrank_gpcca.pickle"))
gpcca
```


Using n_states=c(6L, 20L)
- identified 14 macrostates and did not find overlapping initial and terminal states

```{r fig.height=5, fig.width=10, eval=FALSE}
# set-up the estimators
gpcca <- cr$estimators$GPCCA(tmk) # this works

# fit the clusters 
# two key outputs: the soft assignment of cells to macrostates, and a matrix of transition probabilities among these macrostates
#  the algorithm to scan this interval for the optimal number of macrostates (4, 12)
# Make sure to have the scientific computing libraries PETSc and SLEPc installed (see set-up chunks above)
gpcca$fit(cluster_key="subtype_standardized",
          n_states=c(10L, 40L)) # increase the number the macrostates

# gpcca

# Predict the terminal states of cells/clusters
# values reflect our confidence in assigning a cell to a terminal state
gpcca$predict_terminal_states(allow_overlap = FALSE)

# predict the initial states of cells/clusters
# by default the algorithm is expecting there is only 1 initial state cell type - perhaps there could be > 1?
gpcca$predict_initial_states(allow_overlap = FALSE,
                             n_states = 1L)

# manually set the initial state cells as day 0 iPSC cell cluster and compare the results 
```

GPCCA[kernel=RealTimeKernel[n=86954], initial_states=['progenitor_2'], terminal_states=['astrocyte', 'dl4_1', 'dl4_2', 'motorneurons_1', 'motorneurons_3', 'progenitor_4', 'progenitor_8']]

Computing Schur decomposition
Adding `adata.uns['eigendecomposition_fwd']`
       `.schur_vectors`
       `.schur_matrix`
       `.eigendecomposition`
    Finish (0:00:17)
Calculating minChi criterion in interval `[6, 20]`
Computing `14` macrostates
Computing `14` macrostates
Adding `.macrostates`
       `.macrostates_memberships`
       `.coarse_T`
       `.coarse_initial_distribution
       `.coarse_stationary_distribution`
       `.schur_vectors`
       `.schur_matrix`
       `.eigendecomposition`
    Finish (0:08:33)
    
  Adding `adata.obs['term_states_fwd']`
     `adata.obs['term_states_fwd_probs']`
     `.terminal_states`
     `.terminal_states_probabilities`
     `.terminal_states_memberships
  Finish`

```{r}
gpcca$params
memberships <- gpcca$adata$obsm$get(key = 'macrostates_fwd_memberships')

# class(memberships)
# memberships
```

```{r eval=FALSE}
gpcca <- cr$estimators$GPCCA(tmk) # this works

gpcca$compute_schur(n_components = 40L)

gpcca$plot_spectrum(real_only=TRUE,
                     save = here::here("figures/tmk_plot_spectrum.pdf"), 
                     figsize = c(10L,10L),
                     dpi = 125L)
gpcca$compute_macrostates(n_states=17L,
                          cluster_key="subtype_standardized")

# Computing `17` macrostates
# Adding `.macrostates`
#        `.macrostates_memberships`
#        `.coarse_T`
#        `.coarse_initial_distribution
#        `.coarse_stationary_distribution`
#        `.schur_vectors`
#        `.schur_matrix`
#        `.eigendecomposition`
#     Finish (0:15:24)

gpcca$predict_terminal_states(allow_overlap = FALSE)
gpcca$predict_initial_states(allow_overlap = FALSE,
                             n_states = 1L)

gpcca$write(fname = here::here("results/day0_day50/cellrank/gpcca/iPSC_MNs_day0-day50_moscot_cellrank_gpcca_nstates_17.pickle"),
            write_adata = TRUE)

```

```{r fig.height=7, fig.width=7}
gpcca$plot_coarse_T()
```

```{r fig.height=7, fig.width=7}
gpcca$plot_macrostates(which="initial", discrete=FALSE)
gpcca$plot_macrostates(which="terminal", discrete=FALSE)
```

Macrostates, and their classification as initial or terminal, are written to the GPCCA estimator and can be inspected conveniently via initial_states and terminal_states.

```{r}
temp <- gpcca$adata$obs %>% 
  py_to_r() %>% 
  select(orig.ident, time_point, matches("states_fwd_probs"))

quantile(temp$term_states_fwd_probs)
quantile(temp$init_states_fwd_probs)
```

```{r fig.height=10, fig.width=20}
# gpcca$plot_macrostates(which="all",
#                        discrete=TRUE, 
#                        legend_loc="center left")
# gpcca$plot_macrostates(which="terminal", 
#                        legend_loc="center left")
meta <- py_to_r(gpcca$adata$obs) %>% 
  mutate_at(vars(macrostates_fwd,init_states_fwd, term_states_fwd), ~ as.character(.) %>% 
           ifelse(is.na(.), "other",.))

# Add metadata
ipsc_obj <- AddMetaData(ipsc_obj, metadata = select(meta, day:init_states_fwd_probs))

# meta$macrostates_fwd %>% table()
n_states <- length(unique(meta$macrostates_fwd))
cc_states <- colors_vector[1:n_states] %>% 
  set_names(unique(meta$macrostates_fwd)) 
cc_states["other"] <- "grey95"


p1 <- custom_dimplot(metadata = meta,
               colorby = "macrostates_fwd",
               dimred_colnames = "umapscanvi", 
               custom_colors = cc_states) +
  labs(title = "macrostates_fwd")

p2 <- custom_dimplot(metadata = meta,
               colorby = "init_states_fwd",
               dimred_colnames = "umapscanvi", 
               custom_colors = cc_states) +
  labs(title = "init_states_fwd")
  theme(legend.position = "none")
  
p3 <- custom_dimplot(metadata = meta,
               colorby = "term_states_fwd",
               dimred_colnames = "umapscanvi", 
               custom_colors = cc_states) +
  labs(title = "term_states_fwd") +
  theme(legend.position = "none")

p1 + p2 + p3 + patchwork::plot_layout(guides = "collect") & theme(legend.position = 'top')
```

```{r}
table(meta$macrostates_fwd)
length(unique(meta$macrostates_fwd)) #15
# tail(colnames(meta), n = 20)
```

```{r}
check <- meta %>% 
  select(orig.ident, time_point, batch,
         subtype_standardized, 
         macrostates_fwd:init_states_fwd_probs)

head(check)


check %>% 
  filter(init_states_fwd != "other") %>% 
  select(time_point, init_states_fwd, term_states_fwd, 
         term_states_fwd_probs,init_states_fwd_probs) %>% 
  arrange(desc(init_states_fwd_probs))
```

```{r}
class(gpcca$coarse_stationary_distribution)
gpcca$coarse_stationary_distribution
```

```{r fig.height=10, fig.width=10}
gpcca$plot_coarse_T(save = here::here("figures/gpcca_nstates_17_plot_coarse_T.pdf"), 
                     figsize = c(10L,10L), dpi = 125L)


gpcca$plot_macrostate_composition(key="subtype_standardized",
                                  save = here::here("figures/gpcca_nstates_17_plot_macrostate_composition.pdf"),
                                  figsize=c(15L, 10L), dpi = 125L)
```

```{r fig.width=12}
mstate_levels <- unique(ipsc_obj$macrostates_fwd) %>% 
  .[order(.)] %>% 
  as.factor()

mstate_levels <- relevel(mstate_levels, ref = "other")
# mstate_levels

ipsc_obj$macrostates_fwd_fct <- factor(ipsc_obj$macrostates_fwd, levels = mstate_levels)
Idents(ipsc_obj) <- ipsc_obj$macrostates_fwd_fct

VlnPlot(ipsc_obj, features = "time_point", cols = cc_states) +
  scale_y_continuous(breaks = seq(0,50, by = 2.5))

```

```{r fig.height=5, fig.width=10, eval=FALSE}
# marker_genes_iPSC
DefaultAssay(ipsc_obj) <- "RNA"
ipsc_obj <- ScaleData(ipsc_obj, features = unlist(marker_genes_iPSC))
Idents(ipsc_obj) <- meta$macrostates_fwd

# VlnPlot(ipsc_obj, features = marker_genes_iPSC$iPSCs)
Seurat::DoHeatmap(ipsc_obj, features = marker_genes_iPSC$iPSCs)

dim(ipsc_obj[["RNA"]]$scale.data)
class(ipsc_obj[["RNA"]]$scale.data)
head(colnames(ipsc_obj[["RNA"]]$scale.data))
```

```{r fig.height=10, fig.width=10, eval=FALSE}
pheatmap::pheatmap(mat = ipsc_obj[["RNA"]]$scale.data,
                   annotation_col = select(meta, macrostates_fwd))
```


### Cell Fate Probabilities 

We recommend the 'ilu' preconditioner for badly conditioned problems.

compute how likely each cell is to reach each terminal state using compute_fate_probabilities().

```{r}
gpcca
```

What about the macrostates that were not selected as the terminal states? these are simply the intermediate states. 

```{r eval=FALSE}
# compute fate_probabilities by aggregating over all random walks that start in a given cell and end in some terminal population
# use all states defined in terminal_states
gpcca$compute_fate_probabilities(preconditioner = "ilu", n_jobs = 4)
gpcca
```

Computing fate probabilities
100%|██████████| 7/7 [00:26<00:00,  3.73s/]
Adding `adata.obsm['lineages_fwd']`
       `.fate_probabilities`
    Finish (0:00:27)
    
```{r fig.height=10, fig.width=20}
gpcca$plot_fate_probabilities(same_plot=FALSE)
```

```{r fig.height=10, fig.width=10}
gpcca$plot_fate_probabilities(same_plot=TRUE)
```

```{r fig.height=10, fig.width=10, eval=FALSE}
cr$pl$circular_projection(ipsc_adata, 
                          keys=c("subtype_standardized_subclusters"),
                          legend_loc="right")

ipsc_obj$subtype_standardized %>%
  unique() %>%
  grep("motor", ., value = TRUE)

cr$pl$aggregate_fate_probabilities(
    ipsc_adata,
    mode="violin",
    lineages=c("motorneurons"),
    cluster_key="subtype_standardized",
    clusters=mn_states,
)
```

### Driver Genes 

 correlate expression values with fate probabilities.
 
```{r}
library(clusterProfiler)
```
 
```{r}
# fate probabilites / lineages = For each cell, this computes the probability of being absorbed in any of the terminal_states. 
lineages <- gpcca$adata$obsm$get(key = 'lineages_fwd')
lineages

# gpcca$fate_probabilities
```

```{r eval=FALSE}
drivers_df <- gpcca$compute_lineage_drivers(method = 'fisher',
                                            cluster_key = 'subtype_standardized',
                                            n_jobs = 2) 

gpcca$write(fname = here::here("results/day0_day50/cellrank/gpcca/iPSC_MNs_day0-day50_moscot_cellrank_gpcca.pickle"),
            write_adata = TRUE)
```


### GSEA

```{r}
mn_markers <- marker_genes_chun_list[grep("motor", names(marker_genes_chun_list))]

out_len <- max(sapply(mn_markers, length))
mn_markers_df <- purrr::map_dfc(mn_markers, function(x) {
  n_genes <- length(x)
  if(length(x) < out_len){
    dummy_n <- out_len - length(x) 
    dummy <- rep("", dummy_n)
    x <- c(x, dummy)
  }
  return(x)
}) %>% 
  pivot_longer(cols = everything(), 
               names_to = "mn_marker_gene_source",
               values_to = "gene_name") %>% 
  filter(gene_name != "") %>% 
  arrange(gene_name) %>% 
  group_by(gene_name) %>% 
  mutate_at(vars(mn_marker_gene_source), ~paste(., collapse = "; ")) %>% 
  distinct()

mn_markers_df
```

```{r}
gene_annots <- ipsc_obj@assays$RNA@meta.data %>% 
  select(orig_gene_name = gene_name , everything())

head(gene_annots)
# dim(gene_annots)
# identical(ipsc_obj@assays$RNA@meta.data$gene_name_fix, rownames(ipsc_obj[["RNA"]])) #OK


mart <- biomaRt::useMart(biomart="ensembl", dataset="hsapiens_gene_ensembl")
# biomaRt::listAttributes(mart) %>% 
#   filter(grepl("ensembl|entrez|ncbi", name))

entrez_genes <- biomaRt::getBM(attributes = c("ensembl_gene_id","entrezgene_id"),
                               filters = "ensembl_gene_id",
                               values = gene_annots$ensembl_id,
                               mart = mart,
                               uniqueRows = TRUE)

head(entrez_genes)
table(duplicated(entrez_genes$ensembl_gene_id))
```

```{bash, eval=FALSE}
cd resources/gene_sets
curl -o "wikipathways_filtered.json" -X GET "https://webservice.wikipathways.org/findPathwaysByText?query=motor%20OR%20spinal%20OR%20spine%20OR%20endoderm%20OR%20interneuron%20OR%20fibroblast%20OR%20ipsc%20OR%20pluripotent&species=Homo%20sapiens&format=json"
```

```{r}
pathway_meta <- rjson::fromJSON(file = "resources/gene_sets/wikipathways_filtered.json")$result

sel_paths <- "resources/gene_sets/wikipathways_filtered_spinal_cord_motorneuron_endoderm_fibroblast.csv"


if(!file.exists(sel_paths)){
  term_to_gene <- purrr::map_dfr(1:length(pathway_meta), function(i){
      pway_info <- pathway_meta[[i]]
      id <- pway_info$id
      print(id)
      pname <- tolower(pway_info$name) %>% 
        gsub("\\s{1,}","_",.)
      
      url <- glue("https://www.wikipathways.org/wikipathways-assets/pathways/{id}/{id}-datanodes.tsv")
      tsv <- RCurl::getURI(url = url)
      tsv <- gsub("\\t\\tGeneProduct", "\tGeneProduct", tsv) 
      
      OK <- all(c(grepl("\\t", tsv), i != 38))
      if(OK){
        df <- read.table(text = tsv, 
                         sep = "\t",
                         quote = "",
                         header = TRUE) %>% 
          janitor::clean_names() %>% 
          filter(type == "GeneProduct") %>% 
          mutate_at(vars(ensembl:hgnc), ~str_split_fixed(., ":", n = 2)[,2]) %>% 
          mutate_all(as.character) %>% 
          mutate(term = pname, 
                 species = pway_info$species,
                 id = id) %>% 
          select(term, everything())
      }else{
        df <- data.frame()
      }
      return(df)
  }) %>% 
  mutate(gene = label) %>% 
  mutate_all(~replace_na(., replace = "")) %>% 
  mutate_at(vars(ensembl), ~case_when(
    ensembl == "" & grepl("ensembl", identifier) ~ str_split_fixed(identifier, ":", n = 2)[,2],
    TRUE ~ .
  )) %>% 
  mutate_at(vars(gene), ~gsub("@", "", .) %>% toupper(.)) %>% 
  select(id, term, gene, ensembl, everything())
  
  write.csv(term_to_gene, "resources/gene_sets/wikipathways_filtered_spinal_cord_motorneuron_endoderm_fibroblast.csv", row.names = FALSE)

} else {
  term_to_gene <- read.csv(sel_paths)
}


head(term_to_gene)
table(term_to_gene$ensembl == "")
table(term_to_gene$gene == "")
```

```{r}
drivers_df <- gpcca$adata$varm$get('terminal_lineage_drivers') %>% 
  py_to_r() %>% 
  select(all_of(colnames(.)[order(colnames(.))])) %>% 
  rownames_to_column("gene_name") %>% 
  pivot_longer(cols = -gene_name, 
               names_to = "macrostate", 
               values_to = "stat_value") %>% 
  filter(!is.nan(stat_value)) %>% 
  mutate(stat = str_split_fixed(macrostate, pattern = "_", n = 2)[,2],
         macrostate = str_split_fixed(macrostate, pattern = "_", n = 2)[,1]) %>% 
  mutate(macrostate_clust = gsub("^([0-9]_).+$","\\1", stat) %>% 
                      gsub("^[a-z]+.+$|_$", "", .),
         stat = gsub("^[0-9]_","", stat)) %>% 
  mutate(macrostate = ifelse(macrostate_clust != "",
                             paste(macrostate, macrostate_clust, sep = "_"), 
                             macrostate)) %>% 
  pivot_wider(id_cols = c(macrostate, gene_name),
              names_from = stat,
              values_from = stat_value) %>% 
  left_join(., gene_annots, by = c("gene_name"="gene_name_fix")) %>% 
  left_join(.,mn_markers_df, by = "gene_name") 

drivers_df
# table(drivers_df$macrostate)
```

```{r}
mn_genes <- drivers_df %>% 
  filter(grepl("motorneurons_",macrostate),
         qval < 0.001) %>%
  mutate(neg_log10_q = -log10(qval+.Machine$double.xmin),
         macrostate = as.factor(macrostate)) %>%
  arrange(macrostate, desc(corr), qval,.by_group = TRUE)
  
mn_genes %>% 
  group_by(macrostate, .drop = FALSE) %>%
  arrange(desc(corr), qval,.by_group = TRUE) %>%
  dplyr::slice(1:20) %>%
  ungroup() %>% 
  View()

# table(mn_genes$macrostate)
table(mn_genes$macrostate)
```

### GSEA

```{r}
set.seed(seed_val)

pathway_info <- term_to_gene %>% 
  select(term, id,species) %>% 
  distinct()

term_states <- unique(drivers_df$macrostate) %>% 
  set_names(., value=.)
gsea_res <- purrr::map(term_states, function(state){
  
  in_genes <- filter(drivers_df,
                  macrostate == state, 
                  qval < 0.001)  %>% 
  arrange(desc(corr)) %>% 
  distinct()
  
  gsea_res <- GSEA(geneList = pull(in_genes,corr, name = ensembl_id),
                            pvalueCutoff = 0.05, 
                            TERM2GENE = select(term_to_gene, term, ensembl),
                            seed = seed_val)@result
  gsea_res <- gsea_res %>% 
      left_join(.,pathway_info,  by = c("Description"="term")) %>% 
      arrange(desc(NES)) %>% 
      mutate(macrostate = state) %>% 
      select(macrostate, id, NES, qvalue, everything())
})
```


# Example Data 

```{r fig.height=10,fig.width=10}
hspc_adata = mt$datasets$hspc()
hspc_adata$obs["day"] = hspc_adata$obs["day"]$astype("category")

problem = mt$problems$TemporalProblem(hspc_adata)
problem
# problem$adata$obs['day']$cat$categories
# Index([2, 3, 4, 7], dtype='int64')

problem = problem$prepare(time_key="day", 
                          joint_attr = 'X_umap_GEX')

problem = problem$solve(epsilon=1e-3, tau_a=0.95, tau_b = 0.99, scale_cost="mean")

# problem.sankey(
#     source=2,
#     target=7,
#     source_groups="cell_type",
#     target_groups="cell_type",
#     forward=True,
# )

rtk = cr$kernels$RealTimeKernel$from_moscot(problem = problem, 
                                            kwargs = list("time_key" = "day",
                                                        "policy"="sequential"))
rtk = rtk$compute_transition_matrix(self_transitions="all", 
                              conn_weight=0.2, 
                              threshold="auto")

problem$temporal_key
rtk$couplings
rtk

# set-up the estimators
gp <- cr$estimators$GPCCA(rtk)

# fit the clusters 
gp$fit(cluster_key="cell_type",
       n_states=c(4L, 12L))

gp

gp$plot_macrostates(which="all", discrete=TRUE, legend_loc="center left")
gp$predict_initial_states() #   ValueError: Found `30` overlapping cells between initial and terminal states
gp$predict_terminal_states(allow_overlap=TRUE)

# not showing plot either 
gp$plot_coarse_T(show_stationary_dist = TRUE, order='stability', figsize=c(8L, 8L), annotate = TRUE)
```


# Session Info

```{r}
cr$logging$print_versions()
# cellrank==2.0.2 scanpy==1.9.5 anndata==0.10.5.post1 numpy==1.26.4 numba==0.59.0 scipy==1.11.4 pandas==2.1.0 pygpcca==1.0.4 scikit-learn==1.1.3 statsmodels==0.14.0 python-igraph==0.10.8 scvelo==0.3.1 pygam==0.9.1 matplotlib==3.7.1 seaborn==0.13.2
```

```{r}
sessionInfo()
```

